
[FILE START: Assets\Scripts\Editor\CodeZipper.cs]
using UnityEngine; using UnityEditor; using System.IO; using System.Text; using System.Text.RegularExpressions; public class CodeZipper : EditorWindow { [MenuItem("Tools/Code Zipper")] public static void ShowWindow() { GetWindow<CodeZipper>("Code Zipper"); } private void OnGUI() { GUILayout.Space(20); GUILayout.Label("��Ŀ������ȡ����", EditorStyles.boldLabel); GUILayout.Space(10); EditorGUILayout.HelpBox("�ù��߽���ȡ Assets/Scripts ������ .cs �ļ����Ƴ�ע���뻻�У��������һ���ı��ļ���\n\n�ļ��������ڣ�\n��Ŀ��Ŀ¼/ProjectAllCodesList/", MessageType.Info); GUILayout.Space(20); if (GUILayout.Button("Start Zip (��ȡ��ѹ��)", GUILayout.Height(40))) { ZipCodes(); } } private void ZipCodes() { string scriptsFolder = Path.Combine(Application.dataPath, "Scripts"); if (!Directory.Exists(scriptsFolder)) { EditorUtility.DisplayDialog("����", "δ�ҵ� 'Assets/Scripts' �ļ��У�\n��ȷ����Ĵ��붼�� Scripts Ŀ¼�¡�", "ȷ��"); return; } string[] scriptPaths = Directory.GetFiles(scriptsFolder, "*.cs", SearchOption.AllDirectories); StringBuilder sb = new StringBuilder(); int fileCount = 0; foreach (string path in scriptPaths) { string content = File.ReadAllText(path); string compressedContent = CompressCode(content); string relativePath = path.Replace(Application.dataPath, "Assets"); sb.Append($"\n[FILE START: {relativePath}]\n"); sb.Append(compressedContent); sb.Append($"\n[FILE END]\n"); fileCount++; } string projectRoot = Directory.GetParent(Application.dataPath).FullName; string targetDir = Path.Combine(projectRoot, "ProjectAllCodesList"); if (!Directory.Exists(targetDir)) { Directory.CreateDirectory(targetDir); } string outputFileName = GetNextVersionFileName(targetDir); string finalPath = Path.Combine(targetDir, outputFileName); File.WriteAllText(finalPath, sb.ToString()); EditorUtility.DisplayDialog("���", $"�ɹ���ȡ {fileCount} ���ű��ļ���\n(��Դ: Assets/Scripts)\n\n�ѱ�����:\n{finalPath}", "ȷ��"); EditorUtility.RevealInFinder(finalPath); } private string CompressCode(string source) { string noBlockComments = Regex.Replace(source, @"/\*[\s\S]*?\*/", ""); string noLineComments = Regex.Replace(noBlockComments, @" string singleLine = Regex.Replace(noLineComments, @"\s+", " "); return singleLine.Trim(); } private string GetNextVersionFileName(string folderPath) { string baseName = "ProjectAllCodesV"; string extension = ".txt"; int version = 1; while (true) { string fileName = $"{baseName}{version}{extension}"; string fullPath = Path.Combine(folderPath, fileName); if (!File.Exists(fullPath)) { return fileName; } version++; } } }
[FILE END]

[FILE START: Assets\Scripts\Editor\SubclassSelectorDrawer.cs]
using System; using System.Linq; using UnityEditor; using UnityEngine; [CustomPropertyDrawer(typeof(SubclassSelectorAttribute))] public class SubclassSelectorDrawer : PropertyDrawer { public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { if (property.propertyType != SerializedPropertyType.ManagedReference) { EditorGUI.PropertyField(position, property, label, true); return; } var labelRect = new Rect(position.x, position.y, EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight); EditorGUI.LabelField(labelRect, label); var buttonRect = new Rect(position.x + EditorGUIUtility.labelWidth, position.y, position.width - EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight); string typeName = GetTypeName(property); if (EditorGUI.DropdownButton(buttonRect, new GUIContent(typeName), FocusType.Passive)) { ShowTypeMenu(property); } EditorGUI.PropertyField(position, property, GUIContent.none, true); } private void ShowTypeMenu(SerializedProperty property) { var menu = new GenericMenu(); string typeName = property.managedReferenceFieldTypename; if (string.IsNullOrEmpty(typeName)) return; var splitTypeString = typeName.Split(' '); var assemblyName = splitTypeString[0]; var className = splitTypeString[1]; var assembly = AppDomain.CurrentDomain.GetAssemblies() .FirstOrDefault(a => a.GetName().Name == assemblyName); if (assembly == null) { Debug.LogError($"[SubclassSelector] �Ҳ��� Assembly: {assemblyName}"); return; } Type baseType = assembly.GetType(className); if (baseType == null) { Debug.LogError($"[SubclassSelector] �Ҳ�������: {className}"); return; } var types = AppDomain.CurrentDomain.GetAssemblies() .SelectMany(s => s.GetTypes()) .Where(p => baseType.IsAssignableFrom(p) && p.IsClass && !p.IsAbstract); menu.AddItem(new GUIContent("None (Null)"), false, () => { property.managedReferenceValue = null; property.serializedObject.ApplyModifiedProperties(); }); foreach (var type in types) { string menuLabel = type.Name; menu.AddItem(new GUIContent(menuLabel), false, () => { property.managedReferenceValue = Activator.CreateInstance(type); property.serializedObject.ApplyModifiedProperties(); }); } menu.ShowAsContext(); } private string GetTypeName(SerializedProperty property) { if (string.IsNullOrEmpty(property.managedReferenceFullTypename)) return "Select Type..."; return property.managedReferenceFullTypename.Split('.').Last(); } public override float GetPropertyHeight(SerializedProperty property, GUIContent label) { return EditorGUI.GetPropertyHeight(property, label, true); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\CharacterDatabaseSO.cs]
using UnityEngine; using Unity.Netcode; using System.Collections.Generic; [CreateAssetMenu(fileName = "CharacterDatabase", menuName = "Game/Character Database")] public class CharacterDatabaseSO : ScriptableObject { public List<NetworkObject> characterPrefabs; public NetworkObject GetPrefabById(int id) { if (id >= 0 && id < characterPrefabs.Count) { return characterPrefabs[id]; } Debug.Log("��ȡĬ�Ͻ�ɫ"); return characterPrefabs[0]; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\DestructableCrate.cs]
using Unity.Netcode; using UnityEngine; public class DestructableCrate : NetworkBehaviour, IDamageable { [SerializeField] private NetworkObject _lootPrefab; private readonly NetworkVariable<int> _hp = new NetworkVariable<int>( 50, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public void TakeDamage(int amount, ulong attackerId) { _hp.Value -= amount; if( _hp.Value <= 0) { if(_lootPrefab != null) { var lootInstance = Instantiate(_lootPrefab, transform.position, Quaternion.identity); lootInstance.Spawn(); } GetComponent<NetworkObject>().Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\GameLifecycleManager.cs]
using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using UnityEngine.SceneManagement; public class GameLifecycleManager : NetworkBehaviour { [SerializeField] private BossController bossInstance; private List<PlayerNetworkCore> activePlayers = new List<PlayerNetworkCore>(); private bool isGameEnded = false; public static GameLifecycleManager Instance { get; private set; } public void Awake() { Instance = this; } public override void OnNetworkSpawn() { if (!IsServer) return; NetworkManager.Singleton.OnClientConnectedCallback += HandleClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback += HandleClientDisconnect; foreach (var client in NetworkManager.Singleton.ConnectedClientsList) { if (client.PlayerObject != null) { var playerCore = client.PlayerObject.GetComponent<PlayerNetworkCore>(); RegisterPlayer(playerCore); } } if (bossInstance != null) { bossInstance.OnBossDied += HandleBossDefeat; } } public override void OnNetworkDespawn() { if (!IsServer) return; if (NetworkManager.Singleton != null) { NetworkManager.Singleton.OnClientConnectedCallback -= HandleClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback -= HandleClientDisconnect; } } public void RegisterPlayer(PlayerNetworkCore player) { if (!IsServer || player == null) return; if (!activePlayers.Contains(player)) { activePlayers.Add(player); player.OnPlayerDied += HandlePlayerDeath; Debug.Log($"[Manager] Player Registered. ID: {player.OwnerClientId}. Total Players: {activePlayers.Count}"); } } public void UnregisterPlayer(PlayerNetworkCore player) { if (!IsServer || player == null) return; if (activePlayers.Contains(player)) { player.OnPlayerDied -= HandlePlayerDeath; activePlayers.Remove(player); Debug.Log($"[Manager] Player Unregistered. ID: {player.OwnerClientId}. Remaining: {activePlayers.Count}"); } } private void HandlePlayerDeath(PlayerNetworkCore deadPlayer) { if (isGameEnded) return; Debug.Log($"[Manager] HandlePlayerDeath Triggered for Player {deadPlayer.OwnerClientId}"); int aliveCount = 0; foreach (var p in activePlayers) { if (p != null && !p.IsDead) { aliveCount++; } } Debug.Log($"[Manager] Alive Count: {aliveCount}"); if (aliveCount <= 0) { EndGame(false); } } private void HandleClientConnected(ulong clientId) { if (NetworkManager.Singleton.ConnectedClients.TryGetValue(clientId, out var client)) { if (client.PlayerObject != null) { RegisterPlayer(client.PlayerObject.GetComponent<PlayerNetworkCore>()); } } } private void HandleClientDisconnect(ulong clientId) { } private void HandleBossDefeat() { if (isGameEnded) return; EndGame(true); } private void EndGame(bool isVictory) { isGameEnded = true; Debug.Log(isVictory ? "VICTORY! Loading WinScene..." : "DEFEAT! Loading Init..."); if (isVictory) { SceneManager.LoadScene("WinScene", LoadSceneMode.Single); } else { NetworkManager.Singleton.Shutdown(); SceneManager.LoadScene("Init", LoadSceneMode.Single); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\InteractCube.cs]
using UnityEngine; public class InteractCube : MonoBehaviour, IInteractable { private bool _stateBig = false; public string InteractionPrompt => "PickUp"; public void Interact(GameObject source) { if (_stateBig) { transform.localScale = Vector3.one * 2.0f; _stateBig = false; } else { transform.localScale = Vector3.one; _stateBig = true; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\InteracteHeal.cs]
using Unity.Netcode; using UnityEngine; public class InteracteHeal : NetworkBehaviour, IInteractable { public string InteractionPrompt => "Eat"; public void Interact(GameObject source) { ulong sourceId = source.GetComponent<NetworkObject>().NetworkObjectId; RequestInteractServerRpc(sourceId); } [ServerRpc(RequireOwnership = false)] private void RequestInteractServerRpc(ulong sourceId) { if(NetworkManager.SpawnManager.SpawnedObjects.TryGetValue(sourceId, out var sourceObject)) { if (Vector3.Distance(transform.position, sourceObject.transform.position) > 3.0f) return; if(sourceObject.TryGetComponent<PlayerNetworkHealth>(out var health)) { health.ServerHeal(10); GetComponent<NetworkObject>().Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\PickupItem.cs]
using Unity.Netcode; using UnityEngine; public class PickupItem : NetworkBehaviour, IInteractable { private int points = 10; public string InteractionPrompt => "Pickup"; public void Interact(GameObject source) { RequestPickupServerRpc(source.GetComponent<NetworkObject>().NetworkObjectId); } [ServerRpc(RequireOwnership = false)] private void RequestPickupServerRpc(ulong sourceId) { if (NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(sourceId, out var sourceNetObj)) { if (Vector3.Distance(transform.position, sourceNetObj.transform.position) > 3.0f) return; if (sourceNetObj.TryGetComponent<PlayerNetworkCore>(out var core)) { core.AddPointsServer(points); core.AddItem(gameObject.name); GetComponent<NetworkObject>().Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\PotionSpawner.cs]
using Unity.Netcode; using UnityEngine; public class PotionSpawner : NetworkBehaviour { [SerializeField] private NetworkObject potionPrefab; [SerializeField] private Transform[] spawnPoints; public override void OnNetworkSpawn() { if (IsServer) { foreach (var point in spawnPoints) { SpawnPotion(point.position); } } } private void SpawnPotion(Vector3 position) { if (potionPrefab == null) return; var instance = Instantiate(potionPrefab, position, Quaternion.identity); instance.Spawn(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\testBossSkill.cs]
using Unity.Netcode; using UnityEngine; public class testBossSkill : NetworkBehaviour { public SkillDataSO[] skills; public LayerMask goundLayer; void Start() { } void Update() { if (Input.GetMouseButtonDown(0)) { if( Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hit, 1000f, goundLayer)) { var targetpos = hit.point; transform.position = targetpos; } } if (Input.GetKeyDown(KeyCode.I)) { Debug.Log("boss�ͷż���2"); skills[0].Cast(gameObject, null, transform.position); } if (Input.GetKeyDown(KeyCode.O)) { Debug.Log("boss�ͷŴ���"); skills[1].Cast(gameObject, null, transform.position); } if (Input.GetKeyDown(KeyCode.P)) { Debug.Log("boss�ͷ�����"); skills[2].Cast(gameObject, null, transform.position); } } }
[FILE END]

[FILE START: Assets\Scripts\InitScene\ConnectionManager.cs]
using System; using System.Collections.Generic; using System.Text; using Unity.Netcode; using UnityEngine; using UnityEngine.SceneManagement; public class ConnectionManager : MonoBehaviour { [Header("Settings")] [SerializeField] private CharacterDatabaseSO characterDatabase; [SerializeField] private string gameSceneName = "Game"; private Dictionary<ulong, int> _clientSelectionData = new Dictionary<ulong, int>(); private void Start() { DontDestroyOnLoad(this); } private void OnEnable() { if (NetworkManager.Singleton != null) { SubscribeEvents(); } } private void SubscribeEvents() { UnsubscribeEvents(); NetworkManager.Singleton.ConnectionApprovalCallback += ApprovalCheck; NetworkManager.Singleton.OnClientConnectedCallback += OnClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback += OnClientDisconnect; Debug.Log("ConnectionManager: �����¼����ĳɹ���"); } private void UnsubscribeEvents() { if (NetworkManager.Singleton == null) return; NetworkManager.Singleton.ConnectionApprovalCallback -= ApprovalCheck; NetworkManager.Singleton.OnClientConnectedCallback -= OnClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback -= OnClientDisconnect; if (NetworkManager.Singleton.SceneManager != null) { NetworkManager.Singleton.SceneManager.OnLoadEventCompleted -= OnSceneLoadComplete; } } private void OnDestroy() { UnsubscribeEvents(); } public void StartHostWithCharacter(int characterIndex) { SubscribeEvents(); var payload = Encoding.ASCII.GetBytes(characterIndex.ToString()); NetworkManager.Singleton.NetworkConfig.ConnectionData = payload; NetworkManager.Singleton.NetworkConfig.PlayerPrefab = null; Debug.Log($"1. [Host] ׼�������ѡ���ɫ: {characterIndex}"); if (NetworkManager.Singleton.StartHost()) { Debug.Log("2. [Host] ����ɹ���"); if (NetworkManager.Singleton.SceneManager != null) { NetworkManager.Singleton.SceneManager.OnLoadEventCompleted += OnSceneLoadComplete; Debug.Log(" -> �����¼����ĳɹ�"); NetworkManager.Singleton.SceneManager.LoadScene(gameSceneName, LoadSceneMode.Single); } else { Debug.LogError("!!! ��������SceneManager ��ȻΪ�գ����� Inspector ���Ƿ�ѡ�� 'Enable Scene Management' !!!"); } } } public void StartClientWithCharacter(int characterIndex) { SubscribeEvents(); var payload = Encoding.ASCII.GetBytes(characterIndex.ToString()); NetworkManager.Singleton.NetworkConfig.ConnectionData = payload; NetworkManager.Singleton.NetworkConfig.PlayerPrefab = null; Debug.Log($"1. [Client] ׼�����ӣ�ѡ���ɫ: {characterIndex}"); NetworkManager.Singleton.StartClient(); } private void ApprovalCheck(NetworkManager.ConnectionApprovalRequest request, NetworkManager.ConnectionApprovalResponse response) { int charId = 0; if (request.Payload != null) { int.TryParse(Encoding.ASCII.GetString(request.Payload), out charId); } if (_clientSelectionData.ContainsKey(request.ClientNetworkId)) _clientSelectionData[request.ClientNetworkId] = charId; else _clientSelectionData.Add(request.ClientNetworkId, charId); Debug.Log($"3. [Server] ����ͨ��: �ͻ���ID {request.ClientNetworkId} ѡ���˽�ɫ {charId}"); response.Approved = true; response.CreatePlayerObject = false; } private void OnClientConnected(ulong clientId) { if (!NetworkManager.Singleton.IsServer) return; Debug.Log($"4. [Server] �ͻ��� {clientId} ���ӳɹ�����ǰ����: {SceneManager.GetActiveScene().name}"); if (SceneManager.GetActiveScene().name == gameSceneName) { Debug.Log($" -> �Ѿ�����Ϸ������ֱ�����ɽ�ɫ�� {clientId}"); SpawnPlayer(clientId); } else { Debug.Log($" -> ���� {SceneManager.GetActiveScene().name}���ݲ����ɣ��ȴ���������..."); } } private void OnSceneLoadComplete(string sceneName, LoadSceneMode loadSceneMode, List<ulong> clientsCompleted, List<ulong> clientsTimedOut) { if (!NetworkManager.Singleton.IsServer) return; if (!sceneName.Contains(gameSceneName)) return; Debug.Log($"5. [Server] ���� {sceneName} ������ϣ���ʼ��鲢���ɽ�ɫ..."); foreach (ulong clientId in NetworkManager.Singleton.ConnectedClientsIds) { if (NetworkManager.Singleton.ConnectedClients[clientId].PlayerObject == null) { Debug.Log($" -> Ϊ��� {clientId} ������ɫ"); SpawnPlayer(clientId); } } } private void SpawnPlayer(ulong clientId) { int charId = _clientSelectionData.ContainsKey(clientId) ? _clientSelectionData[clientId] : 0; NetworkObject prefab = characterDatabase.GetPrefabById(charId); if (prefab == null) return; Vector3 pos = new Vector3(clientId * 2, 1, 0); GameObject instance = Instantiate(prefab.gameObject, pos, Quaternion.identity); NetworkObject netObj = instance.GetComponent<NetworkObject>(); netObj.SpawnAsPlayerObject(clientId, true); Debug.Log($"6. [Server] �ɹ����ɽ�ɫ {charId} ����� {clientId}"); } private void OnClientDisconnect(ulong clientId) { if (NetworkManager.Singleton.IsServer) _clientSelectionData.Remove(clientId); } }
[FILE END]

[FILE START: Assets\Scripts\InitScene\InitSceneController.cs]
using UnityEngine; using UnityEngine.SceneManagement; public class InitSceneController : MonoBehaviour { void Start() { } void Update() { } public void OnStartClicke() { SceneManager.LoadScene("Game"); } }
[FILE END]

[FILE START: Assets\Scripts\WinScene\WinSceneController.cs]
using UnityEngine; using UnityEngine.SceneManagement; public class WinSceneController : MonoBehaviour { void Start() { } void Update() { } public void OnBtnBackToInitClicked() { SceneManager.LoadScene("Init"); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Camera\GameCameraManager.cs]
using UnityEngine; using Unity.Netcode; using Unity.Cinemachine; public class GameCameraManager : MonoBehaviour { public static GameCameraManager Instance { get; private set; } [Header("Cinemachine Components")] [SerializeField] private CinemachineCamera virtualCamera; [SerializeField] private CinemachineImpulseSource impulseSource; private void Awake() { Instance = this; } public void SetFollowTarget(Transform target) { if (virtualCamera != null) { virtualCamera.Follow = target; Debug.Log($"[Camera] Now following {target.name}"); } } public void ShakeCamera(float force) { if (impulseSource != null) { impulseSource.GenerateImpulse(force); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Camera\TestShake.cs]
using UnityEngine; using Unity.Cinemachine; public class TestShake : MonoBehaviour { public CinemachineCamera targetCamera; public NoiseSettings noiseProfile; void Update() { if (Input.GetKeyDown(KeyCode.T)) { Debug.Log("ǿ�Ʋ����𶯣�"); if (targetCamera != null && noiseProfile != null) { } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IDamageable.cs]
using UnityEngine; public interface IDamageable { void TakeDamage(int amount, ulong attackerId); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IInteractable.cs]
using UnityEngine; public interface IInteractable { string InteractionPrompt { get; } void Interact(GameObject source); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IKnockBackable.cs]
using UnityEngine; public interface IKnockBackable { void ApplyKnockbackServer(Vector3 forceDir, float forceStrength); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerController.cs]
using System; using Unity.Netcode; using UnityEditor.PackageManager; using UnityEngine; using UnityEngine.Rendering; public class PlayerController : NetworkBehaviour { public enum MotionState : byte { Idle = 0, Moving = 1, Attack = 2 } private readonly NetworkVariable<MotionState> _motionState = new NetworkVariable<MotionState>( MotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public MotionState Motion => _motionState.Value; [Header("Settings")] [SerializeField] private float moveSpeed = 5f; [SerializeField] private float rotateSpeed = 10f; [SerializeField] private float attackDistance = 20f; [SerializeField] private LayerMask groundLayer; [SerializeField] private LayerMask interactLayer; private IPlayerState currentState; private Vector3 _serverTargetPosition; public Camera MainCamera { get; private set; } public Rigidbody Rigidbody { get; private set; } public CapsuleCollider CapsuleCollider { get; private set; } public float MoveSpeed => moveSpeed; public float RotationSpeed => rotateSpeed; public Vector3 ServerTargetPosition => _serverTargetPosition; private PlayerNetworkHealth _healthComponent; public LayerMask GroundLayer => groundLayer; public LayerMask InteractLayer => interactLayer; private void Awake() { MainCamera = Camera.main; Rigidbody = GetComponent<Rigidbody>(); CapsuleCollider = GetComponent<CapsuleCollider>(); _healthComponent = GetComponent<PlayerNetworkHealth>(); } public override void OnNetworkSpawn() { if (IsServer) { _serverTargetPosition = transform.position; _motionState.Value = MotionState.Idle; _healthComponent.OnHealthChanged += CheckDeath; } if (IsOwner) { BindLocalPlayerUI(); _motionState.OnValueChanged += OnMotionStateChanged; AppyMotionState(_motionState.Value); } } private void OnMotionStateChanged(MotionState oldState, MotionState newState) { AppyMotionState(newState); } private void AppyMotionState(MotionState state) { if (!IsOwner) return; switch (state) { case MotionState.Idle: if (currentState is PlayerStateIdle) return; break; case MotionState.Moving: if (currentState is PlayerStateMove) return; break; } } public override void OnNetworkDespawn() { if (IsOwner && HealthBarUI.Instance != null) { _healthComponent.OnHealthChanged -= HealthBarUI.Instance.UpdateViewHealth; _motionState.OnValueChanged -= OnMotionStateChanged; } if (IsServer) { _healthComponent.OnHealthChanged -= CheckDeath; } } void Update() { if (IsOwner) { currentState?.Update(); } if (IsServer) { ProcessMovement(); } } public void ChangeState(IPlayerState nextState) { if (currentState != null) currentState.Exit(); currentState = nextState; currentState.Enter(); } private void BindLocalPlayerUI() { var ui = HealthBarUI.Instance; if (ui == null) { Debug.LogError("Scene creates Player but HealthBarUI is missing!"); return; } _healthComponent.OnHealthChanged += ui.UpdateViewHealth; ui.UpdateViewHealth(_healthComponent.MaxHealth, _healthComponent.MaxHealth); } #region StateRequest methods public void RequestMove(Vector3 position) { if (IsOwner) { RequestMoveServerRpc(position); } } public void RequestStop() { if (IsOwner) { RequestStopServerRpc(); } } [ServerRpc] private void RequestMoveServerRpc(Vector3 pos) { _serverTargetPosition = new Vector3(pos.x, transform.position.y, pos.z); _motionState.Value = MotionState.Moving; } [ServerRpc] private void RequestStopServerRpc() { ServerStopMove(); } #endregion #region movement methods private void ProcessMovement() { if (_motionState.Value != MotionState.Moving) return; float step = moveSpeed * Time.deltaTime; transform.position = Vector3.MoveTowards(transform.position, _serverTargetPosition, step); Vector3 direction = _serverTargetPosition - transform.position; if (direction != Vector3.zero) { Quaternion targetRot = Quaternion.LookRotation(direction); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime); } if (Vector3.Distance(transform.position, _serverTargetPosition) < 0.01f) { ServerStopMove(); } } private void ServerStopMove() { if (_motionState.Value == MotionState.Idle) return; _motionState.Value = MotionState.Idle; } #endregion #region death private void CheckDeath(int currentHealth, int maxHealth) { if (currentHealth <= 0 && !(currentState is PlayerStateDie)) { BroadcastDeathClientRpc(); } } [ClientRpc] private void BroadcastDeathClientRpc() { } #endregion private void OnCollisionEnter(Collision collision) { if (!IsServer) return; if(collision != null && collision.gameObject.CompareTag("Player")) { ServerStopMove(); } } public void CheckInteract(RaycastHit hit) { switch (hit.collider.gameObject.tag) { case "Player": Debug.Log("点击到了玩家"); break; default: Debug.Log("点击到了无法交互的物体"); break; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\DamageText.cs]
using System.Collections; using TMPro; using UnityEngine; using UnityEngine.Pool; public class DamageText : MonoBehaviour { [SerializeField] private TMP_Text damageLable; private IObjectPool<DamageText> _pool; public void SetupPool(IObjectPool<DamageText> pool) { _pool = pool; } public void Setup(int damageAmount) { damageLable.text = damageAmount.ToString(); StartCoroutine(ReturnToPoolAfterTime(3.0f)); } private IEnumerator ReturnToPoolAfterTime(float time) { yield return new WaitForSeconds(time); if(_pool != null) { _pool.Release(this); } else { Destroy(gameObject); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\DamageTextManager.cs]
using System.Net.NetworkInformation; using UnityEngine; using UnityEngine.Pool; public class DamageTextManager : MonoBehaviour { public static DamageTextManager Instance { get; private set; } [Header("����")] [SerializeField] private DamageText textPrefab; [SerializeField] private Canvas gameCanvas; private ObjectPool<DamageText> _pool; private Camera _camera; private void Awake() { Instance = this; _camera = Camera.main; _pool = new ObjectPool<DamageText>( createFunc: CreateText, actionOnGet: OnGetText, actionOnRelease: OnReleaseText, actionOnDestroy: OnDestroyText, defaultCapacity:20, maxSize:100 ); } private DamageText CreateText() { var instance = Instantiate(textPrefab, transform); instance.SetupPool(_pool); return instance; } private void OnGetText(DamageText text) { text.gameObject.SetActive(true); text.transform.localScale = Vector3.one; } private void OnReleaseText(DamageText text) { text.gameObject.SetActive(false); } private void OnDestroyText(DamageText text) { Destroy(text.gameObject); } public void ShowDamage(int amount, Vector3 worldPos) { if (textPrefab == null) return; var instance = _pool.Get(); Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPos); instance.transform.position = screenPos; instance.Setup(amount); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\HealthBarUI.cs]
using UnityEngine; using UnityEngine.UI; public class HealthBarUI : MonoBehaviour { public static HealthBarUI Instance { get; private set; } [SerializeField] private Slider healthSlider; [SerializeField] private Image QSkill; private void Awake() { Instance = this; } public void UpdateViewHealth(int current, int max) { if (healthSlider == null) return; healthSlider.value = (float)current / max; } public void UpdateViewQskill(bool activeBefore, bool activeCurrent) { if(QSkill == null) return; QSkill.color = activeCurrent ? Color.yellow : Color.red; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\InteractableTest.cs]
using Unity.Netcode; using UnityEngine; public class InteractableTest : NetworkBehaviour { private NetworkVariable<float> _health = new NetworkVariable<float>( 100f, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public override void OnNetworkSpawn() { _health.OnValueChanged += OnHealthChanged; } public override void OnNetworkDespawn() { _health.OnValueChanged -= OnHealthChanged; } private void OnHealthChanged(float prev, float cur) { if (!IsServer) return; if(cur <= 0f) { NetworkObject.Despawn(); } } [ServerRpc] public void ServerTakeDamageServerRpc(float damage) { if(!IsServer) return; _health.Value -= damage; Debug.Log("ľ׮�ܵ��˺�"); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\LaserVisual.cs]
using UnityEngine; using Unity.Netcode; [RequireComponent(typeof(LineRenderer))] public class LaserVisual : NetworkBehaviour { private LineRenderer _line; private float _growthDuration; private float _startLen; private float _maxLen; private bool _isGrowing = false; private float _timer = 0f; private void Awake() { _line = GetComponent<LineRenderer>(); _line.useWorldSpace = false; } [ClientRpc] public void InitializeLaserClientRpc(float startLen, float maxLen, float growthDuration, float width) { _startLen = startLen; _maxLen = maxLen; _growthDuration = growthDuration; _line.startWidth = width; _line.endWidth = width; _line.SetPosition(0, Vector3.zero); _line.SetPosition(1, Vector3.forward * startLen); _timer = 0f; _isGrowing = true; } private void Update() { if (!_isGrowing) return; _timer += Time.deltaTime; float progress = Mathf.Clamp01(_timer / _growthDuration); float currentLen = Mathf.Lerp(_startLen, _maxLen, progress); _line.SetPosition(1, Vector3.forward * currentLen); if (progress >= 1.0f) { _isGrowing = false; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\NukeZoneVisual.cs]
using Unity.Netcode; using UnityEngine; using System.Collections; public class NukeZoneVisual : NetworkBehaviour { private float _targetScale; private float _duration; private bool _isRunning = false; private float _timer = 0f; [ClientRpc] public void StartExpansionClientRpc(float targetRadius, float duration) { _targetScale = targetRadius * 2.0f; _duration = duration; _timer = 0f; _isRunning = true; transform.localScale = Vector3.zero; } private void Update() { if (!_isRunning) return; _timer += Time.deltaTime; float progress = _timer / _duration; if (progress >= 1.0f) { transform.localScale = Vector3.one * _targetScale; _isRunning = false; } else { transform.localScale = Vector3.Lerp(Vector3.zero, Vector3.one * _targetScale, progress); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillIndicator.cs]
using UnityEngine; using UnityEngine.UI; using System.Collections; public class SkillIndicator : MonoBehaviour { [Header("UI �������")] [SerializeField] private Image _fillImage; public void Initialize(float duration, float diameter) { transform.localScale = Vector3.one * diameter; StartCoroutine(PlayFillAnimationRoutine(duration)); } private IEnumerator PlayFillAnimationRoutine(float duration) { float timer = 0f; _fillImage.fillAmount = 0f; while (timer < duration) { timer += Time.deltaTime; _fillImage.fillAmount = timer / duration; yield return null; } _fillImage.fillAmount = 1f; yield return new WaitForSeconds(0.1f); Destroy(gameObject); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\GameHUDView.cs]
using UnityEngine; using UnityEngine.UI; using TMPro; using System.Collections.Generic; using Unity.Collections; using Unity.Netcode; public class GameHUDView : MonoBehaviour { public Slider HealthSlider; public Image QSkill; public Image WSkill; public Image ESkill; public TMP_Text points; public Sprite itemIcon; public Image item1; public Image item2; public Image item3; private PlayerNetworkHealth _pnHealth; private PlayerNetworkCombat _pnCombat; private PlayerNetworkCore _core; public static GameHUDView Instance { get; private set; } private void Awake() { Instance = this; } public void BindToLocalPlayer(PlayerNetworkHealth health, PlayerNetworkCombat combat, PlayerNetworkCore core) { _pnHealth = health; _pnCombat = combat; _core = core; BindView(); } public void BindView() { _pnHealth.CurrentHealthVar.OnValueChanged += UpdateHealthSlider; _pnCombat.QSkillActiveVar.OnValueChanged += UpdateQSkill; _pnCombat.WSkillActiveVar.OnValueChanged += UpdateWSkill; _pnCombat.ESkillActiveVar.OnValueChanged += UpdateESkill; _core.PointVar.OnValueChanged += UpdatePoints; _core.ItemsVar.OnListChanged += UpdateItems; UpdateHealthSlider(_pnHealth.MaxHealth, _pnHealth.MaxHealth); UpdateQSkill(true, _pnCombat.QSkillActiveVar.Value); UpdateWSkill(true, _pnCombat.WSkillActiveVar.Value); UpdateESkill(true, _pnCombat.ESkillActiveVar.Value); } public void UpdateHealthSlider(int preHealth, int currentHealth) { if (HealthSlider == null) return; HealthSlider.value = (float)currentHealth / (float)_pnHealth.MaxHealth; } public void UpdateQSkill(bool ignore, bool active) { QSkill.color = active ? Color.white : Color.gray; } public void UpdateWSkill(bool ignore, bool active) { WSkill.color = active ? Color.white : Color.gray; } public void UpdateESkill(bool ignore, bool active) { ESkill.color = active ? Color.white : Color.gray; } public void UpdatePoints(int pre, int current) { points.text = current.ToString(); } public void UpdateItems(NetworkListEvent<FixedString32Bytes> changeEvent) { int count = _core.ItemsVar.Count; if (count >= 1) { item1.sprite = itemIcon; item1.color = Color.white; } else { item1.sprite = null; item1.color = Color.clear; } if (count >= 2) { item2.sprite = itemIcon; item2.color = Color.white; } else { item2.sprite = null; item2.color = Color.clear; } if (count >= 3) { item3.sprite = itemIcon; item3.color = Color.white; } else { item3.sprite = null; item3.color = Color.clear; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\UIManager.cs]
using UnityEngine; using Unity.Netcode; public class UIManager : MonoBehaviour { public static UIManager Instance { get; private set; } [SerializeField] private GameHUDView hudView; private void Awake() { Instance = this; } public void OnLocalPlayerSpawned(PlayerNetworkHealth health, PlayerNetworkCombat combat) { } public void OnLocalPlayerDespawned() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Utils\SubclassSelectorAttribute.cs]
using UnityEngine; public class SubclassSelectorAttribute : PropertyAttribute { }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossController.cs]
using System; using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using UnityEngine.AI; using Random = UnityEngine.Random; [RequireComponent(typeof(NavMeshAgent)), RequireComponent(typeof(NetworkObject))] public class BossController : NetworkBehaviour, IDamageable { public enum BossMotionState { Idle = 0, Chase = 1, Charge = 2, Skill = 3, Die = 4 } [Header("AI ��������")] [SerializeField] private int _maxHealth = 100; [SerializeField] private float _chaseRange = 50f; [SerializeField] private float _basicAttackRange = 3.5f; [SerializeField] private LayerMask _chaseLayer; [Header("��������")] [SerializeField] private SkillDataSO[] _skills; [Header("AI ս������")] [SerializeField] private float _specialSkillInterval = 15f; private NavMeshAgent _agent; private NetworkObject _target; private float[] _skillCDs; private bool _isCasting = false; private float _specialSkillTimer = 0f; private bool _hasTriggered50Ult = false; private bool _hasTriggered10Ult = false; private float _repathTimer = 0f; private float _repathInterval = 0.2f; #region Network Variables private NetworkVariable<BossMotionState> _currentBossState = new NetworkVariable<BossMotionState>( BossMotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 100, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private NetworkVariable<int> _currentSkillIndex = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public BossMotionState MotionStateVar => _currentBossState.Value; public NetworkVariable<BossMotionState> Motion => _currentBossState; public NetworkVariable<int> SkillIndexVar => _currentSkillIndex; #endregion public event Action OnBossDied; public override void OnNetworkSpawn() { _agent = GetComponent<NavMeshAgent>(); if (_skills != null) _skillCDs = new float[_skills.Length]; if (IsServer) { _currentHealth.Value = _maxHealth; _currentBossState.Value = BossMotionState.Idle; _currentSkillIndex.Value = 0; _agent.enabled = true; _target = null; } else { _agent.enabled = false; } } private void Update() { if (!IsServer) return; if (_currentBossState.Value == BossMotionState.Die) return; UpdateTimers(); switch (_currentBossState.Value) { case BossMotionState.Idle: LogicIdle(); break; case BossMotionState.Chase: LogicChase(); break; case BossMotionState.Skill: LogicSkill(); break; } } private void UpdateTimers() { if (_skillCDs != null) { for (int i = 0; i < _skillCDs.Length; i++) if (_skillCDs[i] > 0) _skillCDs[i] -= Time.deltaTime; } if (_target != null) _specialSkillTimer += Time.deltaTime; } public void TakeDamage(int amount, ulong attackerId) { if (!IsServer) return; if (_currentBossState.Value == BossMotionState.Die) return; int newHealth = Mathf.Max(_currentHealth.Value - amount, 0); _currentHealth.Value = newHealth; if (newHealth <= 0) { ChangeState(BossMotionState.Die); OnBossDied?.Invoke(); return; } if (_target == null && NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(attackerId, out var attacker)) { _target = attacker; } } public void TageDamage(int amount, ulong attackerId) => TakeDamage(amount, attackerId); private bool TryStartAttack() { int skillIndex = SelectSkillToCast(); if (skillIndex != -1) { _currentSkillIndex.Value = skillIndex; ChangeState(BossMotionState.Skill); StartCoroutine(PerformSkillRoutine(skillIndex)); return true; } return false; } private void LogicCharge() { RotateTowardsTarget(); } private void LogicIdle() { DetectPlayer(); if (_target != null) { float dist = Vector3.Distance(transform.position, _target.transform.position); if (dist <= _basicAttackRange) { if (!TryStartAttack()) { } } else { ChangeState(BossMotionState.Chase); } } } private void LogicChase() { if (_target == null) { ChangeState(BossMotionState.Idle); return; } float dist = Vector3.Distance(transform.position, _target.transform.position); if (dist > _chaseRange * 1.5f) { ChangeState(BossMotionState.Idle); return; } if (dist <= _basicAttackRange) { if (TryStartAttack()) return; } _repathTimer += Time.deltaTime; if (_repathTimer > _repathInterval) { _repathTimer = 0f; if (_agent.isOnNavMesh) _agent.SetDestination(_target.transform.position); } } private void LogicSkill() { if (!_isCasting) { ChangeState(BossMotionState.Idle); return; } RotateTowardsTarget(); } private int SelectSkillToCast() { float hpPercent = (float)_currentHealth.Value / _maxHealth; int ultIndex = 3; if (_skills.Length > ultIndex) { if (hpPercent <= 0.1f && !_hasTriggered10Ult) { _hasTriggered10Ult = true; _skillCDs[ultIndex] = 0; return ultIndex; } if (hpPercent <= 0.5f && !_hasTriggered50Ult) { _hasTriggered50Ult = true; _skillCDs[ultIndex] = 0; return ultIndex; } } if (_specialSkillTimer >= _specialSkillInterval) { List<int> readySpecials = new List<int>(); if (_skills.Length > 1 && _skillCDs[1] <= 0) readySpecials.Add(1); if (_skills.Length > 2 && _skillCDs[2] <= 0) readySpecials.Add(2); if (readySpecials.Count > 0) { _specialSkillTimer = 0f; return readySpecials[Random.Range(0, readySpecials.Count)]; } } if (_skills.Length > 0 && _skillCDs[0] <= 0) { return 0; } return -1; } private IEnumerator PerformSkillRoutine(int index) { _isCasting = true; var skillData = _skills[index]; _skillCDs[index] = skillData.coolDown; Vector3 finalCastPos = transform.position; bool isSelfCentered = index == 3 || skillData.isSelfCentered; if (!isSelfCentered && _target != null) finalCastPos = _target.transform.position; ChangeState(BossMotionState.Charge); if (skillData.chargeDuration > 0) { if (skillData.warningPrefab != null) { float diameter = (index == 3) ? 10.0f : 4.0f; ShowWarningClientRpc(index, finalCastPos, skillData.chargeDuration, diameter); } Debug.Log($"[Server] ��������: {skillData.chargeDuration}��"); yield return new WaitForSeconds(skillData.chargeDuration); } ChangeState(BossMotionState.Skill); Debug.Log($"[Server] �ͷż��ܣ�����˺�"); skillData.Cast(gameObject, _target != null ? _target.gameObject : null, finalCastPos); float recoveryTime = (index == 0) ? 1.0f : 2.0f; yield return new WaitForSeconds(recoveryTime); _isCasting = false; ChangeState(BossMotionState.Idle); } [ClientRpc] private void ShowWarningClientRpc(int skillIndex, Vector3 pos, float duration, float diameter) { if (skillIndex < 0 || skillIndex >= _skills.Length) return; GameObject prefab = _skills[skillIndex].warningPrefab; if (prefab == null) return; GameObject instance = Instantiate(prefab, pos + Vector3.up * 0.1f, Quaternion.Euler(90, 0, 0)); if (instance.TryGetComponent<SkillIndicator>(out var indicator)) indicator.Initialize(duration, diameter); } private void RotateTowardsTarget() { if (_target == null) return; Vector3 dir = (_target.transform.position - transform.position).normalized; dir.y = 0; if (dir != Vector3.zero) transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(dir), 10f * Time.deltaTime); } private void ChangeState(BossMotionState newState) { if (_currentBossState.Value == newState) return; _currentBossState.Value = newState; if (newState == BossMotionState.Idle || newState == BossMotionState.Skill) { if (_agent.isOnNavMesh) _agent.ResetPath(); } else if (newState == BossMotionState.Chase) { if (_agent.isOnNavMesh) _agent.isStopped = false; } } private void DetectPlayer() { if (_target != null) return; var hits = Physics.OverlapSphere(transform.position, _chaseRange, _chaseLayer); foreach (var hit in hits) { if (hit.TryGetComponent<PlayerNetworkCore>(out var playerCore) && !playerCore.IsDead) { _target = hit.GetComponent<NetworkObject>(); return; } } } public string GetCurrentSkillAnimationName() { int idx = _currentSkillIndex.Value; if (_skills != null && idx >= 0 && idx < _skills.Length) { return _skills[idx].animationName; } return "Idle"; } public string GetCurrentChargeAnimationName() { int idx = _currentSkillIndex.Value; if (_skills != null && idx >= 0 && idx < _skills.Length) { if (string.IsNullOrEmpty(_skills[idx].chargeAnimationName)) return "Idle"; return _skills[idx].chargeAnimationName; } return "Idle"; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossPresentation.cs]
using UnityEngine; [RequireComponent(typeof(Animator))] public class BossPresentation : MonoBehaviour { private BossController _controller; private IEnemyState _currentState; private Animator _animator; private string _skillAnimationName; private string _skillChargeAnimationName; public Animator Animator => _animator; public string SkillAnimationName => _skillAnimationName; public string SkillChargeAnimationName => _skillChargeAnimationName; public BossController Controller => _controller; void Start() { _controller = GetComponent<BossController>(); _controller.Motion.OnValueChanged += OnMotionStateChanged; _controller.SkillIndexVar.OnValueChanged += OnSkillIndexChanged; _animator = GetComponent<Animator>(); } void Update() { _currentState?.Update(); } private void OnDestroy() { if (_controller != null) { _controller.Motion.OnValueChanged -= OnMotionStateChanged; } } private void OnMotionStateChanged(BossController.BossMotionState oldState, BossController.BossMotionState newState) { RefreshState(); } private void OnSkillIndexChanged(int oldIdx, int newIdx) { if (_controller.MotionStateVar == BossController.BossMotionState.Skill || _controller.MotionStateVar == BossController.BossMotionState.Charge) { RefreshState(); } } private void RefreshState() { if (_controller == null) return; switch (_controller.MotionStateVar) { case BossController.BossMotionState.Idle: if (_currentState is BossStateIdle) return; ChangeState(new BossStateIdle(this)); break; case BossController.BossMotionState.Chase: if (_currentState is BossStateMove) return; ChangeState(new BossStateMove(this)); break; case BossController.BossMotionState.Charge: _skillChargeAnimationName = _controller.GetCurrentChargeAnimationName(); ChangeState(new BossStateCharge(this)); break; case BossController.BossMotionState.Skill: _skillAnimationName = _controller.GetCurrentSkillAnimationName(); ChangeState(new BossStateSkill(this)); break; case BossController.BossMotionState.Die: break; } } public void ChangeState(IEnemyState newState) { _currentState?.Exit(); _currentState = newState; _currentState.Enter(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyController.cs]
using System; using System.Collections; using System.Linq; using Unity.Netcode; using UnityEngine; using UnityEngine.AI; using static UnityEngine.GraphicsBuffer; [RequireComponent(typeof(NavMeshAgent)), RequireComponent(typeof(NetworkObject))] public class EnemyController : NetworkBehaviour { public enum NPCMotionState { Idle = 0, Chase = 1, Attack = 2, Die = 3 } [SerializeField] private float _chaseRange = 10f; [SerializeField] private float _attackRange = 5f; [SerializeField] private LayerMask _chaseLayer; private float _repathTimer = 0f; private float _repathInterval = 0.2f; private float _attackTimer = 0f; private float _attackInterval = 0.833f; private bool _isAttacking = false; public LayerMask ChaseLayer => _chaseLayer; private NavMeshAgent _agent; private NetworkObject _target; #region public property public NavMeshAgent Agent => _agent; public float AttackRange => _attackRange; public float ChaseRange => _chaseRange; #endregion #region network variable private NetworkVariable<NPCMotionState> _currentEnmeyState = new NetworkVariable<NPCMotionState>( NPCMotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<NPCMotionState> Motion => _currentEnmeyState; public NPCMotionState MotionStateVar => _currentEnmeyState.Value; #endregion public override void OnNetworkSpawn() { _agent = GetComponent<NavMeshAgent>(); if (IsServer) { _target = null; _agent.enabled = true; _currentEnmeyState.Value = NPCMotionState.Idle; } else { _agent.enabled = false; } } private void Update() { if (!IsServer) return; switch (_currentEnmeyState.Value) { case NPCMotionState.Idle: LogicIdle(); break; case NPCMotionState.Chase: LogicChase(); break; case NPCMotionState.Attack: LogicAttack(); break; } } private void LogicIdle() { DetectPlayer(); if (_target != null) { float distance = Vector3.Distance(transform.position, _target.transform.position); if (distance <= _attackRange) { ChangeStateToAttack(); } else { ChangeStateToChase(); } } } private void LogicChase() { if (_target == null) { ChangeStateToIdle(); return; } float distance = Vector3.Distance(transform.position, _target.transform.position); if (distance > _chaseRange * 1.2f) { ChangeStateToIdle(); return; } if (distance <= _attackRange) { ChangeStateToAttack(); return; } ChasePlayerMovement(); } private void LogicAttack() { if (_target == null) { ChangeStateToIdle(); return; } float distance = Vector3.Distance(transform.position, _target.transform.position); if (distance > _attackRange * 1.1f) { ChangeStateToChase(); return; } AttackPlayerBehavior(); } private void ChangeStateToIdle() { _currentEnmeyState.Value = NPCMotionState.Idle; _target = null; if (_agent.isOnNavMesh) _agent.ResetPath(); } private void ChangeStateToChase() { _currentEnmeyState.Value = NPCMotionState.Chase; if (_agent.isOnNavMesh) _agent.isStopped = false; } private void ChangeStateToAttack() { _currentEnmeyState.Value = NPCMotionState.Attack; if (_agent.isOnNavMesh) _agent.ResetPath(); _attackTimer = _attackInterval; } private void ChasePlayerMovement() { _repathTimer += Time.deltaTime; if (_repathTimer > _repathInterval) { _repathTimer = 0f; if (_agent.isOnNavMesh) { _agent.SetDestination(_target.transform.position); } } } private void AttackPlayerBehavior() { _attackTimer += Time.deltaTime; if (_attackTimer > _attackInterval) { _attackTimer = 0f; Debug.Log($"�� {_target.name} ���𹥻���"); if(_target.TryGetComponent<PlayerNetworkCore>(out PlayerNetworkCore targetAuth)) { targetAuth.ApplyDamageServer(10, NetworkObjectId); } } } private void DetectPlayer() { if (_target != null) return; var colliderInfos = Physics.OverlapSphere(transform.position, _chaseRange, _chaseLayer); if (colliderInfos.Length <= 0) return; Debug.Log($"��⵽{colliderInfos.Length}������"); NetworkObject bestTarget = null; float minDistance = float.MaxValue; foreach (Collider collider in colliderInfos) { if (collider.gameObject == gameObject) continue; if (!collider.TryGetComponent<NetworkObject>(out NetworkObject netObj)) continue; Debug.Log($"netobject.id -> [{netObj.NetworkObjectId}]"); float d = Vector3.Distance(collider.transform.position, transform.position); if (d < minDistance) { minDistance = d; bestTarget = netObj; } } if (bestTarget != null) { Debug.Log($"����Ŀ��: {bestTarget.name}"); _target = bestTarget; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyPresentation.cs]
using UnityEditor.VersionControl; using UnityEngine; [RequireComponent(typeof(Animator))] public class EnemyPresentation : MonoBehaviour { private EnemyController _controller; private IEnemyState _currentState; private Animator _animator; public Animator Animator => _animator; void Start() { _controller = GetComponent<EnemyController>(); _controller.Motion.OnValueChanged += OnMtionStateChanged; _animator = GetComponent<Animator>(); } void Update() { } private void OnMtionStateChanged(EnemyController.NPCMotionState oldState, EnemyController.NPCMotionState newState) { RefreshState(); } private void RefreshState() { if(_controller == null) return; switch (_controller.MotionStateVar) { case EnemyController.NPCMotionState.Idle: if (_currentState is EnemyStateIdle) return; ChangeState(new EnemyStateIdle(this)); break; case EnemyController.NPCMotionState.Chase: if(_currentState is EnemyStateMove) return; ChangeState(new EnemyStateMove(this)); break; case EnemyController.NPCMotionState.Attack: if(_currentState is EnemyStateAttack) return; ChangeState(new EnemyStateAttack(this)); break; default: break; } } public void ChangeState(IEnemyState newState) { _currentState?.Exit(); _currentState = newState; _currentState.Enter(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerInputManager.cs]
using Unity.Netcode; using UnityEngine; [RequireComponent(typeof(PlayerNetworkCore))] public class PlayerInputManager : NetworkBehaviour { [Header("Raycast Layers")] [SerializeField] private LayerMask groundLayer; [SerializeField] private LayerMask interactLayer; [Header("Raycast")] [SerializeField] private float rayMaxDistance = 1000f; private Camera _mainCamera; private PlayerNetworkCore _core; private PlayerNetworkMovement _movement; private PlayerNetworkCombat _combat; private void Awake() { _core = GetComponent<PlayerNetworkCore>(); _movement = GetComponent<PlayerNetworkMovement>(); _combat = GetComponent<PlayerNetworkCombat>(); } public override void OnNetworkSpawn() { if (!IsOwner) { enabled = false; return; } _mainCamera = Camera.main; if( _core != null ) { _core.LifeVar.OnValueChanged += OnLifeChanged; } } public override void OnNetworkDespawn() { if (IsOwner && _core != null) _core.LifeVar.OnValueChanged -= OnLifeChanged; } private void OnLifeChanged(PlayerNetworkStates.LifeState oldState, PlayerNetworkStates.LifeState newState) { if (newState == PlayerNetworkStates.LifeState.Dead) enabled = false; } private void Update() { if (!IsOwner) return; if (_movement == null) return; if (Input.GetKeyDown(KeyCode.S)) { _movement.RequestStop(); return; } if (Input.GetKeyDown(KeyCode.A)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position + transform.forward; _combat.RequestCastSkill(0, aimPos); return; } if (Input.GetKeyDown(KeyCode.Q)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(1, aimPos); return; } if (Input.GetKeyDown(KeyCode.W)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(2, aimPos); return; } if (Input.GetKeyDown(KeyCode.E)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(3, aimPos); return; } if (Input.GetMouseButtonDown(1)) { if (_mainCamera == null) _mainCamera = Camera.main; if (_mainCamera == null) return; Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out RaycastHit interactHit, rayMaxDistance, interactLayer)) { if(interactHit.collider.TryGetComponent<IInteractable>(out var interact)) { Debug.Log("����������㣬��ȡ�����ӿ�"); interact.Interact(gameObject); } return; } if(Physics.Raycast(ray, out RaycastHit groundHit, rayMaxDistance, groundLayer)) { _movement.RequestMove(groundHit.point); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkCombat.cs]
using System; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkCombat : NetworkBehaviour { [Header("技能配置")] [Tooltip("Element 0 = 普攻, Element 1 = Q, Element 2 = W, Element 3 = E")] [SerializeField] private List<SkillDataSO> _skillSlots; private PlayerNetworkCore _core; private PlayerNetworkMovement _movement; #region net var private readonly NetworkVariable<int> _currentSkillIndex = new NetworkVariable<int>( -1, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private readonly NetworkVariable<bool> _qSkillActive = new NetworkVariable<bool>( true, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private readonly NetworkVariable<bool> _wSkillActive = new NetworkVariable<bool>( true, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private readonly NetworkVariable<bool> _eSkillActive = new NetworkVariable<bool>( true, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<bool> QSkillActiveVar => _qSkillActive; public NetworkVariable<bool> WSkillActiveVar => _wSkillActive; public NetworkVariable<bool> ESkillActiveVar => _eSkillActive; #endregion private float[] _cooldownTimers; public string GetSkillAnimationName() => _skillSlots[_currentSkillIndex.Value].animationName; public int CurrentSkillIndex => _currentSkillIndex.Value; public int SkillCount => _skillSlots.Count; public event Action<int> OnSkillIndexChanged; private bool _isChasing; private void Awake() { _core = GetComponent<PlayerNetworkCore>(); _movement = GetComponent<PlayerNetworkMovement>(); _cooldownTimers = new float[_skillSlots.Count]; for(int i = 0; i < _skillSlots.Count; i++) { _cooldownTimers[i] = _skillSlots[i].coolDown; } } public override void OnNetworkSpawn() { _currentSkillIndex.OnValueChanged += HandleSkillIndexChanged; if (!IsServer) return; } public override void OnNetworkDespawn() { _currentSkillIndex.OnValueChanged -= HandleSkillIndexChanged; } private void HandleSkillIndexChanged(int prev, int curr) { OnSkillIndexChanged?.Invoke(curr); } private void Update() { if (!IsServer) return; if (_core.IsDead) return; ProcessCooldowns(); if (_isChasing) PerformChaseLogic(); } private void ProcessCooldowns() { for (int i = 0; i < _cooldownTimers.Length; i++) { if (_cooldownTimers[i] > 0) { _cooldownTimers[i] -= Time.deltaTime; } else { if (i == 1 && !_qSkillActive.Value) _qSkillActive.Value = true; if (i == 2 && !_wSkillActive.Value) _wSkillActive.Value = true; if (i == 3 && !_eSkillActive.Value) _eSkillActive.Value = true; } } } public SkillDataSO GetCurrentSkillData() { int index = _currentSkillIndex.Value; if (index < 0 || index >= _skillSlots.Count) return null; return _skillSlots[index]; } public void RequestCastSkill(int slotIndex, Vector3 aimPosition) { if (!IsOwner) return; RequestCastSkillServerRpc(slotIndex, aimPosition); } [ServerRpc] private void RequestCastSkillServerRpc(int index, Vector3 aimPosition) { if (_core.IsDead) return; if (index < 0 || index >= _skillSlots.Count) return; if (_cooldownTimers[index] > 0) return; ExecuteSkill(index, aimPosition); } private void ExecuteSkill(int index, Vector3 aimPosition) { switch (index) { case 1: _qSkillActive.Value = false; break; case 2: _wSkillActive.Value = false; break; case 3: _eSkillActive.Value = false; break; default: break; } SkillDataSO skillData = _skillSlots[index]; _movement.ServerForceStop(); _isChasing = false; _currentSkillIndex.Value = index; _core.SetMotionServer(PlayerNetworkStates.MotionState.Skill); _cooldownTimers[index] = skillData.coolDown; skillData.Cast(gameObject, null, aimPosition); CancelInvoke(nameof(ResetToIdle)); float recoveryTime = 0.8f; Invoke(nameof(ResetToIdle), recoveryTime); } private void ResetToIdle() { if (_core.IsDead) return; _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); _currentSkillIndex.Value = -1; } private void PerformChaseLogic() { } public float GetCooldownRemaining(int v) { return _cooldownTimers[v]; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkCore.cs]
using NUnit.Framework; using System; using System.Collections.Generic; using Unity.Collections; using TMPro.EditorUtilities; using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkCore : NetworkBehaviour { [Header("Server LifeCycle")] [SerializeField] private float deathDespawnDelay = 3f; private readonly NetworkVariable<PlayerNetworkStates.LifeState> _lifeState = new NetworkVariable<PlayerNetworkStates.LifeState>( PlayerNetworkStates.LifeState.Alive, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server); public PlayerNetworkStates.LifeState Life => _lifeState.Value; public NetworkVariable<PlayerNetworkStates.LifeState> LifeVar => _lifeState; private readonly NetworkVariable<PlayerNetworkStates.MotionState> _motionState = new NetworkVariable<PlayerNetworkStates.MotionState>( PlayerNetworkStates.MotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server); public PlayerNetworkStates.MotionState Motion => _motionState.Value; public NetworkVariable<PlayerNetworkStates.MotionState> MotionVar => _motionState; public bool IsDead => _lifeState.Value == PlayerNetworkStates.LifeState.Dead; private readonly NetworkVariable<int> _points = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<int> PointVar => _points; private NetworkList<FixedString32Bytes> _items = new NetworkList<FixedString32Bytes>( new List<FixedString32Bytes>(), NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkList<FixedString32Bytes> ItemsVar => _items; #region public events public event Action<PlayerNetworkCore> OnPlayerDied; #endregion private PlayerNetworkHealth _health; private PlayerNetworkMovement _movement; private PlayerNetworkCombat _combat; private bool _deathTimerRunning; private float _deathTimer; private void Awake() { _health = GetComponent<PlayerNetworkHealth>(); _movement = GetComponent<PlayerNetworkMovement>(); _combat = GetComponent<PlayerNetworkCombat>(); } public override void OnNetworkSpawn() { if (!IsServer) return; _lifeState.Value = PlayerNetworkStates.LifeState.Alive; _deathTimerRunning = false; _deathTimer = 0f; if (_health != null) { _health.OnDiedServer += OnDiedServer; } if (GameLifecycleManager.Instance != null) { GameLifecycleManager.Instance.RegisterPlayer(this); } else { var manager = FindFirstObjectByType<GameLifecycleManager>(); if (manager != null) manager.RegisterPlayer(this); } _movement?.ServerReset(); } public override void OnNetworkDespawn() { if (!IsServer) return; if (_health != null) { _health.OnDiedServer -= OnDiedServer; } if (GameLifecycleManager.Instance != null) { GameLifecycleManager.Instance.UnregisterPlayer(this); } var gameManager = GameLifecycleManager.Instance; gameManager.UnregisterPlayer(this); } private void Update() { if (!IsServer) return; if (!IsDead) return; ProcessDeathDespawn(); } private void OnDiedServer() { if (!IsServer) return; if (IsDead) return; _lifeState.Value = PlayerNetworkStates.LifeState.Dead; OnPlayerDied?.Invoke(this); _movement?.ServerForceStop(); _deathTimerRunning = true; _deathTimer = 0f; } private void ProcessDeathDespawn() { if (!_deathTimerRunning) return; _deathTimer += Time.deltaTime; if (_deathTimer < deathDespawnDelay) return; var nob = GetComponent<NetworkObject>(); if (nob != null && nob.IsSpawned) { nob.Despawn(); } _deathTimerRunning = false; } public void ApplyDamageServer(int amount, ulong attackerId) { if (!IsServer) return; if (IsDead) return; if (_health == null) return; _health.ServerTakeDamage(amount, attackerId); } public void SetMotionServer(PlayerNetworkStates.MotionState newState) { if (!IsServer) return; if(_motionState.Value == newState) return; _motionState.Value = newState; } public void AddPointsServer(int amount) { if (!IsServer) return; _points.Value += amount; } public void AddItem(string name) { _items.Add(name); string allItems = ""; foreach(var item in _items) { allItems += item; } Debug.Log(allItems); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkHealth.cs]
using System; using Unity.Netcode; using UnityEngine; public class PlayerNetworkHealth : NetworkBehaviour, IDamageable { [Header("����")] [SerializeField] private int _maxHealth = 100; private readonly NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public int CurrentHealth => _currentHealth.Value; public NetworkVariable<int> CurrentHealthVar => _currentHealth; public int MaxHealth => _maxHealth; public bool IsDead => _currentHealth.Value < 0; public event Action<int, int> OnHealthChanged; public event Action<int, ulong> OnDamaged; public event Action<ulong> OnDied; public event Action OnDiedServer; public override void OnNetworkSpawn() { _currentHealth.OnValueChanged += HandleHealthChanged; if (IsServer) { _currentHealth.Value = _maxHealth; } _currentHealth.Value = _maxHealth; OnHealthChanged?.Invoke(_currentHealth.Value, _maxHealth); } public override void OnNetworkDespawn() { _currentHealth.OnValueChanged -= HandleHealthChanged; OnHealthChanged = null; OnDamaged = null; OnDied = null; OnDiedServer = null; } private void HandleHealthChanged(int prev, int curr) { OnHealthChanged?.Invoke(curr, _maxHealth); } public void RequestTakeDamage(int damage, ulong attackerCliendId = 0) { ServerTakeDamage(damage, attackerCliendId); } public void ServerTakeDamage(int damage, ulong attackerCliendId = 0) { if (!IsServer) return; if (damage < 0) return; if (IsDead) return; int prev = _currentHealth.Value; int next = Mathf.Clamp(prev - damage, 0, MaxHealth); if (next == prev) return; _currentHealth.Value = next; DamagedClientRpc(damage, attackerCliendId); ShowDamagePopupClientRpc(damage, transform.position); if(next <= 0) { DiedClientRpc(attackerCliendId); OnDiedServer?.Invoke(); } } public void ServerHeal(int amount) { if (!IsServer) return; if(amount <= 0) return; if (IsDead) return; int prev = _currentHealth.Value; int next = Mathf.Clamp(prev + amount, 0, MaxHealth); if(next == prev) return; _currentHealth.Value = next; } [ClientRpc] private void DamagedClientRpc(int damage, ulong attackerCliendId) { OnDamaged?.Invoke(damage, attackerCliendId); } [ClientRpc] private void DiedClientRpc(ulong attackerCliendId) { OnDied?.Invoke(attackerCliendId); } [ClientRpc] private void ShowDamagePopupClientRpc(int amount, Vector3 targetPos) { if(DamageTextManager.Instance != null) { Vector3 randomOffset = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 1.5f, 0); DamageTextManager.Instance.ShowDamage(amount, targetPos + randomOffset); } } public void TakeDamage(int amount, ulong attackerId) { RequestTakeDamage(amount, attackerId); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkMovement.cs]
using System; using System.Collections; using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkMovement : NetworkBehaviour, IKnockBackable { [Header("Server Movement")] [SerializeField] private float moveSpeed = 5f; [SerializeField] private float rotateSpeed = 10f; [Header("Physics Settings")] [SerializeField] private float gravity = -9.81f; [SerializeField] private float drag = 2.0f; private bool _isKnockedBack = false; private Vector3 _velocity; private Vector3 _serverTargetPosition; private PlayerNetworkCore _core; public event Action ServerReachedDestination; private void Awake() { _core = GetComponent<PlayerNetworkCore>(); } public override void OnNetworkSpawn() { if (!IsServer) return; _serverTargetPosition = transform.position; _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); } private void Update() { if (!IsServer) return; if (_core != null && _core.IsDead) return; ProcessMovementServer(); } private IEnumerator RecoverFromKnockback(float duration) { yield return new WaitForSeconds(duration); _isKnockedBack = false; } public void RequestMove(Vector3 worldPos) { if (!IsOwner) return; RequestMoveServerRpc(worldPos); } public void RequestStop() { if (!IsOwner) return; RequestStopServerRpc(); } public void ServerMoveTo(Vector3 worldPos) { if (!IsServer) return; if (_core != null && _core.IsDead) return; _serverTargetPosition = new Vector3(worldPos.x, transform.position.y, worldPos.z); _core.SetMotionServer(PlayerNetworkStates.MotionState.Moving); } public void ServerForceStop() { if (!IsServer) return; _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); _serverTargetPosition = transform.position; } public void ServerForceDash(Vector3 direction, float distance, float duration) { if (!IsServer) return; Vector3 targetPos = transform.position + direction.normalized * distance; _serverTargetPosition = targetPos; transform.position = targetPos; } public void ServerReset() { if (!IsServer) return; _serverTargetPosition = transform.position; _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); } [ServerRpc] private void RequestMoveServerRpc(Vector3 pos, ServerRpcParams rpcParams = default) { if (_core != null && _core.IsDead) return; if (rpcParams.Receive.SenderClientId != OwnerClientId) return; if (_isKnockedBack) return; _serverTargetPosition = new Vector3(pos.x, transform.position.y, pos.z); _core.SetMotionServer(PlayerNetworkStates.MotionState.Moving); } [ServerRpc] private void RequestStopServerRpc(ServerRpcParams rpcParams = default) { if (_core != null && _core.IsDead) return; if (rpcParams.Receive.SenderClientId != OwnerClientId) return; ServerForceStop(); } private void ProcessMovementServer() { if (_isKnockedBack) { float dt = Time.deltaTime; _velocity.y += gravity * 2.0f * dt; Vector3 horizontalVel = new Vector3(_velocity.x, 0, _velocity.z); horizontalVel = Vector3.Lerp(horizontalVel, Vector3.zero, drag * dt); _velocity = new Vector3(horizontalVel.x, _velocity.y, horizontalVel.z); transform.position += _velocity * dt; if (Physics.Raycast(transform.position + Vector3.up * 0.5f, Vector3.down, out RaycastHit hit, 0.6f)) { if (_velocity.y < 0) { Debug.Log("落地！结束击飞状态"); _isKnockedBack = false; _velocity = Vector3.zero; transform.position = new Vector3(transform.position.x, hit.point.y, transform.position.z); _serverTargetPosition = transform.position; } } return; } if (_core.Motion != PlayerNetworkStates.MotionState.Moving) return; float step = moveSpeed * Time.deltaTime; transform.position = Vector3.MoveTowards(transform.position, _serverTargetPosition, step); Vector3 direction = _serverTargetPosition - transform.position; if (direction.sqrMagnitude > 0.0001f) { Quaternion targetRot = Quaternion.LookRotation(direction); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime); } if (Vector3.Distance(transform.position, _serverTargetPosition) < 0.01f) { _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); ServerReachedDestination?.Invoke(); } } private void OnCollisionEnter(Collision collision) { if (!IsServer) return; if (_core != null && _core.IsDead) return; if (collision == null) return; if (collision.gameObject.CompareTag("Player")) { ServerForceStop(); } } private void OnTriggerEnter(Collider other) { if (!IsServer) return; if (_core != null && _core.IsDead) return; if (other == null) return; if (other.gameObject.TryGetComponent<IInteractable>(out var interact)) { interact.Interact(gameObject); } } public void ApplyKnockbackServer(Vector3 forceDir, float forceStrength) { if (!IsServer) return; _isKnockedBack = true; _velocity = forceDir.normalized * forceStrength; _serverTargetPosition = transform.position; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkStates.cs]
using UnityEngine; public class PlayerNetworkStates { public enum MotionState : byte { Idle = 0, Moving = 1, Skill = 2, } public enum LifeState : byte { Alive = 0, Dead = 1 } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerPresentation.cs]
using Unity.Netcode; using UnityEngine; [RequireComponent(typeof(PlayerNetworkCore))] public class PlayerPresentation : NetworkBehaviour { private PlayerNetworkCore _core; private PlayerNetworkCombat _combat; private PlayerNetworkHealth _health; private IPlayerState _currentState; private string _skillAnimationName; public string SkillAnimationName => _skillAnimationName; public Rigidbody Rigidbody { get; private set; } public CapsuleCollider CapsuleCollider { get; private set; } public Animator Animator { get; private set; } private void Awake() { _core = GetComponent<PlayerNetworkCore>(); _combat = GetComponent<PlayerNetworkCombat>(); _health = GetComponent<PlayerNetworkHealth>(); Rigidbody = GetComponent<Rigidbody>(); CapsuleCollider = GetComponent<CapsuleCollider>(); Animator = GetComponent<Animator>(); } public override void OnNetworkSpawn() { if( _core != null) { _core.LifeVar.OnValueChanged += OnLifeChanged; _core.MotionVar.OnValueChanged += OnMotionChanged; } if (_combat != null) { _combat.OnSkillIndexChanged += OnSkillIndexChanged; } RefreshStateFromNet(); if(_health != null) { _health.OnDamaged += OnDamagedLocal; } if (IsOwner) { if (GameHUDView.Instance != null) { GameHUDView.Instance.BindToLocalPlayer(_health, _combat, _core); } if (GameCameraManager.Instance != null) { GameCameraManager.Instance.SetFollowTarget(transform); } else { } } } public override void OnNetworkDespawn() { if( _core != null) { _core.LifeVar.OnValueChanged-= OnLifeChanged; _core.MotionVar.OnValueChanged -= OnMotionChanged; } if (_combat != null) { _combat.OnSkillIndexChanged -= OnSkillIndexChanged; } if (IsOwner && _health != null && HealthBarUI.Instance != null) { _health.OnHealthChanged -= HealthBarUI.Instance.UpdateViewHealth; _health.OnDamaged -= OnDamagedLocal; } } private void OnSkillIndexChanged(int newIndex) { if (_core.Motion == PlayerNetworkStates.MotionState.Skill && newIndex != -1) { RefreshStateFromNet(); } } private void OnDamagedLocal(int damage, ulong attackerId) { if (IsOwner) { } } private void Update() { _currentState?.Update(); } private void OnMotionChanged(PlayerNetworkStates.MotionState oldState, PlayerNetworkStates.MotionState newState) { RefreshStateFromNet(); } private void OnLifeChanged(PlayerNetworkStates.LifeState oldState, PlayerNetworkStates.LifeState newState) { RefreshStateFromNet(); } private void RefreshStateFromNet() { if (_core == null) return; if(_core.Life == PlayerNetworkStates.LifeState.Dead) { if (_currentState is PlayerStateDie) return; ChangeState(new PlayerStateDie(this)); return; } switch (_core.Motion) { case PlayerNetworkStates.MotionState.Moving: if (_currentState is PlayerStateMove) return; ChangeState(new PlayerStateMove(this)); break; case PlayerNetworkStates.MotionState.Idle: if(_currentState is PlayerStateIdle) return; ChangeState(new PlayerStateIdle(this)); break; case PlayerNetworkStates.MotionState.Skill: _skillAnimationName = _combat.GetSkillAnimationName(); ChangeState(new PlayerStateSkill(this)); break; default: ChangeState(new PlayerStateIdle(this)); break; } } public void ChangeState(IPlayerState nextState) { _currentState?.Exit(); _currentState = nextState; _currentState.Enter(); } private void BindLocalPlayerUI() { var ui = HealthBarUI.Instance; if(ui == null) { Debug.LogError("����������ҵ���û�� Ѫ����"); return; } if(_health == null) { Debug.LogError("���û��Ѫ�����"); return; } _health.OnHealthChanged += ui.UpdateViewHealth; ui.UpdateViewHealth(_health.MaxHealth, _health.MaxHealth); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\IPlayerState.cs]
using UnityEngine; public interface IPlayerState { void Enter(); void Update(); void Exit(); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateDie.cs]
using Unity.Netcode; using Unity.VisualScripting; using UnityEngine; public class PlayerStateDie : IPlayerState { private float DieTime = 3f; private float timer = 0; private PlayerPresentation _view; public PlayerStateDie(PlayerPresentation view) => _view = view; public void Enter() { if(_view.CapsuleCollider != null) { _view.CapsuleCollider.enabled = false; } if(_view.Rigidbody != null) { _view.Rigidbody.isKinematic = true; } Debug.Log("���� Die��Presentation������ײ��ʧЧ�����嶳�ᣨDespawn �� Server Authority ����"); _view.Animator.Play("Die01_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateIdle.cs]
using UnityEngine; public class PlayerStateIdle : IPlayerState { private RaycastHit groundHit; private PlayerPresentation _view; public PlayerStateIdle(PlayerPresentation view) => _view = view; public void Enter() { _view.Animator.Play("Idle_Battle_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateMove.cs]
using System; using System.Globalization; using Unity.Netcode; using UnityEngine; public class PlayerStateMove : IPlayerState { private PlayerPresentation _view; public PlayerStateMove(PlayerPresentation view) => _view = view; public void Enter() { _view.Animator.Play("MoveFWD_Normal_InPlace_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateSkill.cs]
using UnityEngine; public class PlayerStateSkill : IPlayerState { private PlayerPresentation _view; public PlayerStateSkill(PlayerPresentation view) { _view = view; } public void Enter() { _view.Animator.Play(_view.SkillAnimationName); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\AreaEffect.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class AreaEffect : SkillEffect { [Header("AOE ����")] public float radius = 3f; public float delay = 1.0f; public int damage = 10; public GameObject vfxPrefab; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (vfxPrefab != null) { var vfx = GameObject.Instantiate(vfxPrefab, position, Quaternion.identity); vfx.GetComponent<NetworkObject>().Spawn(); GameObject.Destroy(vfx, delay + 0.5f); } caster.GetComponent<NetworkBehaviour>().StartCoroutine(ExplodeRoutine(caster, position)); } private IEnumerator ExplodeRoutine(GameObject caster, Vector3 centerPos) { yield return new WaitForSeconds(delay); Collider[] hits = Physics.OverlapSphere(centerPos, radius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage(damage, caster.GetComponent<NetworkObject>().NetworkObjectId); Debug.Log($"[Effect] AOE ը���� {hit.name}"); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\BossJumpEffect.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class BossJumpEffect : SkillEffect { [Header("��Ծ����")] public float height = 5.0f; public float duration = 1.0f; public bool isLanding = false; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (!caster.TryGetComponent<UnityEngine.AI.NavMeshAgent>(out var agent)) return; caster.GetComponent<NetworkBehaviour>().StartCoroutine( JumpRoutine(caster.transform, agent, isLanding) ); } private IEnumerator JumpRoutine(Transform bossInfo, UnityEngine.AI.NavMeshAgent agent, bool landing) { float timer = 0f; Vector3 startPos = bossInfo.position; Vector3 endPos = landing ? new Vector3(startPos.x, 0, startPos.z) : startPos + Vector3.up * height; if (!landing) { agent.enabled = false; } while (timer < duration) { timer += Time.deltaTime; float t = timer / duration; bossInfo.position = Vector3.Lerp(startPos, endPos, t); yield return null; } bossInfo.position = endPos; if (landing) { agent.enabled = true; if (UnityEngine.AI.NavMesh.SamplePosition(bossInfo.position, out var hit, 2.0f, UnityEngine.AI.NavMesh.AllAreas)) { agent.Warp(hit.position); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\CameraShakeEffect.cs]
using System; using UnityEngine; [Serializable] public class CameraShakeEffect : SkillEffect { [Header("��Ļ������")] [Tooltip("������ (0.1 - 5.0)")] public float shakeForce = 1.0f; [Tooltip("ֻ���ͷ����Լ��ܸ��ܵ�����")] public bool onlyLocalPlayer = true; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (GameCameraManager.Instance == null) return; bool shouldShake = false; if (onlyLocalPlayer) { if (caster.TryGetComponent<Unity.Netcode.NetworkObject>(out var netObj)) { if (netObj.IsOwner) shouldShake = true; } } else { shouldShake = true; } if (shouldShake) { GameCameraManager.Instance.ShakeCamera(shakeForce); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\ConeLaserEffect.cs]
using System; using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using Random = UnityEngine.Random; [Serializable] public class ConeLaserEffect : SkillEffect { [Header("����Ԥ���� (��� NetworkObject + LaserVisual)")] [SerializeField] private NetworkObject _laserPrefab; [Header("��Χ����")] [Range(0, 180)] public float coneAngle = 60f; public int rayCount = 5; [Header("��������")] public float startLength = 0.5f; public float maxLength = 20f; public float growthTime = 1.0f; public float totalDuration = 3.0f; [Header("ս������")] public float rayWidth = 0.2f; public int damagePerTick = 10; public float damageInterval = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { caster.GetComponent<NetworkBehaviour>().StartCoroutine( LaserBarrageRoutine(caster) ); } private IEnumerator LaserBarrageRoutine(GameObject caster) { List<NetworkObject> activeLasers = new List<NetworkObject>(); List<Vector3> laserDirections = new List<Vector3>(); for (int i = 0; i < rayCount; i++) { float randomYAngle = Random.Range(-coneAngle / 2f, coneAngle / 2f); Quaternion rotation = Quaternion.Euler(0, randomYAngle, 0); Vector3 finalDir = rotation * caster.transform.forward; Vector3 spawnPos = caster.transform.position + Vector3.up * 1.0f; Quaternion laserRot = Quaternion.LookRotation(finalDir); var laserInstance = GameObject.Instantiate(_laserPrefab, spawnPos, laserRot); laserInstance.Spawn(); activeLasers.Add(laserInstance); laserDirections.Add(finalDir); if (laserInstance.TryGetComponent<LaserVisual>(out var visual)) { visual.InitializeLaserClientRpc(startLength, maxLength, growthTime, rayWidth); } } float timer = 0f; Dictionary<string, float> hitRecords = new Dictionary<string, float>(); while (timer < totalDuration) { timer += Time.deltaTime; float progress = Mathf.Clamp01(timer / growthTime); float currentLogicLen = Mathf.Lerp(startLength, maxLength, progress); for (int i = 0; i < activeLasers.Count; i++) { var laserObj = activeLasers[i]; if (laserObj == null || !laserObj.IsSpawned) continue; Vector3 origin = laserObj.transform.position; Vector3 dir = laserObj.transform.forward; RaycastHit[] hits = Physics.SphereCastAll(origin, rayWidth / 2f, dir, currentLogicLen); foreach (var hit in hits) { if (hit.collider.gameObject == caster) continue; if (hit.collider.TryGetComponent<IDamageable>(out var damageable)) { ulong targetId = hit.collider.GetComponent<NetworkObject>().NetworkObjectId; ulong laserId = laserObj.NetworkObjectId; string key = $"{laserId}_{targetId}"; if (!hitRecords.ContainsKey(key) || (Time.time - hitRecords[key] > damageInterval)) { damageable.TakeDamage(damagePerTick, caster.GetComponent<NetworkObject>().NetworkObjectId); hitRecords[key] = Time.time; } } } } yield return null; } foreach (var laser in activeLasers) { if (laser != null && laser.IsSpawned) { laser.Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\DamageEffect.cs]
using System; using Unity.Netcode; using UnityEngine; [Serializable] public class DamageEffect : SkillEffect { public int damageAmount = 10; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (target == null) return; if (target.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage( damageAmount, caster.GetComponent<NetworkObject>().NetworkObjectId); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\DynamicLaserEffect.cs]
using System; using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using Random = UnityEngine.Random; [Serializable] public class DynamicLaserEffect : SkillEffect { [Header("����Ԥ���� (��� NetworkObject + NetworkTransform + LaserVisual)")] [SerializeField] private NetworkObject _laserPrefab; [Header("��Χ����")] [Range(0, 180)] public float baseConeAngle = 60f; public int rayCount = 5; [Header("��̬ɨ������ (Snake Motion)")] public float sweepSpeed = 2.0f; public float sweepAmplitude = 30f; public bool syncRotationWithBoss = true; [Header("��������")] public float startLength = 0.5f; public float maxLength = 20f; public float growthTime = 1.0f; public float totalDuration = 5.0f; [Header("ս������")] public float rayWidth = 0.5f; public int damagePerTick = 10; public float damageInterval = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { caster.GetComponent<NetworkBehaviour>().StartCoroutine( LaserBarrageRoutine(caster) ); } private IEnumerator LaserBarrageRoutine(GameObject caster) { List<NetworkObject> activeLasers = new List<NetworkObject>(); List<float> initialYOffsets = new List<float>(); List<float> noiseSeeds = new List<float>(); for (int i = 0; i < rayCount; i++) { float t = rayCount > 1 ? (float)i / (rayCount - 1) : 0.5f; float baseAngle = Mathf.Lerp(-baseConeAngle / 2f, baseConeAngle / 2f, t); Vector3 spawnPos = caster.transform.position + Vector3.up * 1.0f; Quaternion spawnRot = caster.transform.rotation * Quaternion.Euler(0, baseAngle, 0); var laserInstance = GameObject.Instantiate(_laserPrefab, spawnPos, spawnRot); laserInstance.Spawn(); activeLasers.Add(laserInstance); initialYOffsets.Add(baseAngle); noiseSeeds.Add(Random.Range(0f, 100f)); if (laserInstance.TryGetComponent<LaserVisual>(out var visual)) { visual.InitializeLaserClientRpc(startLength, maxLength, growthTime, rayWidth); } } float timer = 0f; Dictionary<string, float> hitRecords = new Dictionary<string, float>(); while (timer < totalDuration) { if (caster == null) break; timer += Time.deltaTime; float growProgress = Mathf.Clamp01(timer / growthTime); float currentLogicLen = Mathf.Lerp(startLength, maxLength, growProgress); Vector3 bossCenter = caster.transform.position + Vector3.up * 1.0f; Quaternion bossForwardRot = syncRotationWithBoss ? caster.transform.rotation : Quaternion.identity; for (int i = 0; i < activeLasers.Count; i++) { var laserObj = activeLasers[i]; if (laserObj == null || !laserObj.IsSpawned) continue; laserObj.transform.position = bossCenter; float baseOffset = initialYOffsets[i]; float noiseVal = Mathf.PerlinNoise(Time.time * sweepSpeed, noiseSeeds[i]); float sweepOffset = (noiseVal - 0.5f) * 2f * sweepAmplitude; Quaternion targetRot = bossForwardRot * Quaternion.Euler(0, baseOffset + sweepOffset, 0); laserObj.transform.rotation = targetRot; Vector3 dir = laserObj.transform.forward; RaycastHit[] hits = Physics.SphereCastAll(bossCenter, rayWidth / 2f, dir, currentLogicLen); foreach (var hit in hits) { if (hit.collider.gameObject == caster) continue; if (activeLasers.Contains(hit.collider.GetComponent<NetworkObject>())) continue; if (hit.collider.TryGetComponent<IDamageable>(out var damageable)) { ulong targetId = hit.collider.GetComponent<NetworkObject>().NetworkObjectId; string key = $"{laserObj.NetworkObjectId}_{targetId}"; if (!hitRecords.ContainsKey(key) || (Time.time - hitRecords[key] > damageInterval)) { damageable.TakeDamage(damagePerTick, caster.GetComponent<NetworkObject>().NetworkObjectId); hitRecords[key] = Time.time; } } } } yield return null; } foreach (var laser in activeLasers) { if (laser != null && laser.IsSpawned) laser.Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\ExpandingNukeEffect.cs]
using System; using System.Collections; using Unity.Netcode; using UnityEngine; [Serializable] public class ExpandingNukeEffect : SkillEffect { [Header("�˱�����")] [SerializeField] private NetworkObject _nukePrefab; public float maxRadius = 10f; public float chargeTime = 3.0f; public int killDamage = 9999; public override void Execute(GameObject caster, GameObject target, Vector3 position) { Vector3 spawnPos = caster.transform.position; var nukeInstance = GameObject.Instantiate(_nukePrefab, spawnPos, Quaternion.identity); nukeInstance.Spawn(); caster.GetComponent<NetworkBehaviour>().StartCoroutine( NukeLogicRoutine(caster, nukeInstance) ); } private IEnumerator NukeLogicRoutine(GameObject caster, NetworkObject nukeObj) { if (nukeObj.TryGetComponent<NukeZoneVisual>(out var visual)) { visual.StartExpansionClientRpc(maxRadius, chargeTime); } yield return new WaitForSeconds(chargeTime); Vector3 explosionCenter = nukeObj.transform.position; Collider[] hits = Physics.OverlapSphere(explosionCenter, maxRadius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage(killDamage, caster.GetComponent<NetworkObject>().NetworkObjectId); Debug.Log($"�˱���ɱ��: {hit.name}"); } } if (nukeObj != null && nukeObj.IsSpawned) { nukeObj.Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\FlyingBullet.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class FlyingBullet : SkillEffect { [Header("Ͷ�������")] [SerializeField] private NetworkObject _bulletPrefab; public float speed = 10f; public float maxDistance = 20f; public int damage = 15; public float radius = 1f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { Vector3 spawnPos = caster.transform.position + Vector3.up * 1.5f; Vector3 direction = (position - caster.transform.position).normalized; direction.y = 0; var bulletInstance = GameObject.Instantiate(_bulletPrefab, spawnPos, Quaternion.LookRotation(direction)); bulletInstance.Spawn(); caster.GetComponent<NetworkBehaviour>().StartCoroutine( BulletLogic(caster, bulletInstance.gameObject, direction, spawnPos) ); } private IEnumerator BulletLogic(GameObject caster, GameObject bullet, Vector3 direction, Vector3 startPos) { float traveled = 0f; ulong attackerId = caster.GetComponent<NetworkObject>().OwnerClientId; while (traveled < maxDistance && bullet != null) { float step = speed * Time.deltaTime; bullet.transform.position += direction * step; traveled += step; if (Physics.CheckSphere(bullet.transform.position, radius, LayerMask.GetMask("Player", "Enemy"))) { Collider[] hits = Physics.OverlapSphere(bullet.transform.position, radius); bool hitValidTarget = false; foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.gameObject == bullet) continue; if (hit.TryGetComponent<IDamageable>(out var damageCmp)) { damageCmp.TakeDamage(damage, attackerId); hitValidTarget = true; } } if (hitValidTarget) { break; } } yield return null; } if (bullet != null && bullet.GetComponent<NetworkObject>().IsSpawned) { bullet.GetComponent<NetworkObject>().Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\KnockbackEffect.cs]
using System; using UnityEngine; using System.Collections; [Serializable] public class KnockbackEffect : SkillEffect { public float radius = 5f; public float force = 10f; public float stunTime = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { Collider[] hits = Physics.OverlapSphere(caster.transform.position, radius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IKnockBackable>(out var knockCmpnt)) { Vector3 dir = (hit.transform.position - caster.transform.position).normalized; dir.y = 0.5f; knockCmpnt.ApplyKnockbackServer(dir, force); Debug.Log($"������ {hit.name}"); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\SkillEffect.cs]
using System; using System.Collections; using Unity.Netcode; using UnityEngine; [Serializable] public abstract class SkillEffect { [Header("��������")] public string effectName; public abstract void Execute(GameObject caster, GameObject target, Vector3 position); } [Serializable] public class DelayEffect : SkillEffect { public float duration = 1.0f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\TeleportEffect.cs]
using System; using UnityEngine; [Serializable] public class TeleportEffect : SkillEffect { [Header("λ������")] public float distance = 5f; public bool isDash = true; public float duration = 0.2f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (!caster.TryGetComponent<PlayerNetworkMovement>(out var movement)) return; Vector3 direction = (position - caster.transform.position).normalized; direction.y = 0; direction.Normalize(); Vector3 targetPos = caster.transform.position + direction * distance; Debug.Log($"[Effect] λ��: {caster.name} �� {direction} �ƶ� {distance}��"); movement.ServerForceDash(direction, distance, duration); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillSO\SkillDataSO.cs]
using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; [CreateAssetMenu(fileName = "NewSkill", menuName = "Game/Skill Data")] public class SkillDataSO : ScriptableObject { [Header("���ܻ���")] public string SkillName; public float coolDown = 1.0f; public string animationName = "Skill1"; [Header("�������� (Charge)")] [Tooltip("����ʱ�䣨�룩����ӦԤ��Ȧ��ʱ��")] public float chargeDuration = 1.5f; [Tooltip("����ʱ�Ķ������ƣ����û��ר�ŵĶ������� Idle")] public string chargeAnimationName = "Idle"; [Header("Ԥ���Ӿ�")] [Tooltip("Ԥ��Ȧ Prefab")] public GameObject warningPrefab; public bool isSelfCentered; [SerializeReference, SubclassSelector] public List<SkillEffect> effects = new List<SkillEffect>(); public void Cast(GameObject caster, GameObject target, Vector3 position) { if (caster.TryGetComponent<NetworkBehaviour>(out var networkBehaviour)) { networkBehaviour.StartCoroutine(ExecutionRoutine(caster, target, position)); } } private IEnumerator ExecutionRoutine(GameObject caster, GameObject target, Vector3 position) { foreach (var effect in effects) { if (effect is DelayEffect delayEffect) { yield return new WaitForSeconds(delayEffect.duration); } effect.Execute(caster, target, position); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateCharge.cs]
using UnityEngine; public class BossStateCharge : IEnemyState { private BossPresentation _view; public BossStateCharge(BossPresentation view) { _view = view; } public void Enter() { string animName = _view.SkillChargeAnimationName; _view.Animator.CrossFade(animName, 0.1f); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateDie.cs]
using UnityEngine; public class BossStateDie : IEnemyState { private BossPresentation _view; public BossStateDie(BossPresentation view) { _view = view; } public void Enter() { } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateIdle.cs]
using UnityEngine; public class BossStateIdle : IEnemyState { private BossPresentation _view; public BossStateIdle(BossPresentation view) { _view = view; } public void Enter() { _view.Animator.Play("Idle"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateMove.cs]
using UnityEngine; using UnityEngine.AI; public class BossStateMove : IEnemyState { private BossPresentation _view; private NavMeshAgent _agent; public BossStateMove(BossPresentation view) { _view = view; _agent = view.GetComponent<NavMeshAgent>(); } public void Enter() { _view.Animator.Play("Walk"); } public void Exit() { } public void Update() { if (_agent != null) { if (_agent.velocity.sqrMagnitude < 0.1f) { } else { } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateSkill.cs]
using UnityEngine; public class BossStateSkill : IEnemyState { private BossPresentation _view; public BossStateSkill(BossPresentation view) { _view = view; } public void Enter() { _view.Animator.Play(_view.SkillAnimationName); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateAttack.cs]
using Unity.Netcode; using UnityEngine; public class EnemyStateAttack : IEnemyState { private EnemyPresentation _view; public EnemyStateAttack(EnemyPresentation view) { _view = view; } public void Enter() { Debug.Log("������빥��״̬"); _view.Animator.Play("Attack01"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateIdle.cs]
using Unity.Netcode; using UnityEngine; public class EnemyStateIdle : IEnemyState { private EnemyPresentation _view; private NetworkObject _target; public EnemyStateIdle(EnemyPresentation view) { _view = view; } public void Enter() { _view.Animator.Play("IdleNormal"); Debug.Log("������� Idle ״̬"); _target = null; } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateMove.cs]
using Unity.Netcode; using UnityEngine; public class EnemyStateMove : IEnemyState { private EnemyPresentation _view; public EnemyStateMove(EnemyPresentation view) { _view = view; } public void Enter() { Debug.Log("�������׷��״̬"); _view.Animator.Play("WalkFWD"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStatePatrol.cs]
public class EnemyStatePatrol : IEnemyState { public void Enter() { } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\IEnemyState.cs]
using UnityEngine; public interface IEnemyState { void Update(); void Enter(); void Exit(); }
[FILE END]
