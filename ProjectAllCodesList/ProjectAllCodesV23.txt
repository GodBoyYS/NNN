
[FILE START: Assets\Scripts\Editor\CodeCopyer.cs]
using UnityEngine; using UnityEditor; using System.IO; using System.Text; using System.Text.RegularExpressions; using System.Collections.Generic; public class CodeCopyer : EditorWindow { private class FolderNode { public string Name; public string FullPath; public bool IsSelected; public bool IsExpanded = true; public bool HasCodeFiles; public List<FolderNode> Children = new List<FolderNode>(); public FolderNode Parent; } private FolderNode _rootNode; private Vector2 _scrollPosition; private string _extractedCode = ""; private bool _hasScanned = false; [MenuItem("Tools/Code Copyer")] public static void ShowWindow() { GetWindow<CodeCopyer>("Code Copyer"); } private void OnGUI() { GUILayout.Space(10); GUILayout.Label("������ȡ���� (����������)", EditorStyles.boldLabel); GUILayout.Space(5); if (GUILayout.Button("ɨ�� Assets/Scripts Ŀ¼", GUILayout.Height(30))) { ScanFoldersTree(); } GUILayout.Space(10); if (_hasScanned && _rootNode != null) { GUILayout.Label("��ѡ��Ҫ��ȡ��ģ��:", EditorStyles.label); GUILayout.BeginHorizontal(); if (GUILayout.Button("ȫѡ", GUILayout.Width(60))) SetTreeSelection(_rootNode, true); if (GUILayout.Button("ȫ��ѡ", GUILayout.Width(60))) SetTreeSelection(_rootNode, false); if (GUILayout.Button("ȫ��չ��", GUILayout.Width(70))) SetTreeExpansion(_rootNode, true); if (GUILayout.Button("ȫ���۵�", GUILayout.Width(70))) SetTreeExpansion(_rootNode, false); GUILayout.EndHorizontal(); _scrollPosition = GUILayout.BeginScrollView(_scrollPosition, "box", GUILayout.Height(300)); DrawFolderNode(_rootNode, 0); GUILayout.EndScrollView(); } else if (_hasScanned && _rootNode == null) { GUILayout.Label("δ�ҵ�����������ļ��С�"); } GUILayout.Space(10); if (GUILayout.Button("��ȡ��ѹ������", GUILayout.Height(30))) { ExtractCodesFromTree(); } GUILayout.Space(10); GUILayout.Label("��������:", EditorStyles.boldLabel); var textAreaStyle = new GUIStyle(EditorStyles.textArea); textAreaStyle.wordWrap = true; _extractedCode = EditorGUILayout.TextArea(_extractedCode, textAreaStyle, GUILayout.Height(150)); GUILayout.Space(5); if (GUILayout.Button("Copy All (���Ƶ�������)", GUILayout.Height(40))) { if (!string.IsNullOrEmpty(_extractedCode)) { EditorGUIUtility.systemCopyBuffer = _extractedCode; EditorUtility.DisplayDialog("�ɹ�", "�����Ѹ��Ƶ������壡", "OK"); } else { EditorUtility.DisplayDialog("��ʾ", "û�пɸ��Ƶ�����", "OK"); } } } private void ScanFoldersTree() { string scriptsRoot = Path.Combine(Application.dataPath, "Scripts"); if (!Directory.Exists(scriptsRoot)) { EditorUtility.DisplayDialog("����", "δ�ҵ� 'Assets/Scripts' �ļ��У�", "OK"); return; } _rootNode = BuildDirectoryNode(scriptsRoot, null); if (_rootNode != null && !_rootNode.HasCodeFiles && _rootNode.Children.Count == 0) { _rootNode = null; } _hasScanned = true; } private FolderNode BuildDirectoryNode(string path, FolderNode parent) { bool hasCsFiles = Directory.GetFiles(path, "*.cs", SearchOption.TopDirectoryOnly).Length > 0; string[] subDirs = Directory.GetDirectories(path); List<FolderNode> childrenNodes = new List<FolderNode>(); foreach (var dir in subDirs) { FolderNode child = BuildDirectoryNode(dir, null); if (child != null) { childrenNodes.Add(child); } } if (!hasCsFiles && childrenNodes.Count == 0) { return null; } FolderNode node = new FolderNode { Name = new DirectoryInfo(path).Name, FullPath = path, IsSelected = true, IsExpanded = true, HasCodeFiles = hasCsFiles, Children = childrenNodes, Parent = parent }; foreach (var child in childrenNodes) { child.Parent = node; } return node; } private void DrawFolderNode(FolderNode node, int indentLevel) { GUILayout.BeginHorizontal(); GUILayout.Space(indentLevel * 20); if (node.Children.Count > 0) { node.IsExpanded = EditorGUILayout.Foldout(node.IsExpanded, GUIContent.none, true); } else { GUILayout.Space(13); } bool prevSelected = node.IsSelected; string displayName = node.Name + (node.HasCodeFiles ? " (������)" : ""); node.IsSelected = EditorGUILayout.ToggleLeft(displayName, node.IsSelected); if (node.IsSelected != prevSelected) { SetTreeSelection(node, node.IsSelected); } GUILayout.EndHorizontal(); if (node.IsExpanded) { foreach (var child in node.Children) { DrawFolderNode(child, indentLevel + 1); } } } private void SetTreeSelection(FolderNode node, bool select) { if (node == null) return; node.IsSelected = select; foreach (var child in node.Children) { SetTreeSelection(child, select); } } private void SetTreeExpansion(FolderNode node, bool expand) { if (node == null) return; node.IsExpanded = expand; foreach (var child in node.Children) { SetTreeExpansion(child, expand); } } private void ExtractCodesFromTree() { if (_rootNode == null) return; StringBuilder sb = new StringBuilder(); int totalFiles = 0; CollectCodesRecursive(_rootNode, sb, ref totalFiles); _extractedCode = sb.ToString(); if (totalFiles == 0) { _extractedCode = "δѡ���κΰ���������ļ��С�"; } else { Debug.Log($"��ȡ��ɣ������� {totalFiles} ���ļ���"); } } private void CollectCodesRecursive(FolderNode node, StringBuilder sb, ref int count) { if (node.IsSelected && node.HasCodeFiles) { string[] files = Directory.GetFiles(node.FullPath, "*.cs", SearchOption.TopDirectoryOnly); foreach (string path in files) { ProcessFile(path, sb); count++; } } foreach (var child in node.Children) { CollectCodesRecursive(child, sb, ref count); } } private void ProcessFile(string path, StringBuilder sb) { string content = File.ReadAllText(path, Encoding.UTF8); string compressedContent = CompressCode(content); string relativePath = path.Replace(Application.dataPath, "Assets"); sb.Append($"\n[FILE START: {relativePath}]\n"); sb.Append(compressedContent); sb.Append($"\n[FILE END]\n"); } private string CompressCode(string source) { string noBlockComments = Regex.Replace(source, @"/\*[\s\S]*?\*/", ""); string noLineComments = Regex.Replace(noBlockComments, @" string singleLine = Regex.Replace(noLineComments, @"\s+", " "); return singleLine.Trim(); } }
[FILE END]

[FILE START: Assets\Scripts\Editor\CodeZipper.cs]
using UnityEngine; using UnityEditor; using System.IO; using System.Text; using System.Text.RegularExpressions; public class CodeZipper : EditorWindow { [MenuItem("Tools/Code Zipper")] public static void ShowWindow() { GetWindow<CodeZipper>("Code Zipper"); } private void OnGUI() { GUILayout.Space(20); GUILayout.Label("��Ŀ������ȡ����", EditorStyles.boldLabel); GUILayout.Space(10); EditorGUILayout.HelpBox("�ù��߽���ȡ Assets/Scripts ������ .cs �ļ����Ƴ�ע���뻻�У��������һ���ı��ļ���\n\n�ļ��������ڣ�\n��Ŀ��Ŀ¼/ProjectAllCodesList/", MessageType.Info); GUILayout.Space(20); if (GUILayout.Button("Start Zip (��ȡ��ѹ��)", GUILayout.Height(40))) { ZipCodes(); } } private void ZipCodes() { string scriptsFolder = Path.Combine(Application.dataPath, "Scripts"); if (!Directory.Exists(scriptsFolder)) { EditorUtility.DisplayDialog("����", "δ�ҵ� 'Assets/Scripts' �ļ��У�\n��ȷ����Ĵ��붼�� Scripts Ŀ¼�¡�", "ȷ��"); return; } string[] scriptPaths = Directory.GetFiles(scriptsFolder, "*.cs", SearchOption.AllDirectories); StringBuilder sb = new StringBuilder(); int fileCount = 0; foreach (string path in scriptPaths) { string content = File.ReadAllText(path, Encoding.UTF8); string compressedContent = CompressCode(content); string relativePath = path.Replace(Application.dataPath, "Assets"); sb.Append($"\n[FILE START: {relativePath}]\n"); sb.Append(compressedContent); sb.Append($"\n[FILE END]\n"); fileCount++; } string projectRoot = Directory.GetParent(Application.dataPath).FullName; string targetDir = Path.Combine(projectRoot, "ProjectAllCodesList"); if (!Directory.Exists(targetDir)) { Directory.CreateDirectory(targetDir); } string outputFileName = GetNextVersionFileName(targetDir); string finalPath = Path.Combine(targetDir, outputFileName); File.WriteAllText(finalPath, sb.ToString(), Encoding.UTF8); EditorUtility.DisplayDialog("���", $"�ɹ���ȡ {fileCount} ���ű��ļ���\n(��Դ: Assets/Scripts)\n\n�ѱ�����:\n{finalPath}", "ȷ��"); EditorUtility.RevealInFinder(finalPath); } private string CompressCode(string source) { string noBlockComments = Regex.Replace(source, @"/\*[\s\S]*?\*/", ""); string noLineComments = Regex.Replace(noBlockComments, @" string singleLine = Regex.Replace(noLineComments, @"\s+", " "); return singleLine.Trim(); } private string GetNextVersionFileName(string folderPath) { string baseName = "ProjectAllCodesV"; string extension = ".txt"; int version = 1; while (true) { string fileName = $"{baseName}{version}{extension}"; string fullPath = Path.Combine(folderPath, fileName); if (!File.Exists(fullPath)) { return fileName; } version++; } } }
[FILE END]

[FILE START: Assets\Scripts\Editor\SubclassSelectorDrawer.cs]
using System; using System.Linq; using UnityEditor; using UnityEngine; [CustomPropertyDrawer(typeof(SubclassSelectorAttribute))] public class SubclassSelectorDrawer : PropertyDrawer { public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { if (property.propertyType != SerializedPropertyType.ManagedReference) { EditorGUI.PropertyField(position, property, label, true); return; } var labelRect = new Rect(position.x, position.y, EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight); EditorGUI.LabelField(labelRect, label); var buttonRect = new Rect(position.x + EditorGUIUtility.labelWidth, position.y, position.width - EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight); string typeName = GetTypeName(property); if (EditorGUI.DropdownButton(buttonRect, new GUIContent(typeName), FocusType.Passive)) { ShowTypeMenu(property); } EditorGUI.PropertyField(position, property, GUIContent.none, true); } private void ShowTypeMenu(SerializedProperty property) { var menu = new GenericMenu(); string typeName = property.managedReferenceFieldTypename; if (string.IsNullOrEmpty(typeName)) return; var splitTypeString = typeName.Split(' '); var assemblyName = splitTypeString[0]; var className = splitTypeString[1]; var assembly = AppDomain.CurrentDomain.GetAssemblies() .FirstOrDefault(a => a.GetName().Name == assemblyName); if (assembly == null) { Debug.LogError($"[SubclassSelector] �Ҳ��� Assembly: {assemblyName}"); return; } Type baseType = assembly.GetType(className); if (baseType == null) { Debug.LogError($"[SubclassSelector] �Ҳ�������: {className}"); return; } var types = AppDomain.CurrentDomain.GetAssemblies() .SelectMany(s => s.GetTypes()) .Where(p => baseType.IsAssignableFrom(p) && p.IsClass && !p.IsAbstract); menu.AddItem(new GUIContent("None (Null)"), false, () => { property.managedReferenceValue = null; property.serializedObject.ApplyModifiedProperties(); }); foreach (var type in types) { string menuLabel = type.Name; menu.AddItem(new GUIContent(menuLabel), false, () => { property.managedReferenceValue = Activator.CreateInstance(type); property.serializedObject.ApplyModifiedProperties(); }); } menu.ShowAsContext(); } private string GetTypeName(SerializedProperty property) { if (string.IsNullOrEmpty(property.managedReferenceFullTypename)) return "Select Type..."; return property.managedReferenceFullTypename.Split('.').Last(); } public override float GetPropertyHeight(SerializedProperty property, GUIContent label) { return EditorGUI.GetPropertyHeight(property, label, true); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\CharacterDatabaseSO.cs]
using UnityEngine; using Unity.Netcode; using System.Collections.Generic; [CreateAssetMenu(fileName = "CharacterDatabase", menuName = "Game/Character Database")] public class CharacterDatabaseSO : ScriptableObject { public List<NetworkObject> characterPrefabs; public NetworkObject GetPrefabById(int id) { if (id >= 0 && id < characterPrefabs.Count) { return characterPrefabs[id]; } Debug.Log("��ȡĬ�Ͻ�ɫ"); return characterPrefabs[0]; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\DestructableCrate.cs]
using Unity.Netcode; using UnityEngine; public class DestructableCrate : NetworkBehaviour, IDamageable { [SerializeField] private NetworkObject _lootPrefab; private readonly NetworkVariable<int> _hp = new NetworkVariable<int>( 50, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public void TakeDamage(int amount, ulong attackerId) { _hp.Value -= amount; if( _hp.Value <= 0) { if(_lootPrefab != null) { var lootInstance = Instantiate(_lootPrefab, transform.position, Quaternion.identity); lootInstance.Spawn(); } GetComponent<NetworkObject>().Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\GameLifecycleManager.cs]
using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using UnityEngine.SceneManagement; public class GameLifecycleManager : NetworkBehaviour { [SerializeField] private BossController bossInstance; private List<PlayerMainController> activePlayers = new List<PlayerMainController>(); private bool isGameEnded = false; public static GameLifecycleManager Instance { get; private set; } public void Awake() { Instance = this; } public override void OnNetworkSpawn() { if (!IsServer) return; NetworkManager.Singleton.OnClientConnectedCallback += HandleClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback += HandleClientDisconnect; foreach (var client in NetworkManager.Singleton.ConnectedClientsList) { if (client.PlayerObject != null) { var player = client.PlayerObject.GetComponent<PlayerMainController>(); RegisterPlayer(player); } } if (bossInstance != null) { bossInstance.OnBossDied += HandleBossDefeat; } } public override void OnNetworkDespawn() { if (!IsServer) return; if (NetworkManager.Singleton != null) { NetworkManager.Singleton.OnClientConnectedCallback -= HandleClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback -= HandleClientDisconnect; } } public void RegisterPlayer(PlayerMainController player) { if (!IsServer || player == null) return; if (!activePlayers.Contains(player)) { activePlayers.Add(player); player.DataContainer.OnDied += HandlePlayerDeath; Debug.Log($"[Manager] Player Registered. ID: {player.OwnerClientId}. Total Players: {activePlayers.Count}"); } } public void UnregisterPlayer(PlayerMainController player) { if (!IsServer || player == null) return; if (activePlayers.Contains(player)) { player.DataContainer.OnDied -= HandlePlayerDeath; activePlayers.Remove(player); Debug.Log($"[Manager] Player Unregistered. ID: {player.OwnerClientId}. Remaining: {activePlayers.Count}"); } } private void HandlePlayerDeath(PlayerDataContainer deadPlayer) { if (isGameEnded) return; Debug.Log($"[Manager] HandlePlayerDeath Triggered for Player {deadPlayer.OwnerClientId}"); int aliveCount = 0; foreach (var p in activePlayers) { if (p != null && !p.DataContainer.IsDead) { aliveCount++; } } Debug.Log($"[Manager] Alive Count: {aliveCount}"); if (aliveCount <= 0) { EndGame(false); } } private void HandleClientConnected(ulong clientId) { if (NetworkManager.Singleton.ConnectedClients.TryGetValue(clientId, out var client)) { if (client.PlayerObject != null) { RegisterPlayer(client.PlayerObject.GetComponent<PlayerMainController>()); } } } private void HandleClientDisconnect(ulong clientId) { } private void HandleBossDefeat() { if (isGameEnded) return; EndGame(true); } private void EndGame(bool isVictory) { isGameEnded = true; Debug.Log(isVictory ? "VICTORY! Loading WinScene..." : "DEFEAT! Loading Init..."); if (isVictory) { SceneManager.LoadScene("WinScene", LoadSceneMode.Single); } else { NetworkManager.Singleton.Shutdown(); SceneManager.LoadScene("Init", LoadSceneMode.Single); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\InteractCube.cs]
using UnityEngine; public class InteractCube : MonoBehaviour, IInteractable { private bool _stateBig = false; public string InteractionPrompt => "PickUp"; public void Interact(GameObject source) { if (_stateBig) { transform.localScale = Vector3.one * 2.0f; _stateBig = false; } else { transform.localScale = Vector3.one; _stateBig = true; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\InteracteHeal.cs]
using Unity.Netcode; using UnityEngine; public class InteracteHeal : NetworkBehaviour, IInteractable { public string InteractionPrompt => "Eat"; public void Interact(GameObject source) { ulong sourceId = source.GetComponent<NetworkObject>().NetworkObjectId; RequestInteractServerRpc(sourceId); } [ServerRpc(RequireOwnership = false)] private void RequestInteractServerRpc(ulong sourceId) { if(NetworkManager.SpawnManager.SpawnedObjects.TryGetValue(sourceId, out var sourceObject)) { if (Vector3.Distance(transform.position, sourceObject.transform.position) > 3.0f) return; if(sourceObject.TryGetComponent<PlayerNetworkHealth>(out var health)) { health.ServerHeal(10); GetComponent<NetworkObject>().Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\MouseHoverHighlight.cs]
using UnityEngine; [RequireComponent(typeof(Collider))] public class MouseHoverHighlight : MonoBehaviour { [Header("Settings")] [SerializeField] private Color highlightColor = Color.yellow; [SerializeField] private float emissionIntensity = 2.0f; private Renderer[] _renderers; private MaterialPropertyBlock _propBlock; private bool _isHovered = false; private void Awake() { _renderers = GetComponentsInChildren<Renderer>(); _propBlock = new MaterialPropertyBlock(); } private void OnMouseEnter() { if (_isHovered) return; _isHovered = true; SetHighlight(true); } private void OnMouseExit() { if (!_isHovered) return; _isHovered = false; SetHighlight(false); } private void SetHighlight(bool active) { foreach (var r in _renderers) { r.GetPropertyBlock(_propBlock); if (active) { _propBlock.SetColor("_EmissionColor", highlightColor * emissionIntensity); } else { _propBlock.SetColor("_EmissionColor", Color.black); } r.SetPropertyBlock(_propBlock); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\PickupItem.cs]
using Unity.Netcode; using UnityEngine; public class PickupItem : NetworkBehaviour, IInteractable { private int points = 10; public string InteractionPrompt => "Pickup"; public void Interact(GameObject source) { RequestPickupServerRpc(source.GetComponent<NetworkObject>().NetworkObjectId); } [ServerRpc(RequireOwnership = false)] private void RequestPickupServerRpc(ulong sourceId) { if (NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(sourceId, out var sourceNetObj)) { if (Vector3.Distance(transform.position, sourceNetObj.transform.position) > 3.0f) return; if (sourceNetObj.TryGetComponent<PlayerDataContainer>(out var playerdata)) { playerdata.AddPointsServer(points); playerdata.AddItemServer(gameObject.name); GetComponent<NetworkObject>().Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\PotionSpawner.cs]
using Unity.Netcode; using UnityEngine; public class PotionSpawner : NetworkBehaviour { [SerializeField] private NetworkObject potionPrefab; [SerializeField] private Transform[] spawnPoints; public override void OnNetworkSpawn() { if (IsServer) { foreach (var point in spawnPoints) { SpawnPotion(point.position); } } } private void SpawnPotion(Vector3 position) { if (potionPrefab == null) return; var instance = Instantiate(potionPrefab, position, Quaternion.identity); instance.Spawn(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\testBossSkill.cs]
using Unity.Netcode; using UnityEngine; public class testBossSkill : NetworkBehaviour { public SkillDataSO[] skills; public LayerMask goundLayer; void Start() { } void Update() { if (Input.GetMouseButtonDown(0)) { if( Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hit, 1000f, goundLayer)) { var targetpos = hit.point; transform.position = targetpos; } } if (Input.GetKeyDown(KeyCode.I)) { Debug.Log("boss�ͷż���2"); skills[0].Cast(gameObject, null, transform.position); } if (Input.GetKeyDown(KeyCode.O)) { Debug.Log("boss�ͷŴ���"); skills[1].Cast(gameObject, null, transform.position); } if (Input.GetKeyDown(KeyCode.P)) { Debug.Log("boss�ͷ�����"); skills[2].Cast(gameObject, null, transform.position); } } }
[FILE END]

[FILE START: Assets\Scripts\InitScene\ConnectionManager.cs]
using System; using System.Collections.Generic; using System.Text; using Unity.Netcode; using UnityEngine; using UnityEngine.SceneManagement; public class ConnectionManager : MonoBehaviour { [Header("Settings")] [SerializeField] private CharacterDatabaseSO characterDatabase; [SerializeField] private string gameSceneName = "Game"; private Dictionary<ulong, int> _clientSelectionData = new Dictionary<ulong, int>(); private void Start() { DontDestroyOnLoad(this); } private void OnEnable() { if (NetworkManager.Singleton != null) { SubscribeEvents(); } } private void SubscribeEvents() { UnsubscribeEvents(); NetworkManager.Singleton.ConnectionApprovalCallback += ApprovalCheck; NetworkManager.Singleton.OnClientConnectedCallback += OnClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback += OnClientDisconnect; Debug.Log("ConnectionManager: �����¼����ĳɹ���"); } private void UnsubscribeEvents() { if (NetworkManager.Singleton == null) return; NetworkManager.Singleton.ConnectionApprovalCallback -= ApprovalCheck; NetworkManager.Singleton.OnClientConnectedCallback -= OnClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback -= OnClientDisconnect; if (NetworkManager.Singleton.SceneManager != null) { NetworkManager.Singleton.SceneManager.OnLoadEventCompleted -= OnSceneLoadComplete; } } private void OnDestroy() { UnsubscribeEvents(); } public void StartHostWithCharacter(int characterIndex) { SubscribeEvents(); var payload = Encoding.ASCII.GetBytes(characterIndex.ToString()); NetworkManager.Singleton.NetworkConfig.ConnectionData = payload; NetworkManager.Singleton.NetworkConfig.PlayerPrefab = null; Debug.Log($"1. [Host] ׼�������ѡ���ɫ: {characterIndex}"); if (NetworkManager.Singleton.StartHost()) { Debug.Log("2. [Host] ����ɹ���"); if (NetworkManager.Singleton.SceneManager != null) { NetworkManager.Singleton.SceneManager.OnLoadEventCompleted += OnSceneLoadComplete; Debug.Log(" -> �����¼����ĳɹ�"); NetworkManager.Singleton.SceneManager.LoadScene(gameSceneName, LoadSceneMode.Single); } else { Debug.LogError("!!! ��������SceneManager ��ȻΪ�գ����� Inspector ���Ƿ�ѡ�� 'Enable Scene Management' !!!"); } } } public void StartClientWithCharacter(int characterIndex) { SubscribeEvents(); var payload = Encoding.ASCII.GetBytes(characterIndex.ToString()); NetworkManager.Singleton.NetworkConfig.ConnectionData = payload; NetworkManager.Singleton.NetworkConfig.PlayerPrefab = null; Debug.Log($"1. [Client] ׼�����ӣ�ѡ���ɫ: {characterIndex}"); NetworkManager.Singleton.StartClient(); } private void ApprovalCheck(NetworkManager.ConnectionApprovalRequest request, NetworkManager.ConnectionApprovalResponse response) { int charId = 0; if (request.Payload != null) { int.TryParse(Encoding.ASCII.GetString(request.Payload), out charId); } if (_clientSelectionData.ContainsKey(request.ClientNetworkId)) _clientSelectionData[request.ClientNetworkId] = charId; else _clientSelectionData.Add(request.ClientNetworkId, charId); Debug.Log($"3. [Server] ����ͨ��: �ͻ���ID {request.ClientNetworkId} ѡ���˽�ɫ {charId}"); response.Approved = true; response.CreatePlayerObject = false; } private void OnClientConnected(ulong clientId) { if (!NetworkManager.Singleton.IsServer) return; Debug.Log($"4. [Server] �ͻ��� {clientId} ���ӳɹ�����ǰ����: {SceneManager.GetActiveScene().name}"); if (SceneManager.GetActiveScene().name == gameSceneName) { Debug.Log($" -> �Ѿ�����Ϸ������ֱ�����ɽ�ɫ�� {clientId}"); SpawnPlayer(clientId); } else { Debug.Log($" -> ���� {SceneManager.GetActiveScene().name}���ݲ����ɣ��ȴ���������..."); } } private void OnSceneLoadComplete(string sceneName, LoadSceneMode loadSceneMode, List<ulong> clientsCompleted, List<ulong> clientsTimedOut) { if (!NetworkManager.Singleton.IsServer) return; if (!sceneName.Contains(gameSceneName)) return; Debug.Log($"5. [Server] ���� {sceneName} ������ϣ���ʼ��鲢���ɽ�ɫ..."); foreach (ulong clientId in NetworkManager.Singleton.ConnectedClientsIds) { if (NetworkManager.Singleton.ConnectedClients[clientId].PlayerObject == null) { Debug.Log($" -> Ϊ��� {clientId} ������ɫ"); SpawnPlayer(clientId); } } } private void SpawnPlayer(ulong clientId) { int charId = _clientSelectionData.ContainsKey(clientId) ? _clientSelectionData[clientId] : 0; NetworkObject prefab = characterDatabase.GetPrefabById(charId); if (prefab == null) return; Vector3 pos = new Vector3(clientId * 2, 1, 0); GameObject instance = Instantiate(prefab.gameObject, pos, Quaternion.identity); NetworkObject netObj = instance.GetComponent<NetworkObject>(); netObj.SpawnAsPlayerObject(clientId, true); Debug.Log($"6. [Server] �ɹ����ɽ�ɫ {charId} ����� {clientId}"); } private void OnClientDisconnect(ulong clientId) { if (NetworkManager.Singleton.IsServer) _clientSelectionData.Remove(clientId); } }
[FILE END]

[FILE START: Assets\Scripts\InitScene\InitSceneController.cs]
using UnityEngine; using UnityEngine.SceneManagement; public class InitSceneController : MonoBehaviour { void Start() { } void Update() { } public void OnStartClicke() { SceneManager.LoadScene("Game"); } }
[FILE END]

[FILE START: Assets\Scripts\System\NetworkObjectPool.cs]
using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using UnityEngine.Pool; public class NetworkObjectPool : NetworkBehaviour { public static NetworkObjectPool Instance { get; private set; } [System.Serializable] struct PoolConfig { public GameObject Prefab; public int PrewarmCount; } [Header("ע������")] [SerializeField] private List<PoolConfig> _pooledPrefabs; private Dictionary<GameObject, ObjectPool<NetworkObject>> _pools = new Dictionary<GameObject, ObjectPool<NetworkObject>>(); private Dictionary<NetworkObject, GameObject> _spawnedObjects = new Dictionary<NetworkObject, GameObject>(); private void Awake() { if (Instance != null && Instance != this) { Destroy(gameObject); return; } Instance = this; } public override void OnNetworkSpawn() { foreach (var config in _pooledPrefabs) { RegisterPrefab(config.Prefab, config.PrewarmCount); } } public override void OnNetworkDespawn() { foreach (var prefab in _pools.Keys) { NetworkManager.Singleton.PrefabHandler.RemoveHandler(prefab); } } private void RegisterPrefab(GameObject prefab, int count) { var pool = new ObjectPool<NetworkObject>( createFunc: () => CreateFunc(prefab), actionOnGet: ActionOnGet, actionOnRelease: ActionOnRelease, actionOnDestroy: ActionOnDestroy, defaultCapacity: count ); _pools.Add(prefab, pool); List<NetworkObject> temp = new List<NetworkObject>(); for (int i = 0; i < count; i++) temp.Add(pool.Get()); foreach (var obj in temp) pool.Release(obj); NetworkManager.Singleton.PrefabHandler.AddHandler(prefab, new PooledPrefabInstanceHandler(prefab, this)); } private NetworkObject CreateFunc(GameObject prefab) { var go = Instantiate(prefab); return go.GetComponent<NetworkObject>(); } private void ActionOnGet(NetworkObject netObj) => netObj.gameObject.SetActive(true); private void ActionOnRelease(NetworkObject netObj) => netObj.gameObject.SetActive(false); private void ActionOnDestroy(NetworkObject netObj) => Destroy(netObj.gameObject); public NetworkObject GetNetworkObject(GameObject prefab, Vector3 pos, Quaternion rot) { if (!IsServer) { Debug.LogError("[NetworkObjectPool] ֻ�з��������������ɶ���"); return null; } NetworkObject netObj = _pools[prefab].Get(); netObj.transform.position = pos; netObj.transform.rotation = rot; if (!_spawnedObjects.ContainsKey(netObj)) _spawnedObjects.Add(netObj, prefab); if (!netObj.IsSpawned) netObj.Spawn(true); return netObj; } public void ReturnNetworkObject(NetworkObject netObj) { if (!IsServer) return; if (netObj.IsSpawned) netObj.Despawn(false); if (_spawnedObjects.TryGetValue(netObj, out GameObject prefab)) { _pools[prefab].Release(netObj); } } public NetworkObject GetLocal(GameObject prefab) => _pools[prefab].Get(); public void ReturnLocal(NetworkObject netObj, GameObject prefab) => _pools[prefab].Release(netObj); } public class PooledPrefabInstanceHandler : INetworkPrefabInstanceHandler { private GameObject _prefab; private NetworkObjectPool _pool; public PooledPrefabInstanceHandler(GameObject prefab, NetworkObjectPool pool) { _prefab = prefab; _pool = pool; } public NetworkObject Instantiate(ulong ownerClientId, Vector3 position, Quaternion rotation) { var netObj = _pool.GetLocal(_prefab); netObj.transform.position = position; netObj.transform.rotation = rotation; return netObj; } public void Destroy(NetworkObject networkObject) { _pool.ReturnLocal(networkObject, _prefab); } }
[FILE END]

[FILE START: Assets\Scripts\WinScene\WinSceneController.cs]
using UnityEngine; using UnityEngine.SceneManagement; public class WinSceneController : MonoBehaviour { void Start() { } void Update() { } public void OnBtnBackToInitClicked() { SceneManager.LoadScene("Init"); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Camera\GameCameraManager.cs]
using UnityEngine; using Unity.Netcode; using Unity.Cinemachine; public class GameCameraManager : MonoBehaviour { public static GameCameraManager Instance { get; private set; } [Header("Cinemachine Components")] [SerializeField] private CinemachineCamera virtualCamera; [SerializeField] private CinemachineImpulseSource impulseSource; private void Awake() { Instance = this; } public void SetFollowTarget(Transform target) { if (virtualCamera != null) { virtualCamera.Follow = target; Debug.Log($"[Camera] Now following {target.name}"); } } public void ShakeCamera(float force) { if (impulseSource != null) { impulseSource.GenerateImpulse(force); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Camera\TestShake.cs]
using UnityEngine; using Unity.Cinemachine; public class TestShake : MonoBehaviour { public CinemachineCamera targetCamera; public NoiseSettings noiseProfile; void Update() { if (Input.GetKeyDown(KeyCode.T)) { Debug.Log("ǿ�Ʋ����𶯣�"); if (targetCamera != null && noiseProfile != null) { } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Combat\DamageFlash.cs]
using System.Collections; using UnityEngine; public class DamageFlash : MonoBehaviour { [Header("Settings")] [SerializeField] private Color flashColor = Color.white; [SerializeField] private float duration = 0.1f; private SkinnedMeshRenderer[] _renderers; private MaterialPropertyBlock _propBlock; private Coroutine _flashRoutine; private void Awake() { _renderers = GetComponentsInChildren<SkinnedMeshRenderer>(); _propBlock = new MaterialPropertyBlock(); } public void TriggerFlash() { if (_flashRoutine != null) StopCoroutine(_flashRoutine); _flashRoutine = StartCoroutine(FlashRoutine()); } private IEnumerator FlashRoutine() { foreach (var r in _renderers) { r.GetPropertyBlock(_propBlock); _propBlock.SetColor("_EmissionColor", flashColor * 5f); r.SetPropertyBlock(_propBlock); } yield return new WaitForSeconds(duration); foreach (var r in _renderers) { r.GetPropertyBlock(_propBlock); _propBlock.SetColor("_EmissionColor", Color.black); r.SetPropertyBlock(_propBlock); } _flashRoutine = null; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Combat\HitStopManager.cs]
using System.Collections; using UnityEngine; public class HitStopManager : MonoBehaviour { public static HitStopManager Instance { get; private set; } private bool _isWaiting = false; private void Awake() { Instance = this; } public void TriggerHitStop(float duration = 0.05f, float timeScale = 0.1f) { if (_isWaiting) return; StartCoroutine(HitStopRoutine(duration, timeScale)); } private IEnumerator HitStopRoutine(float duration, float targetScale) { _isWaiting = true; float original = Time.timeScale; Time.timeScale = targetScale; yield return new WaitForSecondsRealtime(duration); Time.timeScale = original; _isWaiting = false; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IDamageable.cs]
using UnityEngine; public interface IDamageable { void TakeDamage(int amount, ulong attackerId); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IDamageMitigator.cs]
public interface IDamageMitigator { void ApplyDamageReduction(float percentage, float duration); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IInteractable.cs]
using UnityEngine; public interface IInteractable { string InteractionPrompt { get; } void Interact(GameObject source); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IKnockBackable.cs]
using UnityEngine; public interface IKnockBackable { void ApplyKnockbackServer(Vector3 forceDir, float forceStrength); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\ITeleportable.cs]
using UnityEngine; public interface ITeleportable { void TeleportServer(Vector3 position); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Level\BattleZone.cs]
using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using UnityEngine.AI; [RequireComponent(typeof(BoxCollider))] public class BattleZone : NetworkBehaviour { [Header("����")] [SerializeField] private GateController _exitGate; [SerializeField] private GateController _entryGate; [System.Serializable] public struct EnemyWave { public GameObject EnemyPrefab; public Transform SpawnPoint; [Tooltip("�ڸð뾶���������")] public float SpawnRadius; [Tooltip("һ����������")] public int Count; } [SerializeField] private List<EnemyWave> _enemiesToSpawn; [Header("״̬")] private bool _isZoneActive = false; private bool _isZoneCleared = false; private int _aliveEnemyCount = 0; private int _aliveBossCount = 0; public override void OnNetworkSpawn() { if (IsServer) { if (_exitGate != null) _exitGate.SetLocked(true); if (_entryGate != null) _entryGate.SetLocked(false); } } private void OnTriggerEnter(Collider other) { if (!IsServer) return; if (_isZoneActive || _isZoneCleared) return; if (other.CompareTag("Player")) { StartBattle(); } } private void StartBattle() { _isZoneActive = true; Debug.Log($"[BattleZone] {gameObject.name} ս����ʼ��"); if (_entryGate != null) _entryGate.SetLocked(true); SpawnEnemies(); } private void SpawnEnemies() { _aliveEnemyCount = 0; _aliveBossCount = 0; foreach (var waveData in _enemiesToSpawn) { int spawnCount = waveData.Count > 0 ? waveData.Count : 1; float radius = waveData.SpawnRadius > 0 ? waveData.SpawnRadius : 2.0f; for (int i = 0; i < spawnCount; i++) { Vector3 spawnPos = waveData.SpawnPoint.position; Vector2 randomCircle = Random.insideUnitCircle * radius; Vector3 randomOffset = new Vector3(randomCircle.x, 0, randomCircle.y); Vector3 potentialPos = spawnPos + randomOffset; if (NavMesh.SamplePosition(potentialPos, out NavMeshHit hit, 5.0f, NavMesh.AllAreas)) { spawnPos = hit.position; } NetworkObject enemyNetObj = NetworkObjectPool.Instance.GetNetworkObject( waveData.EnemyPrefab, spawnPos, waveData.SpawnPoint.rotation ); if (enemyNetObj != null) { if (enemyNetObj.TryGetComponent<EnemyController>(out var enemyScript)) { enemyScript.OnDied += HandleEnemyDeath; var agent = enemyNetObj.GetComponent<NavMeshAgent>(); if (agent != null) agent.enabled = true; _aliveEnemyCount++; } else if (enemyNetObj.TryGetComponent<BossController>(out var bossScript)) { bossScript.OnBossDied += HandleEnemyDeathNoArg; _aliveBossCount++; } } } } Debug.Log($"[BattleZone] ������ {_aliveEnemyCount} ������"); } private void HandleEnemyDeath(NetworkObject deadEnemy) { if (deadEnemy.TryGetComponent<EnemyController>(out var script)) script.OnDied -= HandleEnemyDeath; DecreaseEnemyCount(); } private void HandleEnemyDeathNoArg() { DecreaseEnemyCount(); } private void DecreaseEnemyCount() { _aliveEnemyCount--; if (_aliveEnemyCount <= 0) { FinishBattle(); } } private void FinishBattle() { _isZoneCleared = true; _isZoneActive = false; Debug.Log($"[BattleZone] {gameObject.name} ������ϣ�"); if (_exitGate != null) _exitGate.SetLocked(false); if (_entryGate != null) _entryGate.SetLocked(false); ShowZoneClearClientRpc(); } [ClientRpc] private void ShowZoneClearClientRpc() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Level\GateController.cs]
using Unity.Netcode; using UnityEngine; public class GateController : NetworkBehaviour { [SerializeField] private GameObject _visualModel; [SerializeField] private Collider _blockCollider; public override void OnNetworkSpawn() { SetGateState(true); } public void SetLocked(bool isLocked) { if (!IsServer) return; SetGateClientRpc(isLocked); } [ClientRpc] private void SetGateClientRpc(bool isLocked) { if (isLocked) return; _visualModel.GetComponent<NetworkObject>().Despawn(); } private void SetGateState(bool isLocked) { _visualModel.SetActive(isLocked); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\BossPresentation.cs]
using UnityEngine; using UnityEngine.AI; [System.Obsolete("Logic moved to BossController. Please reference Animator/Agent directly in Controller.")] public class BossPresentation : MonoBehaviour { [Header("Component References")] public Animator Animator; public NavMeshAgent Agent; private void Awake() { if (Animator == null) Animator = GetComponent<Animator>(); if (Agent == null) Agent = GetComponent<NavMeshAgent>(); } public void PlayAnimation(string animName, float transitionDuration = 0.1f) { if (Animator != null && !string.IsNullOrEmpty(animName)) { Animator.CrossFade(animName, transitionDuration); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerController.cs]
using System; using Unity.Netcode; using UnityEditor.PackageManager; using UnityEngine; using UnityEngine.Rendering; public class PlayerController : NetworkBehaviour { public enum MotionState : byte { Idle = 0, Moving = 1, Attack = 2 } private readonly NetworkVariable<MotionState> _motionState = new NetworkVariable<MotionState>( MotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public MotionState Motion => _motionState.Value; [Header("Settings")] [SerializeField] private float moveSpeed = 5f; [SerializeField] private float rotateSpeed = 10f; [SerializeField] private float attackDistance = 20f; [SerializeField] private LayerMask groundLayer; [SerializeField] private LayerMask interactLayer; private IPlayerState currentState; private Vector3 _serverTargetPosition; public Camera MainCamera { get; private set; } public Rigidbody Rigidbody { get; private set; } public CapsuleCollider CapsuleCollider { get; private set; } public float MoveSpeed => moveSpeed; public float RotationSpeed => rotateSpeed; public Vector3 ServerTargetPosition => _serverTargetPosition; private PlayerNetworkHealth _healthComponent; public LayerMask GroundLayer => groundLayer; public LayerMask InteractLayer => interactLayer; private void Awake() { MainCamera = Camera.main; Rigidbody = GetComponent<Rigidbody>(); CapsuleCollider = GetComponent<CapsuleCollider>(); _healthComponent = GetComponent<PlayerNetworkHealth>(); } public override void OnNetworkSpawn() { if (IsServer) { _serverTargetPosition = transform.position; _motionState.Value = MotionState.Idle; _healthComponent.OnHealthChanged += CheckDeath; } if (IsOwner) { BindLocalPlayerUI(); _motionState.OnValueChanged += OnMotionStateChanged; AppyMotionState(_motionState.Value); } } private void OnMotionStateChanged(MotionState oldState, MotionState newState) { AppyMotionState(newState); } private void AppyMotionState(MotionState state) { if (!IsOwner) return; switch (state) { case MotionState.Idle: if (currentState is PlayerStateIdle) return; break; case MotionState.Moving: if (currentState is PlayerStateMove) return; break; } } public override void OnNetworkDespawn() { if (IsOwner && HealthBarUI.Instance != null) { _healthComponent.OnHealthChanged -= HealthBarUI.Instance.UpdateViewHealth; _motionState.OnValueChanged -= OnMotionStateChanged; } if (IsServer) { _healthComponent.OnHealthChanged -= CheckDeath; } } void Update() { if (IsOwner) { currentState?.Update(); } if (IsServer) { ProcessMovement(); } } public void ChangeState(IPlayerState nextState) { if (currentState != null) currentState.Exit(); currentState = nextState; currentState.Enter(); } private void BindLocalPlayerUI() { var ui = HealthBarUI.Instance; if (ui == null) { Debug.LogError("Scene creates Player but HealthBarUI is missing!"); return; } _healthComponent.OnHealthChanged += ui.UpdateViewHealth; ui.UpdateViewHealth(_healthComponent.MaxHealth, _healthComponent.MaxHealth); } #region StateRequest methods public void RequestMove(Vector3 position) { if (IsOwner) { RequestMoveServerRpc(position); } } public void RequestStop() { if (IsOwner) { RequestStopServerRpc(); } } [ServerRpc] private void RequestMoveServerRpc(Vector3 pos) { _serverTargetPosition = new Vector3(pos.x, transform.position.y, pos.z); _motionState.Value = MotionState.Moving; } [ServerRpc] private void RequestStopServerRpc() { ServerStopMove(); } #endregion #region movement methods private void ProcessMovement() { if (_motionState.Value != MotionState.Moving) return; float step = moveSpeed * Time.deltaTime; transform.position = Vector3.MoveTowards(transform.position, _serverTargetPosition, step); Vector3 direction = _serverTargetPosition - transform.position; if (direction != Vector3.zero) { Quaternion targetRot = Quaternion.LookRotation(direction); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime); } if (Vector3.Distance(transform.position, _serverTargetPosition) < 0.01f) { ServerStopMove(); } } private void ServerStopMove() { if (_motionState.Value == MotionState.Idle) return; _motionState.Value = MotionState.Idle; } #endregion #region death private void CheckDeath(int currentHealth, int maxHealth) { if (currentHealth <= 0 && !(currentState is PlayerStateDie)) { BroadcastDeathClientRpc(); } } [ClientRpc] private void BroadcastDeathClientRpc() { } #endregion private void OnCollisionEnter(Collision collision) { if (!IsServer) return; if(collision != null && collision.gameObject.CompareTag("Player")) { ServerStopMove(); } } public void CheckInteract(RaycastHit hit) { switch (hit.collider.gameObject.tag) { case "Player": Debug.Log("点击到了玩家"); break; default: Debug.Log("点击到了无法交互的物体"); break; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerInputManager.cs]
using Unity.Netcode; using UnityEngine; [RequireComponent(typeof(PlayerNetworkCore))] public class PlayerInputManager : NetworkBehaviour { [Header("Raycast Layers")] [SerializeField] private LayerMask groundLayer; [SerializeField] private LayerMask interactLayer; [Header("Raycast")] [SerializeField] private float rayMaxDistance = 1000f; private Camera _mainCamera; private PlayerNetworkCore _core; private PlayerNetworkMovement _movement; private PlayerNetworkCombat _combat; private void Awake() { _core = GetComponent<PlayerNetworkCore>(); _movement = GetComponent<PlayerNetworkMovement>(); _combat = GetComponent<PlayerNetworkCombat>(); } public override void OnNetworkSpawn() { if (!IsOwner) { enabled = false; return; } _mainCamera = Camera.main; if( _core != null ) { _core.LifeVar.OnValueChanged += OnLifeChanged; } } public override void OnNetworkDespawn() { if (IsOwner && _core != null) _core.LifeVar.OnValueChanged -= OnLifeChanged; } private void OnLifeChanged(PlayerNetworkStates.LifeState oldState, PlayerNetworkStates.LifeState newState) { if (newState == PlayerNetworkStates.LifeState.Dead) enabled = false; } private void Update() { if (!IsOwner) return; if (_movement == null) return; if (Input.GetKeyDown(KeyCode.S)) { _movement.RequestStop(); return; } if (Input.GetKeyDown(KeyCode.A)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position + transform.forward; _combat.RequestCastSkill(0, aimPos); return; } if (Input.GetKeyDown(KeyCode.Q)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(1, aimPos); return; } if (Input.GetKeyDown(KeyCode.W)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(2, aimPos); return; } if (Input.GetKeyDown(KeyCode.E)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(3, aimPos); return; } if (Input.GetMouseButtonDown(1)) { if (_mainCamera == null) _mainCamera = Camera.main; if (_mainCamera == null) return; Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out RaycastHit interactHit, rayMaxDistance, interactLayer)) { if(interactHit.collider.TryGetComponent<IInteractable>(out var interact)) { Debug.Log("����������㣬��ȡ�����ӿ�"); interact.Interact(gameObject); } return; } if(Physics.Raycast(ray, out RaycastHit groundHit, rayMaxDistance, groundLayer)) { _movement.RequestMove(groundHit.point); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerNetworkCore.cs]
using NUnit.Framework; using System; using System.Collections.Generic; using Unity.Collections; using TMPro.EditorUtilities; using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkCore : NetworkBehaviour { [Header("Server LifeCycle")] [SerializeField] private float deathDespawnDelay = 3f; private readonly NetworkVariable<PlayerNetworkStates.LifeState> _lifeState = new NetworkVariable<PlayerNetworkStates.LifeState>( PlayerNetworkStates.LifeState.Alive, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server); public PlayerNetworkStates.LifeState Life => _lifeState.Value; public NetworkVariable<PlayerNetworkStates.LifeState> LifeVar => _lifeState; private readonly NetworkVariable<PlayerNetworkStates.MotionState> _motionState = new NetworkVariable<PlayerNetworkStates.MotionState>( PlayerNetworkStates.MotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server); public PlayerNetworkStates.MotionState Motion => _motionState.Value; public NetworkVariable<PlayerNetworkStates.MotionState> MotionVar => _motionState; public bool IsDead => _lifeState.Value == PlayerNetworkStates.LifeState.Dead; private readonly NetworkVariable<int> _points = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<int> PointVar => _points; private NetworkList<FixedString32Bytes> _items = new NetworkList<FixedString32Bytes>( new List<FixedString32Bytes>(), NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkList<FixedString32Bytes> ItemsVar => _items; #region public events public event Action<PlayerNetworkCore> OnPlayerDied; #endregion private PlayerNetworkHealth _health; private PlayerNetworkMovement _movement; private PlayerNetworkCombat _combat; private bool _deathTimerRunning; private float _deathTimer; private void Awake() { _health = GetComponent<PlayerNetworkHealth>(); _movement = GetComponent<PlayerNetworkMovement>(); _combat = GetComponent<PlayerNetworkCombat>(); } public override void OnNetworkSpawn() { if (!IsServer) return; _lifeState.Value = PlayerNetworkStates.LifeState.Alive; _deathTimerRunning = false; _deathTimer = 0f; if (_health != null) { _health.OnDiedServer += OnDiedServer; } if (GameLifecycleManager.Instance != null) { } else { var manager = FindFirstObjectByType<GameLifecycleManager>(); } _movement?.ServerReset(); } public override void OnNetworkDespawn() { if (!IsServer) return; if (_health != null) { _health.OnDiedServer -= OnDiedServer; } if (GameLifecycleManager.Instance != null) { } var gameManager = GameLifecycleManager.Instance; } private void Update() { if (!IsServer) return; if (!IsDead) return; ProcessDeathDespawn(); } private void OnDiedServer() { if (!IsServer) return; if (IsDead) return; _lifeState.Value = PlayerNetworkStates.LifeState.Dead; OnPlayerDied?.Invoke(this); _deathTimerRunning = true; _deathTimer = 0f; } private void ProcessDeathDespawn() { if (!_deathTimerRunning) return; _deathTimer += Time.deltaTime; if (_deathTimer < deathDespawnDelay) return; var nob = GetComponent<NetworkObject>(); if (nob != null && nob.IsSpawned) { nob.Despawn(); } _deathTimerRunning = false; } public void ApplyDamageServer(int amount, ulong attackerId) { if (!IsServer) return; if (IsDead) return; if (_health == null) return; _health.ServerTakeDamage(amount, attackerId); } public void SetMotionServer(PlayerNetworkStates.MotionState newState) { if (!IsServer) return; if(_motionState.Value == newState) return; _motionState.Value = newState; } public void AddPointsServer(int amount) { if (!IsServer) return; _points.Value += amount; } public void AddItem(string name) { _items.Add(name); string allItems = ""; foreach(var item in _items) { allItems += item; } Debug.Log(allItems); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerNetworkHealth.cs]
using System; using Unity.Netcode; using UnityEngine; public class PlayerNetworkHealth : NetworkBehaviour, IDamageable { [Header("����")] [SerializeField] private int _maxHealth = 100; [Header("Feedback Settings")] [SerializeField] private float knockbackForce = 15f; private readonly NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public int CurrentHealth => _currentHealth.Value; public NetworkVariable<int> CurrentHealthVar => _currentHealth; public int MaxHealth => _maxHealth; public bool IsDead => _currentHealth.Value < 0; private PlayerNetworkMovement _movement; private DamageFlash _damageFlash; public event Action<int, int> OnHealthChanged; public event Action<int, ulong> OnDamaged; public event Action<ulong> OnDied; public event Action OnDiedServer; private void Awake() { _movement = GetComponent<PlayerNetworkMovement>(); _damageFlash = GetComponent<DamageFlash>(); } public override void OnNetworkSpawn() { _currentHealth.OnValueChanged += HandleHealthChanged; if (IsServer) { _currentHealth.Value = _maxHealth; } _currentHealth.Value = _maxHealth; OnHealthChanged?.Invoke(_currentHealth.Value, _maxHealth); } public override void OnNetworkDespawn() { _currentHealth.OnValueChanged -= HandleHealthChanged; OnHealthChanged = null; OnDamaged = null; OnDied = null; OnDiedServer = null; } private void HandleHealthChanged(int prev, int curr) { OnHealthChanged?.Invoke(curr, _maxHealth); } public void RequestTakeDamage(int damage, ulong attackerCliendId = 0) { ServerTakeDamage(damage, attackerCliendId); } public void ServerTakeDamage(int damage, ulong attackerClientId = 0) { if (!IsServer) return; if (damage < 0) return; if (IsDead) return; int prev = _currentHealth.Value; int next = Mathf.Clamp(prev - damage, 0, MaxHealth); if (next != prev) { _currentHealth.Value = next; } DamagedClientRpc(damage, attackerClientId); if (next <= 0) { DiedClientRpc(attackerClientId); OnDiedServer?.Invoke(); } } public void ServerHeal(int amount) { if (!IsServer) return; if(amount <= 0) return; if (IsDead) return; int prev = _currentHealth.Value; int next = Mathf.Clamp(prev + amount, 0, MaxHealth); if(next == prev) return; _currentHealth.Value = next; } [ClientRpc] private void DamagedClientRpc(int damage, ulong attackerClientId) { OnDamaged?.Invoke(damage, attackerClientId); if (DamageTextManager.Instance != null) { Vector3 randomOffset = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 1.5f, 0); DamageTextManager.Instance.ShowDamage(damage, transform.position + randomOffset); } if (_damageFlash != null) { _damageFlash.TriggerFlash(); } if (HitStopManager.Instance != null) { HitStopManager.Instance.TriggerHitStop(0.05f, 0.0f); } } [ClientRpc] private void DiedClientRpc(ulong attackerCliendId) { OnDied?.Invoke(attackerCliendId); } [ClientRpc] private void ShowDamagePopupClientRpc(int amount, Vector3 targetPos) { if(DamageTextManager.Instance != null) { Vector3 randomOffset = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 1.5f, 0); DamageTextManager.Instance.ShowDamage(amount, targetPos + randomOffset); } } public void TakeDamage(int amount, ulong attackerId) { RequestTakeDamage(amount, attackerId); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerNetworkStates.cs]
using UnityEngine; public class PlayerNetworkStates { public enum MotionState : byte { Idle = 0, Moving = 1, Skill = 2, } public enum LifeState : byte { Alive = 0, Dead = 1 } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerPresentation.cs]
using Unity.Netcode; using UnityEngine; [RequireComponent(typeof(PlayerNetworkCore))] public class PlayerPresentation : NetworkBehaviour { private PlayerNetworkCore _core; private PlayerNetworkCombat _combat; private PlayerNetworkHealth _health; private IPlayerState _currentState; private string _skillAnimationName; public string SkillAnimationName => _skillAnimationName; public Rigidbody Rigidbody { get; private set; } public CapsuleCollider CapsuleCollider { get; private set; } public Animator Animator { get; private set; } private void Awake() { _core = GetComponent<PlayerNetworkCore>(); _combat = GetComponent<PlayerNetworkCombat>(); _health = GetComponent<PlayerNetworkHealth>(); Rigidbody = GetComponent<Rigidbody>(); CapsuleCollider = GetComponent<CapsuleCollider>(); Animator = GetComponent<Animator>(); } public override void OnNetworkSpawn() { if (_core != null) { _core.LifeVar.OnValueChanged += OnLifeChanged; _core.MotionVar.OnValueChanged += OnMotionChanged; } if (_combat != null) { } RefreshStateFromNet(); if (_health != null) { _health.OnDamaged += OnDamagedLocal; } if (IsOwner) { if (GameHUDView.Instance != null) { } if (GameCameraManager.Instance != null) { GameCameraManager.Instance.SetFollowTarget(transform); } else { } } } public override void OnNetworkDespawn() { if (_core != null) { _core.LifeVar.OnValueChanged -= OnLifeChanged; _core.MotionVar.OnValueChanged -= OnMotionChanged; } if (_combat != null) { _combat.OnSkillIndexChanged -= OnSkillIndexChanged; } if (IsOwner && _health != null && HealthBarUI.Instance != null) { _health.OnHealthChanged -= HealthBarUI.Instance.UpdateViewHealth; _health.OnDamaged -= OnDamagedLocal; } } private void OnSkillIndexChanged(int newIndex) { if (_core.Motion == PlayerNetworkStates.MotionState.Skill && newIndex != -1) { RefreshStateFromNet(); } } private void OnDamagedLocal(int damage, ulong attackerId) { if (IsOwner) { } } private void Update() { _currentState?.Update(); } private void OnMotionChanged(PlayerNetworkStates.MotionState oldState, PlayerNetworkStates.MotionState newState) { RefreshStateFromNet(); } private void OnLifeChanged(PlayerNetworkStates.LifeState oldState, PlayerNetworkStates.LifeState newState) { RefreshStateFromNet(); } private void RefreshStateFromNet() { if (_core == null) return; if (_core.Life == PlayerNetworkStates.LifeState.Dead) { if (_currentState is PlayerStateDie) return; ChangeState(new PlayerStateDie(this)); return; } switch (_core.Motion) { case PlayerNetworkStates.MotionState.Moving: if (_currentState is PlayerStateMove) return; ChangeState(new PlayerStateMove(this)); break; case PlayerNetworkStates.MotionState.Idle: if (_currentState is PlayerStateIdle) return; ChangeState(new PlayerStateIdle(this)); break; case PlayerNetworkStates.MotionState.Skill: ChangeState(new PlayerStateSkill(this)); break; default: ChangeState(new PlayerStateIdle(this)); break; } } public void ChangeState(IPlayerState nextState) { _currentState?.Exit(); _currentState = nextState; _currentState.Enter(); } private void BindLocalPlayerUI() { var ui = HealthBarUI.Instance; if (ui == null) { Debug.LogError("����������ҵ���û�� Ѫ����"); return; } if (_health == null) { Debug.LogError("���û��Ѫ�����"); return; } _health.OnHealthChanged += ui.UpdateViewHealth; ui.UpdateViewHealth(_health.MaxHealth, _health.MaxHealth); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\DamageText.cs]
using System.Collections; using TMPro; using UnityEngine; using UnityEngine.Pool; public class DamageText : MonoBehaviour { [SerializeField] private TMP_Text damageLable; private IObjectPool<DamageText> _pool; public void SetupPool(IObjectPool<DamageText> pool) { _pool = pool; } public void Setup(int damageAmount) { damageLable.text = damageAmount.ToString(); StartCoroutine(ReturnToPoolAfterTime(3.0f)); } private IEnumerator ReturnToPoolAfterTime(float time) { yield return new WaitForSeconds(time); if(_pool != null) { _pool.Release(this); } else { Destroy(gameObject); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\DamageTextManager.cs]
using System.Net.NetworkInformation; using UnityEngine; using UnityEngine.Pool; public class DamageTextManager : MonoBehaviour { public static DamageTextManager Instance { get; private set; } [Header("����")] [SerializeField] private DamageText textPrefab; [SerializeField] private Canvas gameCanvas; private ObjectPool<DamageText> _pool; private Camera _camera; private void Awake() { Instance = this; _camera = Camera.main; _pool = new ObjectPool<DamageText>( createFunc: CreateText, actionOnGet: OnGetText, actionOnRelease: OnReleaseText, actionOnDestroy: OnDestroyText, defaultCapacity:20, maxSize:100 ); } private DamageText CreateText() { var instance = Instantiate(textPrefab, transform); instance.SetupPool(_pool); return instance; } private void OnGetText(DamageText text) { text.gameObject.SetActive(true); text.transform.localScale = Vector3.one; } private void OnReleaseText(DamageText text) { text.gameObject.SetActive(false); } private void OnDestroyText(DamageText text) { Destroy(text.gameObject); } public void ShowDamage(int amount, Vector3 worldPos) { if (textPrefab == null) return; var instance = _pool.Get(); Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPos); instance.transform.position = screenPos; instance.Setup(amount); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\HealthBarUI.cs]
using UnityEngine; using UnityEngine.UI; public class HealthBarUI : MonoBehaviour { public static HealthBarUI Instance { get; private set; } [SerializeField] private Slider healthSlider; [SerializeField] private Image QSkill; private void Awake() { Instance = this; } public void UpdateViewHealth(int current, int max) { if (healthSlider == null) return; healthSlider.value = (float)current / max; } public void UpdateViewQskill(bool activeBefore, bool activeCurrent) { if(QSkill == null) return; QSkill.color = activeCurrent ? Color.yellow : Color.red; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\InteractableTest.cs]
using Unity.Netcode; using UnityEngine; public class InteractableTest : NetworkBehaviour { private NetworkVariable<float> _health = new NetworkVariable<float>( 100f, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public override void OnNetworkSpawn() { _health.OnValueChanged += OnHealthChanged; } public override void OnNetworkDespawn() { _health.OnValueChanged -= OnHealthChanged; } private void OnHealthChanged(float prev, float cur) { if (!IsServer) return; if(cur <= 0f) { NetworkObject.Despawn(); } } [ServerRpc] public void ServerTakeDamageServerRpc(float damage) { if(!IsServer) return; _health.Value -= damage; Debug.Log("ľ׮�ܵ��˺�"); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\ChargeGrowingVisual.cs]
using UnityEngine; using System.Collections; public class ChargeGrowingVisual : MonoBehaviour { [Header("�Ӿ�����")] [Tooltip("�������յ�Ŀ���С (Local Scale)")] [SerializeField] private float _targetScale = 20.0f; [Tooltip("�������ߣ��ñ����̸���Ȼ")] [SerializeField] private AnimationCurve _growthCurve = AnimationCurve.Linear(0, 0, 1, 1); public void SetDuration(float duration) { transform.localScale = Vector3.zero; StartCoroutine(GrowthRoutine(duration)); } private IEnumerator GrowthRoutine(float duration) { float timer = 0f; while (timer < duration) { timer += Time.deltaTime; float progress = Mathf.Clamp01(timer / duration); float curveValue = _growthCurve.Evaluate(progress); transform.localScale = Vector3.one * (_targetScale * curveValue); yield return null; } transform.localScale = Vector3.one * _targetScale; Destroy(gameObject); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\DamageAuraController.cs]
using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; [RequireComponent(typeof(NetworkObject))] public class DamageAuraController : NetworkBehaviour { private NetworkObject _owner; private int _damage; private float _radius; private float _interval; private float _duration; private float _timerDuration = 0f; private float _timerInterval = 0f; private bool _isInitialized = false; private Dictionary<ulong, float> _hitHistory = new Dictionary<ulong, float>(); public void Initialize(NetworkObject owner, int damage, float radius, float interval, float duration) { _owner = owner; _damage = damage; _radius = radius; _interval = interval; _duration = duration; _isInitialized = true; } private void Update() { if (!IsServer || !_isInitialized) return; if (_owner != null && _owner.IsSpawned) { transform.position = _owner.transform.position; } else { DespawnAura(); return; } _timerDuration += Time.deltaTime; if (_timerDuration >= _duration) { DespawnAura(); return; } _timerInterval += Time.deltaTime; if (_timerInterval >= _interval) { _timerInterval = 0f; DealDamage(); } } private void DealDamage() { Collider[] hits = Physics.OverlapSphere(transform.position, _radius); foreach (var hit in hits) { if (hit.gameObject == _owner.gameObject) continue; if (hit.gameObject == gameObject) continue; if (hit.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage(_damage, _owner.NetworkObjectId); } } } private void DespawnAura() { if (NetworkObject.IsSpawned) { NetworkObject.Despawn(); } } private void OnDrawGizmosSelected() { Gizmos.color = new Color(1, 0, 0, 0.3f); Gizmos.DrawSphere(transform.position, _radius > 0 ? _radius : 3f); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\LaserVisual.cs]
using UnityEngine; using Unity.Netcode; [RequireComponent(typeof(LineRenderer))] public class LaserVisual : NetworkBehaviour { private LineRenderer _line; private float _growthDuration; private float _startLen; private float _maxLen; private bool _isGrowing = false; private float _timer = 0f; private void Awake() { _line = GetComponent<LineRenderer>(); _line.useWorldSpace = false; } [ClientRpc] public void InitializeLaserClientRpc(float startLen, float maxLen, float growthDuration, float width) { _startLen = startLen; _maxLen = maxLen; _growthDuration = growthDuration; _line.startWidth = width; _line.endWidth = width; _line.SetPosition(0, Vector3.zero); _line.SetPosition(1, Vector3.forward * startLen); _timer = 0f; _isGrowing = true; } private void Update() { if (!_isGrowing) return; _timer += Time.deltaTime; float progress = Mathf.Clamp01(_timer / _growthDuration); float currentLen = Mathf.Lerp(_startLen, _maxLen, progress); _line.SetPosition(1, Vector3.forward * currentLen); if (progress >= 1.0f) { _isGrowing = false; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\NukeZoneVisual.cs]
using Unity.Netcode; using UnityEngine; using System.Collections; public class NukeZoneVisual : NetworkBehaviour { private float _targetScale; private float _duration; private bool _isRunning = false; private float _timer = 0f; [ClientRpc] public void StartExpansionClientRpc(float targetRadius, float duration) { _targetScale = targetRadius * 2.0f; _duration = duration; _timer = 0f; _isRunning = true; transform.localScale = Vector3.zero; } private void Update() { if (!_isRunning) return; _timer += Time.deltaTime; float progress = _timer / _duration; if (progress >= 1.0f) { transform.localScale = Vector3.one * _targetScale; _isRunning = false; } else { transform.localScale = Vector3.Lerp(Vector3.zero, Vector3.one * _targetScale, progress); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\ProjectileController.cs]
using System; using Unity.Netcode; using UnityEngine; public class ProjectileController : NetworkBehaviour { private float _speed; private float _maxDistance; private int _damage; private float _radius; private ulong _attackerId; private GameObject _caster; private Vector3 _startPos; private Vector3 _direction; private float _traveledDistance; private bool _isInitialized = false; public void Initialize(Vector3 direction, float speed, float maxDistance, int damage, float radius, ulong attackerId, GameObject caster) { _direction = direction; _speed = speed; _maxDistance = maxDistance; _damage = damage; _radius = radius; _attackerId = attackerId; _caster = caster; _startPos = transform.position; _traveledDistance = 0f; _isInitialized = true; } private void Update() { if (!IsServer || !_isInitialized) return; ProcessMovement(); } private void ProcessMovement() { float step = _speed * Time.deltaTime; transform.position += _direction * step; _traveledDistance += step; if (_traveledDistance >= _maxDistance) { DespawnObject(); return; } if (Physics.CheckSphere(transform.position, _radius, LayerMask.GetMask("Player", "Enemy"))) { Collider[] hits = Physics.OverlapSphere(transform.position, _radius); bool hitValidTarget = false; foreach (var hit in hits) { if (hit.gameObject == _caster) continue; if (hit.gameObject == gameObject) continue; if (hit.TryGetComponent<IDamageable>(out var damageCmp)) { damageCmp.TakeDamage(_damage, _attackerId); Debug.Log($"[Projectile] Hit {hit.name}, caused {_damage}"); hitValidTarget = true; } } if (hitValidTarget) { DespawnObject(); } } } private void DespawnObject() { if (!IsServer) return; if (NetworkObjectPool.Instance != null) { NetworkObjectPool.Instance.ReturnNetworkObject(NetworkObject); } else { if (NetworkObject != null && NetworkObject.IsSpawned) { NetworkObject.Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillIndicator.cs]
using UnityEngine; using UnityEngine.UI; using System.Collections; public class SkillIndicator : MonoBehaviour { [Header("UI �������")] [SerializeField] private Image _fillImage; public void Initialize(float duration, float diameter) { transform.localScale = Vector3.one * diameter; StartCoroutine(PlayFillAnimationRoutine(duration)); } private IEnumerator PlayFillAnimationRoutine(float duration) { float timer = 0f; _fillImage.fillAmount = 0f; while (timer < duration) { timer += Time.deltaTime; _fillImage.fillAmount = timer / duration; yield return null; } _fillImage.fillAmount = 1f; yield return new WaitForSeconds(0.1f); Destroy(gameObject); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\BufferedHealthBar.cs]
using UnityEngine; using UnityEngine.UI; public class BufferedHealthBar : MonoBehaviour { [Header("UI References")] [SerializeField] private Slider _mainSlider; [SerializeField] private Slider _bufferSlider; [SerializeField] private CanvasGroup _canvasGroup; [Header("Settings")] [SerializeField] private float _bufferDropSpeed = 0.5f; [SerializeField] private float _bufferDelay = 0.5f; private float _delayTimer; private void Awake() { if (_mainSlider == null) _mainSlider = GetComponent<Slider>(); if (_canvasGroup == null) _canvasGroup = GetComponent<CanvasGroup>(); } public void UpdateHealth(int current, int max) { if (current <= 0) { SetVisible(false); return; } SetVisible(true); float fillAmount = (float)current / max; _mainSlider.value = fillAmount; if (_bufferSlider != null) { if (_mainSlider.value > _bufferSlider.value) { _bufferSlider.value = _mainSlider.value; } else { _delayTimer = _bufferDelay; } } } public void ForceReset(int max) { SetVisible(true); _mainSlider.value = 1.0f; if (_bufferSlider != null) _bufferSlider.value = 1.0f; _delayTimer = 0f; } private void Update() { if (_bufferSlider == null) return; if (_bufferSlider.value > _mainSlider.value) { if (_delayTimer > 0) { _delayTimer -= Time.deltaTime; return; } _bufferSlider.value -= _bufferDropSpeed * Time.deltaTime; } } private void SetVisible(bool isVisible) { if (_canvasGroup != null) { _canvasGroup.alpha = isVisible ? 1 : 0; } else { foreach (Transform child in transform) child.gameObject.SetActive(isVisible); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\GameHUDView.cs]
using UnityEngine; using UnityEngine.UI; using TMPro; using System.Collections.Generic; using Unity.Collections; using Unity.Netcode; public class GameHUDView : MonoBehaviour { public Slider HealthSlider; public Image QSkill; public Image WSkill; public Image ESkill; public TMP_Text points; public Sprite itemIcon; public Image item1; public Image item2; public Image item3; private PlayerNetworkCombat _pnCombat; private PlayerDataContainer _playerData; public static GameHUDView Instance { get; private set; } private void Awake() { Instance = this; } public void BindToLocalPlayer(PlayerDataContainer container, PlayerNetworkCombat combat) { _playerData = container; _pnCombat = combat; BindView(); } public void BindView() { _playerData.CurrentHealthVar.OnValueChanged += UpdateHealthSlider; _pnCombat.QSkillActiveVar.OnValueChanged += UpdateQSkill; _pnCombat.WSkillActiveVar.OnValueChanged += UpdateWSkill; _pnCombat.ESkillActiveVar.OnValueChanged += UpdateESkill; _playerData.PointVar.OnValueChanged += UpdatePoints; _playerData.ItemsVar.OnListChanged += UpdateItems; UpdateHealthSlider(_playerData.MaxHealth, _playerData.MaxHealth); UpdateQSkill(true, _pnCombat.QSkillActiveVar.Value); UpdateWSkill(true, _pnCombat.WSkillActiveVar.Value); UpdateESkill(true, _pnCombat.ESkillActiveVar.Value); } public void UpdateHealthSlider(int preHealth, int currentHealth) { if (HealthSlider == null) return; HealthSlider.value = (float)currentHealth / (float)_playerData.MaxHealth; } public void UpdateQSkill(bool ignore, bool active) { QSkill.color = active ? Color.white : Color.gray; } public void UpdateWSkill(bool ignore, bool active) { WSkill.color = active ? Color.white : Color.gray; } public void UpdateESkill(bool ignore, bool active) { ESkill.color = active ? Color.white : Color.gray; } public void UpdatePoints(int pre, int current) { points.text = current.ToString(); } public void UpdateItems(NetworkListEvent<FixedString32Bytes> changeEvent) { int count = _playerData.ItemsVar.Count; if (count >= 1) { item1.sprite = itemIcon; item1.color = Color.white; } else { item1.sprite = null; item1.color = Color.clear; } if (count >= 2) { item2.sprite = itemIcon; item2.color = Color.white; } else { item2.sprite = null; item2.color = Color.clear; } if (count >= 3) { item3.sprite = itemIcon; item3.color = Color.white; } else { item3.sprite = null; item3.color = Color.clear; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\UIBillboard.cs]
using UnityEngine; public class UIBillboard : MonoBehaviour { private Camera _mainCamera; private void Start() { _mainCamera = Camera.main; } private void LateUpdate() { if (_mainCamera == null) _mainCamera = Camera.main; if (_mainCamera == null) return; transform.LookAt(transform.position + _mainCamera.transform.rotation * Vector3.forward, _mainCamera.transform.rotation * Vector3.up); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\UIManager.cs]
using UnityEngine; using Unity.Netcode; public class UIManager : MonoBehaviour { public static UIManager Instance { get; private set; } [SerializeField] private GameHUDView hudView; private void Awake() { Instance = this; } public void OnLocalPlayerSpawned(PlayerNetworkHealth health, PlayerNetworkCombat combat) { } public void OnLocalPlayerDespawned() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\UnitHealthBinder.cs]
using Unity.Netcode; using UnityEngine; public class UnitHealthBinder : MonoBehaviour { [Header("UI Reference")] [SerializeField] private BufferedHealthBar _healthBar; [Header("Unit References")] [SerializeField] private BossController _bossController; [SerializeField] private EnemyController _enemyController; private void Awake() { if (_bossController == null) _bossController = GetComponentInParent<BossController>(); if (_enemyController == null) _enemyController = GetComponentInParent<EnemyController>(); } private void OnEnable() { if (_healthBar != null) { _healthBar.ForceReset(100); } BindEvents(); } private void OnDisable() { UnbindEvents(); } private void BindEvents() { if (_bossController != null) { _bossController.OnHealthChanged += HandleHealthChanged; HandleHealthChanged(_bossController.CurrentHealth, _bossController.MaxHealth); } if (_enemyController != null) { _enemyController.OnHealthChanged += HandleHealthChanged; HandleHealthChanged(_enemyController.CurrentHealth, _enemyController.MaxHealth); } } private void UnbindEvents() { if (_bossController != null) _bossController.OnHealthChanged -= HandleHealthChanged; if (_enemyController != null) _enemyController.OnHealthChanged -= HandleHealthChanged; } private void HandleHealthChanged(int current, int max) { if (_healthBar != null) { _healthBar.UpdateHealth(current, max); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Utils\SubclassSelectorAttribute.cs]
using UnityEngine; public class SubclassSelectorAttribute : PropertyAttribute { }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossBaseState.cs]
using UnityEngine; public abstract class BossBaseState { protected BossController _controller; protected BossStateMachine _stateMachine; public BossBaseState(BossController controller, BossStateMachine stateMachine) { _controller = controller; _stateMachine = stateMachine; } public virtual void OnEnter() { } public virtual void OnUpdate() { } public virtual void OnExit() { } protected void PlayAnimation(string animName, float fadeTime = 0.1f) { if (_controller.Animator != null && !string.IsNullOrEmpty(animName)) { _controller.Animator.Play(animName); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossController.cs]
using System; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using UnityEngine.AI; using Random = UnityEngine.Random; [RequireComponent(typeof(NetworkObject))] [RequireComponent(typeof(Animator))] [RequireComponent(typeof(NavMeshAgent))] public class BossController : NetworkBehaviour, IDamageable { public enum BossMotionState { Idle = 0, Chase = 1, Charge = 2, Skill = 3, Recovery = 4, Die = 5, } [Header("References")] [SerializeField] private SkillDataSO[] _skills; [Header("Settings")] [SerializeField] private int _maxHealth = 100; [SerializeField] public float ChaseRange = 50f; [SerializeField] public float BasicAttackRange = 3.5f; [SerializeField] public LayerMask ChaseLayer; [SerializeField] private float _specialSkillInterval = 15f; public NavMeshAgent Agent { get; private set; } public Animator Animator { get; private set; } public BossPresentation View => GetComponent<BossPresentation>(); public NetworkObject Target { get; private set; } public SkillDataSO[] Skills => _skills; private float[] _skillCDs; private float _specialSkillTimer = 0f; private bool _hasTriggered50Ult = false; private bool _hasTriggered10Ult = false; private NetworkVariable<BossMotionState> _currentBossState = new NetworkVariable<BossMotionState>( BossMotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 100, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public int MaxHealth => _maxHealth; public int CurrentHealth => _currentHealth.Value; public BossMotionState MotionState => _currentBossState.Value; public event Action OnBossDied; public event Action<int, int> OnHealthChanged; private BossStateMachine _stateMachine; public BossStateMachine StateMachine => _stateMachine; private void Awake() { Agent = GetComponent<NavMeshAgent>(); Animator = GetComponent<Animator>(); _stateMachine = new BossStateMachine(this); } public override void OnNetworkSpawn() { if (IsServer) { _currentHealth.Value = _maxHealth; _currentBossState.Value = BossMotionState.Idle; Agent.enabled = true; Target = null; if (_skills != null) _skillCDs = new float[_skills.Length]; foreach (var skill in _skills) skill.SetDurations(); } else { Agent.enabled = false; } _currentBossState.OnValueChanged += OnStateNetworkValueChanged; SyncStateFromNetwork(_currentBossState.Value); _currentHealth.OnValueChanged += OnHealthNetworkChanged; OnHealthChanged?.Invoke(_currentHealth.Value, _maxHealth); } public override void OnNetworkDespawn() { _currentBossState.OnValueChanged -= OnStateNetworkValueChanged; _currentHealth.OnValueChanged -= OnHealthNetworkChanged; } private void Update() { if (IsServer) { UpdateTimers(); } _stateMachine.Update(); } private void UpdateTimers() { if (_currentBossState.Value == BossMotionState.Die) return; if (_skillCDs != null) { for (int i = 0; i < _skillCDs.Length; i++) if (_skillCDs[i] > 0) _skillCDs[i] -= Time.deltaTime; } if (Target != null) _specialSkillTimer += Time.deltaTime; } #region State Sync private void OnStateNetworkValueChanged(BossMotionState oldState, BossMotionState newState) { SyncStateFromNetwork(newState); } private void SyncStateFromNetwork(BossMotionState state) { switch (state) { case BossMotionState.Idle: _stateMachine.ChangeState(_stateMachine.StateIdle); break; case BossMotionState.Chase: _stateMachine.ChangeState(_stateMachine.StateMove); break; case BossMotionState.Charge: _stateMachine.ChangeState(_stateMachine.StateCharge); break; case BossMotionState.Skill: _stateMachine.ChangeState(_stateMachine.StateSkill); break; case BossMotionState.Recovery: _stateMachine.ChangeState(_stateMachine.StateRecovery); break; case BossMotionState.Die: _stateMachine.ChangeState(_stateMachine.StateDie); break; } } public void SetState(BossMotionState newState) { if (!IsServer) return; if (_currentBossState.Value != newState) { _currentBossState.Value = newState; } } #endregion #region Logic public void SetTarget(NetworkObject target) { Target = target; } public void RotateTowardsTarget() { if (Target == null) return; Vector3 dir = (Target.transform.position - transform.position).normalized; dir.y = 0; if (dir != Vector3.zero) transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(dir), 10f * Time.deltaTime); } public bool TrySelectAndStartAttack() { int skillIndex = SelectSkillToCast(); if (skillIndex != -1) { _stateMachine.PendingSkillIndex = skillIndex; if (_skills != null && skillIndex < _skills.Length) _skillCDs[skillIndex] = _skills[skillIndex].coolDown; SetState(BossMotionState.Charge); return true; } return false; } private int SelectSkillToCast() { float hpPercent = (float)_currentHealth.Value / _maxHealth; int ultIndex = 3; if (_skills.Length > ultIndex) { if (hpPercent <= 0.1f && !_hasTriggered10Ult) { _hasTriggered10Ult = true; _skillCDs[ultIndex] = 0; return ultIndex; } if (hpPercent <= 0.5f && !_hasTriggered50Ult) { _hasTriggered50Ult = true; _skillCDs[ultIndex] = 0; return ultIndex; } } if (_specialSkillTimer >= _specialSkillInterval) { List<int> readySpecials = new List<int>(); if (_skills.Length > 1 && _skillCDs[1] <= 0) readySpecials.Add(1); if (_skills.Length > 2 && _skillCDs[2] <= 0) readySpecials.Add(2); if (readySpecials.Count > 0) { _specialSkillTimer = 0f; return readySpecials[Random.Range(0, readySpecials.Count)]; } } if (_skills.Length > 0 && _skillCDs[0] <= 0) return 0; return -1; } public void TriggerChargeVisuals(Vector3 pos, float duration) { int skillIndex = _stateMachine.PendingSkillIndex; SpawnChargeVisualsClientRpc(skillIndex, pos, duration); } [ClientRpc] private void SpawnChargeVisualsClientRpc(int skillIndex, Vector3 pos, float duration) { if (_skills == null || skillIndex < 0 || skillIndex >= _skills.Length) return; var skillData = _skills[skillIndex]; var prefabs = skillData.chargeVisualPrefabs; if (prefabs == null || prefabs.Count == 0) return; foreach (var prefab in prefabs) { if (prefab == null) continue; GameObject instance = Instantiate(prefab, pos, Quaternion.identity); if (instance.TryGetComponent<ChargeGrowingVisual>(out var visualScript)) { visualScript.SetDuration(duration); } else { Destroy(instance, duration + 0.5f); } } } #endregion #region IDamageable public void TakeDamage(int amount, ulong attackerId) { if (!IsServer) return; if (_currentBossState.Value == BossMotionState.Die) return; int newHealth = Mathf.Max(_currentHealth.Value - amount, 0); _currentHealth.Value = newHealth; if (newHealth <= 0) { SetState(BossMotionState.Die); OnBossDied?.Invoke(); return; } if (Target == null && NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(attackerId, out var attacker)) { Target = attacker; if (_currentBossState.Value == BossMotionState.Idle) SetState(BossMotionState.Chase); } } #endregion private void OnHealthNetworkChanged(int prev, int curr) { OnHealthChanged?.Invoke(curr, _maxHealth); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossStateMachine.cs]
using UnityEngine; public class BossStateMachine { public BossBaseState CurrentState { get; private set; } public BossStateIdle StateIdle; public BossStateMove StateMove; public BossStateCharge StateCharge; public BossStateSkill StateSkill; public BossStateRecovery StateRecovery; public BossStateDie StateDie; public int PendingSkillIndex { get; set; } = -1; public BossStateMachine(BossController controller) { StateIdle = new BossStateIdle(controller, this); StateMove = new BossStateMove(controller, this); StateCharge = new BossStateCharge(controller, this); StateSkill = new BossStateSkill(controller, this); StateRecovery = new BossStateRecovery(controller, this); StateDie = new BossStateDie(controller, this); } public void Update() { CurrentState?.OnUpdate(); } public void ChangeState(BossBaseState newState) { if (newState == null || newState == CurrentState) return; CurrentState?.OnExit(); CurrentState = newState; CurrentState.OnEnter(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyController.cs]
using System; using System.Collections; using System.Linq; using Unity.Netcode; using UnityEngine; using UnityEngine.AI; [RequireComponent(typeof(NavMeshAgent)), RequireComponent(typeof(NetworkObject))] public class EnemyController : NetworkBehaviour, IDamageable { public enum NPCMotionState { Idle = 0, Chase = 1, Attack = 2, Die = 3 } [Header("Detection Settings")] [SerializeField] private float _chaseRange = 10f; [SerializeField] private LayerMask _chaseLayer; [Header("Skill Settings")] [SerializeField] private SkillDataSO _skillData; private float _repathTimer = 0f; private float _repathInterval = 0.2f; private float _attackTimer = 0f; private float _attackInterval = 0.833f; public LayerMask ChaseLayer => _chaseLayer; private NavMeshAgent _agent; private NetworkObject _target; #region public property public NavMeshAgent Agent => _agent; public float ChaseRange => _chaseRange; public SkillDataSO SkillData => _skillData; #endregion #region network variable private NetworkVariable<NPCMotionState> _currentEnmeyState = new NetworkVariable<NPCMotionState>( NPCMotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<NPCMotionState> Motion => _currentEnmeyState; public NPCMotionState MotionStateVar => _currentEnmeyState.Value; private NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 100, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public int MaxHealth => _maxHealth; public int CurrentHealth => _currentHealth.Value; [SerializeField] private int _maxHealth = 100; #endregion private float _skillTimer = 0f; public string GetSkillAnimationName() { return _skillData != null ? _skillData.activeAnimationName : "Attack"; } #region public events public event Action<int, int> OnHealthChanged; public event Action<NetworkObject> OnDied; #endregion public override void OnNetworkSpawn() { _agent = GetComponent<NavMeshAgent>(); if (IsServer) { _target = null; _agent.enabled = true; _currentEnmeyState.Value = NPCMotionState.Idle; _currentHealth.Value = _maxHealth; _skillTimer = 0f; if (_skillData != null) { _agent.stoppingDistance = Mathf.Max(1.0f, _skillData.castRadius - 0.5f); } } else { _agent.enabled = false; } _currentHealth.OnValueChanged += (prev, curr) => OnHealthChanged?.Invoke(curr, _maxHealth); OnHealthChanged?.Invoke(_currentHealth.Value, _maxHealth); } private void Update() { if (!IsServer) return; if (_skillTimer > 0) _skillTimer -= Time.deltaTime; switch (_currentEnmeyState.Value) { case NPCMotionState.Idle: LogicIdle(); break; case NPCMotionState.Chase: LogicChase(); break; case NPCMotionState.Attack: LogicAttack(); break; } } private void LogicIdle() { DetectPlayer(); if (_target != null) { float distance = Vector3.Distance(transform.position, _target.transform.position); float requiredRange = GetRequiredAttackRange(); if (distance <= requiredRange) { ChangeStateToAttack(); } else { ChangeStateToChase(); } } } private void LogicChase() { if (_target == null) { ChangeStateToIdle(); return; } float distance = Vector3.Distance(transform.position, _target.transform.position); if (distance > _chaseRange * 1.5f) { ChangeStateToIdle(); return; } float requiredRange = GetRequiredAttackRange(); if (distance <= requiredRange) { ChangeStateToAttack(); return; } ChasePlayerMovement(); } private void LogicAttack() { if (_target == null) { ChangeStateToIdle(); return; } float distance = Vector3.Distance(transform.position, _target.transform.position); float requiredRange = GetRequiredAttackRange(); if (distance > requiredRange * 1.1f) { ChangeStateToChase(); return; } if (_agent.isOnNavMesh && !_agent.isStopped) { _agent.isStopped = true; _agent.ResetPath(); } Vector3 direction = (_target.transform.position - transform.position).normalized; direction.y = 0; if (direction != Vector3.zero) { transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(direction), 10f * Time.deltaTime); } if (_skillTimer <= 0 && _skillData != null) { _skillTimer = _skillData.coolDown; _skillData.Cast(gameObject, _target.gameObject, _target.transform.position); Debug.Log($"Enemy Cast Skill: {_skillData.name}"); } } private float GetRequiredAttackRange() { if (_skillData != null) { return _skillData.castRadius; } return 2.0f; } private void ChangeStateToIdle() { if (_currentEnmeyState.Value == NPCMotionState.Idle) return; _currentEnmeyState.Value = NPCMotionState.Idle; _target = null; if (_agent.isOnNavMesh) _agent.ResetPath(); } private void ChangeStateToChase() { if (_currentEnmeyState.Value == NPCMotionState.Chase) return; _currentEnmeyState.Value = NPCMotionState.Chase; if (_agent.isOnNavMesh && _skillData != null) { float stopDist = Mathf.Max(0.5f, _skillData.castRadius * 0.8f); _agent.stoppingDistance = stopDist; _agent.isStopped = false; } } private void ChangeStateToAttack() { if (_currentEnmeyState.Value == NPCMotionState.Attack) return; _currentEnmeyState.Value = NPCMotionState.Attack; if (_agent.isOnNavMesh) _agent.ResetPath(); } private void ChasePlayerMovement() { _repathTimer += Time.deltaTime; if (_repathTimer > _repathInterval) { _repathTimer = 0f; if (_agent.isOnNavMesh && _target != null) { _agent.SetDestination(_target.transform.position); } } } private void DetectPlayer() { if (_target != null) return; var colliderInfos = Physics.OverlapSphere(transform.position, _chaseRange, _chaseLayer); if (colliderInfos.Length <= 0) return; NetworkObject bestTarget = null; float minDistance = float.MaxValue; foreach (Collider collider in colliderInfos) { if (collider.gameObject == gameObject) continue; if (!collider.TryGetComponent<PlayerDataContainer>(out PlayerDataContainer playerData)) continue; float d = Vector3.Distance(collider.transform.position, transform.position); if (d < minDistance) { minDistance = d; bestTarget = playerData.GetComponent<NetworkObject>(); } } if (bestTarget != null) { _target = bestTarget; } } public void TakeDamage(int amount, ulong attackerId) { if (!IsServer) return; int newHealth = _currentHealth.Value - amount; if (newHealth < 0) newHealth = 0; _currentHealth.Value = newHealth; if (_target == null && NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(attackerId, out var attackerObj)) { _target = attackerObj; ChangeStateToChase(); } if (newHealth <= 0) { OnDied?.Invoke(NetworkObject); GetComponent<NetworkObject>().Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyPresentation.cs]
using UnityEditor.VersionControl; using UnityEngine; [RequireComponent(typeof(Animator))] public class EnemyPresentation : MonoBehaviour { private EnemyController _controller; private IEnemyState _currentState; private Animator _animator; public Animator Animator => _animator; private string _skillAnimationName; public string SkillAnimationName => _skillAnimationName; void Start() { _controller = GetComponent<EnemyController>(); _controller.Motion.OnValueChanged += OnMtionStateChanged; _animator = GetComponent<Animator>(); } void Update() { } private void OnMtionStateChanged(EnemyController.NPCMotionState oldState, EnemyController.NPCMotionState newState) { RefreshState(); } private void RefreshState() { if(_controller == null) return; switch (_controller.MotionStateVar) { case EnemyController.NPCMotionState.Idle: if (_currentState is EnemyStateIdle) return; ChangeState(new EnemyStateIdle(this)); break; case EnemyController.NPCMotionState.Chase: if(_currentState is EnemyStateMove) return; ChangeState(new EnemyStateMove(this)); break; case EnemyController.NPCMotionState.Attack: if(_currentState is EnemyStateSkillActive) return; _skillAnimationName = _controller.GetSkillAnimationName(); ChangeState(new EnemyStateSkillActive(this)); break; default: break; } } public void ChangeState(IEnemyState newState) { _currentState?.Exit(); _currentState = newState; _currentState.Enter(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerStates\IPlayerState.cs]
using UnityEngine; public interface IPlayerState { void Enter(); void Update(); void Exit(); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerStates\PlayerStateDie.cs]
using Unity.Netcode; using Unity.VisualScripting; using UnityEngine; public class PlayerStateDie : IPlayerState { private float DieTime = 3f; private float timer = 0; private PlayerPresentation _view; public PlayerStateDie(PlayerPresentation view) => _view = view; public void Enter() { if (_view.CapsuleCollider != null) { _view.CapsuleCollider.enabled = false; } if (_view.Rigidbody != null) { _view.Rigidbody.isKinematic = true; } Debug.Log("���� Die��Presentation������ײ��ʧЧ�����嶳�ᣨDespawn �� Server Authority ����"); _view.Animator.Play("Die01_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerStates\PlayerStateIdle.cs]
using UnityEngine; public class PlayerStateIdle : IPlayerState { private RaycastHit groundHit; private PlayerPresentation _view; public PlayerStateIdle(PlayerPresentation view) => _view = view; public void Enter() { _view.Animator.Play("Idle_Battle_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerStates\PlayerStateMove.cs]
using System; using System.Globalization; using Unity.Netcode; using UnityEngine; public class PlayerStateMove : IPlayerState { private PlayerPresentation _view; public PlayerStateMove(PlayerPresentation view) => _view = view; public void Enter() { _view.Animator.Play("MoveFWD_Normal_InPlace_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerStates\PlayerStateSkill.cs]
using UnityEngine; public class PlayerStateSkill : IPlayerState { private PlayerPresentation _view; public PlayerStateSkill(PlayerPresentation view) { _view = view; } public void Enter() { _view.Animator.Play(_view.SkillAnimationName); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerDataContainer.cs]
using System; using System.Collections.Generic; using Unity.Collections; using Unity.Netcode; using UnityEngine; public class PlayerDataContainer : NetworkBehaviour, IDamageable, IDamageMitigator { [Header("Stats")] [SerializeField] private int _maxHealth = 100; #region netvar defination private readonly NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 100, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<int> CurrentHealthVar => _currentHealth; public int CurrentHealth => _currentHealth.Value; private readonly NetworkVariable<int> _points = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<int> PointVar => _points; private NetworkList<FixedString32Bytes> _items = new NetworkList<FixedString32Bytes>( new List<FixedString32Bytes>(), NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkList<FixedString32Bytes> ItemsVar => _items; #endregion public event Action<int, int> OnHealthChanged; public event Action<int, ulong> OnDamaged; public event Action<PlayerDataContainer> OnDied; private float _damageReductionPercentage = 0f; private Coroutine _reductionCoroutine; #region public properties public int MaxHealth => _maxHealth; public bool IsDead => _currentHealth.Value <= 0; #endregion public override void OnNetworkSpawn() { _currentHealth.OnValueChanged += HandleHealthChanged; if (IsServer) { _currentHealth.Value = _maxHealth; } OnHealthChanged?.Invoke(_currentHealth.Value, _maxHealth); } public override void OnNetworkDespawn() { _currentHealth.OnValueChanged -= HandleHealthChanged; } private void HandleHealthChanged(int prev, int curr) { OnHealthChanged?.Invoke(curr, _maxHealth); if (curr <= 0 && prev > 0) { OnDied?.Invoke(this); OnDiedServer(); } } #region IDamageable Interface & Server Logic public void TakeDamage(int amount, ulong attackerId) { if (!IsServer) return; if (IsDead) return; float reducedAmountFloat = amount * (1.0f - _damageReductionPercentage); int finalDamage = Mathf.RoundToInt(reducedAmountFloat); if (amount > 0 && finalDamage <= 0 && _damageReductionPercentage < 1.0f) finalDamage = 1; int newHealth = Mathf.Clamp(_currentHealth.Value - finalDamage, 0, _maxHealth); _currentHealth.Value = newHealth; DamagedClientRpc(finalDamage, attackerId); } public void Heal(int amount) { if (!IsServer) return; if (IsDead) return; int newHealth = Mathf.Clamp(_currentHealth.Value + amount, 0, _maxHealth); _currentHealth.Value = newHealth; } public void AddPointsServer(int amount) { if (!IsServer) return; _points.Value += amount; } public void AddItemServer(string name) { _items.Add(name); string allItems = ""; foreach (var item in _items) { allItems += item; } Debug.Log(allItems); } private void OnDiedServer() { if (!IsServer) return; NetworkObject.Despawn(); } [ClientRpc] private void DamagedClientRpc(int damage, ulong attackerId) { OnDamaged?.Invoke(damage, attackerId); if (DamageTextManager.Instance != null) { Vector3 randomOffset = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 1.5f, 0); DamageTextManager.Instance.ShowDamage(damage, transform.position + randomOffset); } if (HitStopManager.Instance != null) { HitStopManager.Instance.TriggerHitStop(); } if (TryGetComponent<DamageFlash>(out var flash)) { flash.TriggerFlash(); } } public void ApplyDamageReduction(float percentage, float duration) { if (!IsServer) return; if (_reductionCoroutine != null) { StopCoroutine(_reductionCoroutine); } _reductionCoroutine = StartCoroutine(DamageReductionRoutine(percentage, duration)); } private System.Collections.IEnumerator DamageReductionRoutine(float percentage, float time) { _damageReductionPercentage = Mathf.Clamp01(percentage); Debug.Log($"[Buff] ���˿���: {_damageReductionPercentage:P0}, ���� {time}��"); yield return new WaitForSeconds(time); _damageReductionPercentage = 0f; _reductionCoroutine = null; Debug.Log("[Buff] ���˽���"); } #endregion }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerMainController.cs]
using Unity.Netcode; using UnityEngine; public class PlayerMainController : NetworkBehaviour { [Header("Components")] [SerializeField] private PlayerNetworkMovement _movement; [SerializeField] private PlayerNetworkCombat _combat; [SerializeField] private PlayerDataContainer _dataContainer; [SerializeField] private PlayerNewInputManager _inputManager; [SerializeField] private Animator _animator; public PlayerNetworkMovement Movement => _movement; public PlayerNetworkCombat Combat => _combat; public PlayerDataContainer DataContainer => _dataContainer; public Animator Animator => _animator; public FrameInput Input => _inputManager != null ? _inputManager.CurrentInput : new FrameInput(); private PlayerStateMachine _stateMachine; public PlayerStateMachine StateMachine => _stateMachine; private void Awake() { if (_movement == null) _movement = GetComponent<PlayerNetworkMovement>(); if (_combat == null) _combat = GetComponent<PlayerNetworkCombat>(); if (_dataContainer == null) _dataContainer = GetComponent<PlayerDataContainer>(); if (_inputManager == null) _inputManager = GetComponent<PlayerNewInputManager>(); if (_animator == null) _animator = GetComponent<Animator>(); _stateMachine = new PlayerStateMachine(this); if (GameCameraManager.Instance != null) { GameCameraManager.Instance.SetFollowTarget(transform); } } public override void OnNetworkSpawn() { if (IsOwner) { GameHUDView.Instance.BindToLocalPlayer(_dataContainer, _combat); } if (IsServer) { GameLifecycleManager.Instance.RegisterPlayer(this); } } public override void OnNetworkDespawn() { if (IsServer) { GameLifecycleManager.Instance.UnregisterPlayer(this); } } private void Update() { _stateMachine.Update(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkCombat.cs]
using System; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkCombat : NetworkBehaviour { [Header("Skills Configuration")] [Tooltip("Index 0 = Attack, 1 = Q, 2 = W, 3 = E")] [SerializeField] private List<SkillDataSO> _skillSlots; #region Network Variables private readonly NetworkVariable<bool> _qSkillReady = new NetworkVariable<bool>(true); private readonly NetworkVariable<bool> _wSkillReady = new NetworkVariable<bool>(true); private readonly NetworkVariable<bool> _eSkillReady = new NetworkVariable<bool>(true); private readonly NetworkVariable<int> _currentSkillIndex = new NetworkVariable<int>(0); public NetworkVariable<bool> QSkillActiveVar => _qSkillReady; public NetworkVariable<bool> WSkillActiveVar => _wSkillReady; public NetworkVariable<bool> ESkillActiveVar => _eSkillReady; public event Action<int> OnSkillIndexChanged; #endregion private float[] _cooldownTimers; private PlayerNetworkMovement _movement; private void Awake() { _movement = GetComponent<PlayerNetworkMovement>(); _cooldownTimers = new float[_skillSlots.Count]; for (int i = 0; i < _skillSlots.Count; i++) { if (_skillSlots[i] != null) { _skillSlots[i].SetDurations(); _cooldownTimers[i] = _skillSlots[i].coolDown; } } } private void Update() { if (!IsServer) return; ProcessCooldowns(); } private void ProcessCooldowns() { for (int i = 0; i < _cooldownTimers.Length; i++) { if (_cooldownTimers[i] > 0) { _cooldownTimers[i] -= Time.deltaTime; } else { if (i == 1 && !_qSkillReady.Value) _qSkillReady.Value = true; if (i == 2 && !_wSkillReady.Value) _wSkillReady.Value = true; if (i == 3 && !_eSkillReady.Value) _eSkillReady.Value = true; } } } #region Public API public SkillDataSO GetSkillDataByIndex(int index) { if (index >= 0 && index < _skillSlots.Count) return _skillSlots[index]; return null; } public bool IsSkillReadyClient(int index) { if (index == 0) return true; if (index == 1) return _qSkillReady.Value; if (index == 2) return _wSkillReady.Value; if (index == 3) return _eSkillReady.Value; return false; } public void RequestCastSkill(int index, Vector3 aimPosition) { if (IsOwner) { RequestCastSkillServerRpc(index, aimPosition); } } #endregion [ServerRpc] private void RequestCastSkillServerRpc(int index, Vector3 aimPosition) { if (index < 0 || index >= _skillSlots.Count) return; if (_cooldownTimers[index] > 0) return; if (_movement != null) { _movement.ServerStopMove(); _movement.ServerLookAt(aimPosition); } _cooldownTimers[index] = _skillSlots[index].coolDown; if (index == 1) _qSkillReady.Value = false; if (index == 2) _wSkillReady.Value = false; if (index == 3) _eSkillReady.Value = false; _currentSkillIndex.Value = index; ExecuteSkillLogic(index, aimPosition); } private void ExecuteSkillLogic(int index, Vector3 aimPosition) { SkillDataSO skillData = _skillSlots[index]; if (skillData != null) { Debug.Log($"[Combat] Server executing skill: {skillData.name}"); skillData.Cast(gameObject, null, aimPosition); } } public string GetSkillChargeAnimation(int index) { return _skillSlots[index].chargeAnimationName; } public string GetSkillAnimationName(int index) { return _skillSlots[index].activeAnimationName; } public string GetSkillRecoveryAnimation(int index) { return _skillSlots[index].recoveryAnimationName; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkMovement.cs]
using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkMovement : NetworkBehaviour, IKnockBackable, ITeleportable { [Header("Settings")] [SerializeField] private float moveSpeed = 6f; [SerializeField] private float rotateSpeed = 15f; [SerializeField] private float smoothTime = 0.15f; [Header("Physics")] [SerializeField] private float gravity = -9.81f; [SerializeField] private float drag = 2.0f; [SerializeField] private LayerMask groundLayer; [SerializeField] private float groundCheckOffset = 2.0f; private Vector3 _serverTargetPosition; private Vector3 _smoothDampVelocity; private Vector3 _velocity; private bool _isKnockedBack = false; public override void OnNetworkSpawn() { if (IsServer) { _serverTargetPosition = transform.position; } } private void Update() { if (!IsServer) return; if (_isKnockedBack) { HandleKnockbackPhysics(); return; } ProcessMovementServer(); } #region Public API public void RequestMove(Vector3 worldPos) { if (IsOwner) { RequestMoveServerRpc(worldPos); } } public void RequestStop() { if (IsOwner) { RequestStopServerRpc(); } } #endregion #region Server Logic [ServerRpc] private void RequestMoveServerRpc(Vector3 pos) { if (_isKnockedBack) return; _serverTargetPosition = pos; } [ServerRpc] private void RequestStopServerRpc() { ServerStopMove(); } public void ServerStopMove() { if (!IsServer) return; _serverTargetPosition = transform.position; _smoothDampVelocity = Vector3.zero; _velocity = Vector3.zero; } public void ServerLookAt(Vector3 targetPos) { if (!IsServer) return; Vector3 direction = targetPos - transform.position; direction.y = 0; if (direction.sqrMagnitude > 0.001f) { transform.rotation = Quaternion.LookRotation(direction.normalized); } } private void ProcessMovementServer() { Vector3 currentPosFlat = new Vector3(transform.position.x, 0, transform.position.z); Vector3 targetPosFlat = new Vector3(_serverTargetPosition.x, 0, _serverTargetPosition.z); if (Vector3.SqrMagnitude(targetPosFlat - currentPosFlat) < 0.01f) return; Vector3 directionToTarget = targetPosFlat - currentPosFlat; if (directionToTarget.sqrMagnitude > 0.01f) { Quaternion targetRot = Quaternion.LookRotation(directionToTarget.normalized); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime); } Vector3 newPosFlat = Vector3.SmoothDamp( currentPosFlat, targetPosFlat, ref _smoothDampVelocity, smoothTime, moveSpeed ); float newY = transform.position.y; Vector3 rayOrigin = new Vector3(newPosFlat.x, transform.position.y + groundCheckOffset, newPosFlat.z); if (Physics.Raycast(rayOrigin, Vector3.down, out RaycastHit hit, 20.0f, groundLayer)) { newY = hit.point.y; } else { } transform.position = new Vector3(newPosFlat.x, newY, newPosFlat.z); } public void ApplyKnockbackServer(Vector3 forceDir, float forceStrength) { if (!IsServer) return; _isKnockedBack = true; _velocity = forceDir.normalized * forceStrength; _serverTargetPosition = transform.position; } public void TeleportServer(Vector3 position) { if (!IsServer) return; transform.position = position; _serverTargetPosition = position; _smoothDampVelocity = Vector3.zero; _velocity = Vector3.zero; _isKnockedBack = false; Debug.Log($"[Movement] Teleported to {position}"); } private void HandleKnockbackPhysics() { float dt = Time.deltaTime; _velocity.y += gravity * 2.0f * dt; Vector3 horizontalVel = new Vector3(_velocity.x, 0, _velocity.z); horizontalVel = Vector3.Lerp(horizontalVel, Vector3.zero, drag * dt); _velocity = new Vector3(horizontalVel.x, _velocity.y, horizontalVel.z); Vector3 nextPos = transform.position + _velocity * dt; if (Physics.Raycast(nextPos + Vector3.up * 0.5f, Vector3.down, out RaycastHit hit, 1.0f, groundLayer)) { if (_velocity.y < 0 && nextPos.y <= hit.point.y) { _isKnockedBack = false; _velocity = Vector3.zero; transform.position = new Vector3(nextPos.x, hit.point.y, nextPos.z); _serverTargetPosition = transform.position; return; } } transform.position = nextPos; } public void ServerReset() { _serverTargetPosition = transform.position; _smoothDampVelocity = Vector3.zero; _velocity = Vector3.zero; _isKnockedBack = false; } #endregion private void OnTriggerEnter(Collider other) { if (other != null) { var interactable = other.GetComponent<IInteractable>(); if (interactable != null) { interactable.Interact(gameObject); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNewInputManager.cs]
using System.Globalization; using Unity.Netcode; using Unity.VisualScripting; using UnityEngine; public struct FrameInput { public Vector2 MoveInput; public bool AttackDown; public bool SkillQDown; public bool SkillWDown; public bool SkillEDown; public bool StopDown; public bool InteractDown; public Vector3 MouseWorldPos; public bool HasMouseTarget; public RaycastHit MouseHit; } public class PlayerNewInputManager : NetworkBehaviour { [Header("Raycast Layers")] [SerializeField] private LayerMask groundLayer; private Camera _mainCamera; public FrameInput CurrentInput { get; private set; } public override void OnNetworkSpawn() { if (IsOwner) { _mainCamera = Camera.main; } else { enabled = false; } } private void Update() { if (!IsOwner) return; CurrentInput = GatherInput(); } private FrameInput GatherInput() { var input = new FrameInput { MoveInput = new Vector2(Input.GetAxisRaw("Horizontal"), Input.GetAxisRaw("Vertical")), StopDown = Input.GetKeyDown(KeyCode.S), AttackDown = Input.GetKeyDown(KeyCode.A), SkillQDown = Input.GetKeyDown(KeyCode.Q), SkillWDown = Input.GetKeyDown(KeyCode.W), SkillEDown = Input.GetKeyDown(KeyCode.E), InteractDown = Input.GetMouseButtonDown(1), HasMouseTarget = false, }; if (_mainCamera != null) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out RaycastHit hit, 1000f, groundLayer)) { input.MouseWorldPos = hit.point; input.HasMouseTarget = true; input.MouseHit = hit; } } return input; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerBaseState.cs]
using UnityEngine; public abstract class PlayerBaseState { protected PlayerMainController _controller; protected FrameInput _currentInput; public PlayerBaseState(PlayerMainController controller) { _controller = controller; } public virtual void OnEnter() { } public virtual void OnUpdate() { if (_controller.DataContainer.IsDead) { if (!(_controller.StateMachine.CurrentState is PlayerNewStateDie)) { _controller.StateMachine.ChangeState(_controller.StateMachine.StateDie); } return; } if (_controller.IsOwner) { _currentInput = _controller.Input; } } public virtual void OnExit() { } protected abstract void StateLogic(); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerNewStateCharge.cs]
using UnityEngine; public class PlayerNewStateCharge : PlayerBaseState { private bool stateFinished = false; SkillDataSO _currentSkill; private Coroutine _timerCoroutine; public PlayerNewStateCharge(PlayerMainController controller) : base(controller) { } public override void OnEnter() { stateFinished = false; if (_controller.IsOwner) { int skillIndex = _controller.StateMachine.PendingSkillIndex; Vector3 aimPos = _controller.StateMachine.PendingAimPosition; if (skillIndex != -1) { _controller.StateMachine.PendingSkillIndex = skillIndex; string animName = _controller.Combat.GetSkillChargeAnimation(skillIndex); _controller.Animator.CrossFade(animName, 0.05f); _currentSkill = _controller.Combat.GetSkillDataByIndex(skillIndex); float duration = _currentSkill.chargeDuration; _timerCoroutine = _controller.StartCoroutine(EndStateRoutine(duration)); } else { stateFinished = true; } } } private System.Collections.IEnumerator EndStateRoutine(float time) { yield return new WaitForSeconds(time); stateFinished = true; _controller.StateMachine.ChangeState(_controller.StateMachine.StateSkill); } public override void OnUpdate() { base.OnUpdate(); if (_controller.IsOwner) { StateLogic(); } } public override void OnExit() { if (_timerCoroutine != null) { _controller.StopCoroutine(_timerCoroutine); _timerCoroutine = null; } } protected override void StateLogic() { if (ChangeStateToMove()) return; } private bool ChangeStateToSkill() { if (stateFinished) { return true; } return false; } private bool ChangeStateToMove() { if (_currentInput.InteractDown && _currentInput.HasMouseTarget && _currentSkill.ifChargeInteruptable) { Debug.Log("��Charge״̬��⵽�ƶ����룬���е����Ŀ�꣬׼���л��� �ƶ�״̬"); _controller.StateMachine.ChangeState(_controller.StateMachine.StateMove); return true; } return false; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerNewStateDie.cs]
using UnityEngine; public class PlayerNewStateDie : PlayerBaseState { public PlayerNewStateDie(PlayerMainController controller) : base(controller) { } public override void OnEnter() { } public override void OnUpdate() { } public override void OnExit() { } protected override void StateLogic() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerNewStateIdle.cs]
using UnityEngine; public class PlayerNewStateIdle : PlayerBaseState { public PlayerNewStateIdle(PlayerMainController controller) : base(controller) { } public override void OnEnter() { _controller.Animator.CrossFade("Idle_Battle_SwordAndShield", 0.05f); if (_controller.IsOwner) { _controller.Movement.RequestStop(); } } public override void OnUpdate() { base.OnUpdate(); if (_controller.IsOwner) { StateLogic(); } } protected override void StateLogic() { if (ChangeStateToCharge()) return; if (ChangeStateToMove()) return; } #region Checks private bool ChangeStateToMove() { if (_currentInput.InteractDown && _currentInput.HasMouseTarget) { Debug.Log("�� idle״̬��⵽�ƶ����룬���е����Ŀ�꣬׼���л��� �ƶ�״̬"); _controller.StateMachine.ChangeState(_controller.StateMachine.StateMove); return true; } return false; } private bool ChangeStateToCharge() { int skillIdx = -1; if (_currentInput.AttackDown) skillIdx = 0; else if (_currentInput.SkillQDown) skillIdx = 1; else if (_currentInput.SkillWDown) skillIdx = 2; else if (_currentInput.SkillEDown) skillIdx = 3; if (skillIdx != -1) { if (_controller.Combat.IsSkillReadyClient(skillIdx)) { Debug.Log($"[Idle] �ͷż��� {skillIdx}��CD�������л�״̬"); _controller.StateMachine.PendingSkillIndex = skillIdx; _controller.StateMachine.PendingAimPosition = _currentInput.MouseWorldPos; _controller.StateMachine.ChangeState(_controller.StateMachine.StateCharge); return true; } } return false; } #endregion }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerNewStateMove.cs]
using UnityEngine; public class PlayerNewStateMove : PlayerBaseState { private Vector3 _targetPos; private const float StopDistance = 0.2f; public PlayerNewStateMove(PlayerMainController controller) : base(controller) { } public override void OnEnter() { _controller.Animator.Play("MoveFWD_Normal_InPlace_SwordAndShield"); var input = _controller.Input; if (input.HasMouseTarget) { _targetPos = input.MouseWorldPos; _controller.Movement.RequestMove(_targetPos); } else { _targetPos = _controller.transform.position; } } public override void OnUpdate() { base.OnUpdate(); if (_controller.IsOwner) { StateLogic(); if (_controller.StateMachine.CurrentState == this) { PerformMove(); } } } protected override void StateLogic() { if (ChangeStateToCharge()) return; if (ChangeStateToIdle()) return; } private void PerformMove() { if (_currentInput.InteractDown && _currentInput.HasMouseTarget) { _targetPos = _currentInput.MouseWorldPos; _controller.Movement.RequestMove(_targetPos); } } #region Checks private bool ChangeStateToIdle() { if (_currentInput.StopDown) { _controller.Movement.RequestStop(); _controller.StateMachine.ChangeState(_controller.StateMachine.StateIdle); return true; } Vector3 playerPos = _controller.transform.position; playerPos.y = 0; Vector3 targetPos = _targetPos; targetPos.y = 0; if (Vector3.Distance(playerPos, targetPos) <= StopDistance) { _controller.StateMachine.ChangeState(_controller.StateMachine.StateIdle); return true; } return false; } private bool ChangeStateToCharge() { int skillIdx = -1; if (_currentInput.AttackDown) skillIdx = 0; else if (_currentInput.SkillQDown) skillIdx = 1; else if (_currentInput.SkillWDown) skillIdx = 2; else if (_currentInput.SkillEDown) skillIdx = 3; if (skillIdx != -1) { if (_controller.Combat.IsSkillReadyClient(skillIdx)) { _controller.StateMachine.PendingSkillIndex = skillIdx; _controller.StateMachine.PendingAimPosition = _currentInput.MouseWorldPos; _controller.StateMachine.ChangeState(_controller.StateMachine.StateCharge); return true; } } return false; } #endregion }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerNewStateRecovery.cs]
using UnityEngine; public class PlayerNewStateRecovery : PlayerBaseState { private bool _stateFinished = false; private SkillDataSO _currentSkill; private Coroutine _timerCoroutine; public PlayerNewStateRecovery(PlayerMainController controller) : base(controller) { } public override void OnEnter() { _stateFinished = false; int skillIndex = _controller.StateMachine.PendingSkillIndex; if (skillIndex != -1) { string animName = _controller.Combat.GetSkillRecoveryAnimation(skillIndex); _controller.Animator.CrossFade(animName, 0.05f); _currentSkill = _controller.Combat.GetSkillDataByIndex(skillIndex); float duration = _currentSkill.activeDuration; _controller.StartCoroutine(EndStateRoutine(duration)); } else { _stateFinished = true; } } private System.Collections.IEnumerator EndStateRoutine(float time) { yield return new WaitForSeconds(time); _stateFinished = true; } public override void OnUpdate() { base.OnUpdate(); if (_controller.IsOwner) { StateLogic(); } } public override void OnExit() { if (_timerCoroutine != null) { _controller.StopCoroutine(_timerCoroutine); _timerCoroutine = null; } } protected override void StateLogic() { if (ChangeStateToIdle()) return; if (ChangeStateToMove()) return; } private bool ChangeStateToIdle() { if (_stateFinished) { _controller.StateMachine.ChangeState(_controller.StateMachine.StateIdle); return true; } return false; } private bool ChangeStateToMove() { if (_currentInput.InteractDown && _currentInput.HasMouseTarget && _currentSkill.ifRecoveryInteruptable) { Debug.Log("��Recovery״̬��⵽�ƶ����룬���е����Ŀ�꣬׼���л��� �ƶ�״̬"); _controller.StateMachine.ChangeState(_controller.StateMachine.StateMove); return true; } return false; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerNewStateSkill.cs]
using UnityEngine; public class PlayerNewStateSkill : PlayerBaseState { private bool _stateFinished; private Coroutine _timerCoroutine; private SkillDataSO _currentSkillData; public PlayerNewStateSkill(PlayerMainController controller) : base(controller) { } public override void OnEnter() { _stateFinished = false; if (_controller.IsOwner) { int skillIndex = _controller.StateMachine.PendingSkillIndex; Vector3 aimPos = _controller.StateMachine.PendingAimPosition; if (skillIndex != -1) { _currentSkillData = _controller.Combat.GetSkillDataByIndex(skillIndex); string animName = _controller.Combat.GetSkillAnimationName(skillIndex); _controller.Animator.CrossFade(animName, 0.05f); _controller.Combat.RequestCastSkill(skillIndex, aimPos); var skillData = _controller.Combat.GetSkillDataByIndex(skillIndex); float duration = skillData.activeDuration; _timerCoroutine = _controller.StartCoroutine(EndSkillRoutine(duration)); } else { _stateFinished = true; } } } private System.Collections.IEnumerator EndSkillRoutine(float time) { yield return new WaitForSeconds(time); _stateFinished = true; } public override void OnUpdate() { base.OnUpdate(); if (_controller.IsOwner) { StateLogic(); HandleMovementLogic(); } } public override void OnExit() { if (_timerCoroutine != null) { _controller.StopCoroutine(_timerCoroutine); _timerCoroutine = null; } _currentSkillData = null; } protected override void StateLogic() { if (ChangeStateToRecovery()) return; } private bool ChangeStateToRecovery() { if (_stateFinished) { _controller.StateMachine.ChangeState(_controller.StateMachine.StateRecovery); return true; } return false; } private void HandleMovementLogic() { if (_currentSkillData == null || !_currentSkillData.canMoveDuringActive) return; var input = _controller.Input; if (input.MoveInput != Vector2.zero) { Vector3 camForward = Camera.main.transform.forward; Vector3 camRight = Camera.main.transform.right; camForward.y = 0; camRight.y = 0; camForward.Normalize(); camRight.Normalize(); Vector3 moveDir = (camForward * input.MoveInput.y + camRight * input.MoveInput.x).normalized; Vector3 targetPos = _controller.transform.position + moveDir * 2.0f; _controller.Movement.RequestMove(targetPos); } else if (input.StopDown) { _controller.Movement.RequestStop(); } if (input.InteractDown && input.HasMouseTarget) { _controller.Movement.RequestMove(input.MouseWorldPos); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateMachine.cs]
using UnityEngine; public class PlayerStateMachine { public PlayerNewStateIdle StateIdle; public PlayerNewStateMove StateMove; public PlayerNewStateCharge StateCharge; public PlayerNewStateSkill StateSkill; public PlayerNewStateRecovery StateRecovery; public PlayerNewStateDie StateDie; public int PendingSkillIndex { get; set; } = -1; private float _chargeTime; private float _skillTime; private float _recoveryTime; public float ChargeTime => _chargeTime; public float SkillTime => _skillTime; public float RecoveryTime => _recoveryTime; public PlayerBaseState CurrentState => _currentState; private PlayerBaseState _currentState; private PlayerMainController _controller; public Vector3 PendingAimPosition { get; set; } public PlayerStateMachine(PlayerMainController controller) { _controller = controller; StateIdle = new PlayerNewStateIdle(_controller); StateMove = new PlayerNewStateMove(_controller); StateCharge = new PlayerNewStateCharge(_controller); StateSkill = new PlayerNewStateSkill(_controller); StateRecovery = new PlayerNewStateRecovery(_controller); StateDie = new PlayerNewStateDie(_controller); _currentState = StateIdle; _currentState.OnEnter(); Debug.Log($"[StateMachine] ��ʼ����ɣ���ǰ״̬: {_currentState}"); } public void Update() { _currentState?.OnUpdate(); } public void ChangeState(PlayerBaseState nextState) { if (nextState == null) return; if (_currentState != null) { _currentState.OnExit(); } Debug.Log($"[StateMachine] �л�״̬: {_currentState} -> {nextState}"); _currentState = nextState; _currentState.OnEnter(); } public void SetAnimationTimes(float chargeTime, float skillTime, float recoveryTime) { _chargeTime = chargeTime; _skillTime = skillTime; _recoveryTime = recoveryTime; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\AreaEffect.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class AreaEffect : SkillEffect { [Header("AOE ����")] public float radius = 3f; public float delay = 1.0f; public int damage = 10; public GameObject vfxPrefab; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (vfxPrefab != null) { var vfx = GameObject.Instantiate(vfxPrefab, position, Quaternion.identity); vfx.GetComponent<NetworkObject>().Spawn(); GameObject.Destroy(vfx, delay + 0.5f); } caster.GetComponent<NetworkBehaviour>().StartCoroutine(ExplodeRoutine(caster, position)); } private IEnumerator ExplodeRoutine(GameObject caster, Vector3 centerPos) { yield return new WaitForSeconds(delay); Collider[] hits = Physics.OverlapSphere(centerPos, radius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage(damage, caster.GetComponent<NetworkObject>().NetworkObjectId); Debug.Log($"[Effect] AOE ը���� {hit.name}"); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\BossJumpEffect.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class BossJumpEffect : SkillEffect { [Header("��Ծ����")] public float height = 5.0f; public float duration = 1.0f; public bool isLanding = false; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (!caster.TryGetComponent<UnityEngine.AI.NavMeshAgent>(out var agent)) return; caster.GetComponent<NetworkBehaviour>().StartCoroutine( JumpRoutine(caster.transform, agent, isLanding) ); } private IEnumerator JumpRoutine(Transform bossInfo, UnityEngine.AI.NavMeshAgent agent, bool landing) { float timer = 0f; Vector3 startPos = bossInfo.position; Vector3 endPos = landing ? new Vector3(startPos.x, 0, startPos.z) : startPos + Vector3.up * height; if (!landing) { agent.enabled = false; } while (timer < duration) { timer += Time.deltaTime; float t = timer / duration; bossInfo.position = Vector3.Lerp(startPos, endPos, t); yield return null; } bossInfo.position = endPos; if (landing) { agent.enabled = true; if (UnityEngine.AI.NavMesh.SamplePosition(bossInfo.position, out var hit, 2.0f, UnityEngine.AI.NavMesh.AllAreas)) { agent.Warp(hit.position); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\CameraShakeEffect.cs]
using System; using UnityEngine; [Serializable] public class CameraShakeEffect : SkillEffect { [Header("��Ļ������")] [Tooltip("������ (0.1 - 5.0)")] public float shakeForce = 1.0f; [Tooltip("ֻ���ͷ����Լ��ܸ��ܵ�����")] public bool onlyLocalPlayer = true; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (GameCameraManager.Instance == null) return; bool shouldShake = false; if (onlyLocalPlayer) { if (caster.TryGetComponent<Unity.Netcode.NetworkObject>(out var netObj)) { if (netObj.IsOwner) shouldShake = true; } } else { shouldShake = true; } if (shouldShake) { GameCameraManager.Instance.ShakeCamera(shakeForce); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\ConeLaserEffect.cs]
using System; using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using Random = UnityEngine.Random; [Serializable] public class ConeLaserEffect : SkillEffect { [Header("����Ԥ���� (��� NetworkObject + LaserVisual)")] [SerializeField] private NetworkObject _laserPrefab; [Header("��Χ����")] [Range(0, 180)] public float coneAngle = 60f; public int rayCount = 5; [Header("��������")] public float startLength = 0.5f; public float maxLength = 20f; public float growthTime = 1.0f; public float totalDuration = 3.0f; [Header("ս������")] public float rayWidth = 0.2f; public int damagePerTick = 10; public float damageInterval = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { caster.GetComponent<NetworkBehaviour>().StartCoroutine( LaserBarrageRoutine(caster) ); } private IEnumerator LaserBarrageRoutine(GameObject caster) { List<NetworkObject> activeLasers = new List<NetworkObject>(); List<Vector3> laserDirections = new List<Vector3>(); for (int i = 0; i < rayCount; i++) { float randomYAngle = Random.Range(-coneAngle / 2f, coneAngle / 2f); Quaternion rotation = Quaternion.Euler(0, randomYAngle, 0); Vector3 finalDir = rotation * caster.transform.forward; Vector3 spawnPos = caster.transform.position + Vector3.up * 1.0f; Quaternion laserRot = Quaternion.LookRotation(finalDir); var laserInstance = GameObject.Instantiate(_laserPrefab, spawnPos, laserRot); laserInstance.Spawn(); activeLasers.Add(laserInstance); laserDirections.Add(finalDir); if (laserInstance.TryGetComponent<LaserVisual>(out var visual)) { visual.InitializeLaserClientRpc(startLength, maxLength, growthTime, rayWidth); } } float timer = 0f; Dictionary<string, float> hitRecords = new Dictionary<string, float>(); while (timer < totalDuration) { timer += Time.deltaTime; float progress = Mathf.Clamp01(timer / growthTime); float currentLogicLen = Mathf.Lerp(startLength, maxLength, progress); for (int i = 0; i < activeLasers.Count; i++) { var laserObj = activeLasers[i]; if (laserObj == null || !laserObj.IsSpawned) continue; Vector3 origin = laserObj.transform.position; Vector3 dir = laserObj.transform.forward; RaycastHit[] hits = Physics.SphereCastAll(origin, rayWidth / 2f, dir, currentLogicLen); foreach (var hit in hits) { if (hit.collider.gameObject == caster) continue; if (hit.collider.TryGetComponent<IDamageable>(out var damageable)) { ulong targetId = hit.collider.GetComponent<NetworkObject>().NetworkObjectId; ulong laserId = laserObj.NetworkObjectId; string key = $"{laserId}_{targetId}"; if (!hitRecords.ContainsKey(key) || (Time.time - hitRecords[key] > damageInterval)) { damageable.TakeDamage(damagePerTick, caster.GetComponent<NetworkObject>().NetworkObjectId); hitRecords[key] = Time.time; } } } } yield return null; } foreach (var laser in activeLasers) { if (laser != null && laser.IsSpawned) { laser.Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\DamageEffect.cs]
using System; using Unity.Netcode; using UnityEngine; [Serializable] public class DamageEffect : SkillEffect { [Header("Damage Settings")] public int damageAmount = 10; [Header("Area Settings")] [Tooltip("�����ж������ĵ����ʩ����ǰ���ľ���")] public float forwardDistance = 1.5f; [Tooltip("�����ж��İ뾶")] public float attackRadius = 1.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { Vector3 attackCenter = caster.transform.position + caster.transform.forward * forwardDistance; ulong attackerId = 0; if (caster.TryGetComponent<NetworkObject>(out var casterNetObj)) { attackerId = casterNetObj.NetworkObjectId; } Collider[] hits = Physics.OverlapSphere(attackCenter, attackRadius); bool hasHit = false; foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage(damageAmount, attackerId); hasHit = true; } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\DamageReductionEffect.cs]
using System; using UnityEngine; [Serializable] public class DamageReductionEffect : SkillEffect { [Range(0f, 1f)] public float reductionPercentage = 0.5f; public float duration = 3.0f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (caster.TryGetComponent<IDamageMitigator>(out var mitigator)) { mitigator.ApplyDamageReduction(reductionPercentage, duration); } else { Debug.LogWarning($"[DamageReductionEffect] {caster.name} û��ʵ�� IDamageMitigator �ӿڣ��޷�Ӧ�ü��ˡ�"); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\DynamicLaserEffect.cs]
using System; using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using Random = UnityEngine.Random; [Serializable] public class DynamicLaserEffect : SkillEffect { [Header("����Ԥ���� (��� NetworkObject + NetworkTransform + LaserVisual)")] [SerializeField] private NetworkObject _laserPrefab; [Header("��Χ����")] [Range(0, 180)] public float baseConeAngle = 60f; public int rayCount = 5; [Header("��̬ɨ������ (Snake Motion)")] public float sweepSpeed = 2.0f; public float sweepAmplitude = 30f; public bool syncRotationWithBoss = true; [Header("��������")] public float startLength = 0.5f; public float maxLength = 20f; public float growthTime = 1.0f; public float totalDuration = 5.0f; [Header("ս������")] public float rayWidth = 0.5f; public int damagePerTick = 10; public float damageInterval = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { caster.GetComponent<NetworkBehaviour>().StartCoroutine( LaserBarrageRoutine(caster) ); } private IEnumerator LaserBarrageRoutine(GameObject caster) { List<NetworkObject> activeLasers = new List<NetworkObject>(); List<float> initialYOffsets = new List<float>(); List<float> noiseSeeds = new List<float>(); for (int i = 0; i < rayCount; i++) { float t = rayCount > 1 ? (float)i / (rayCount - 1) : 0.5f; float baseAngle = Mathf.Lerp(-baseConeAngle / 2f, baseConeAngle / 2f, t); Vector3 spawnPos = caster.transform.position + Vector3.up * 1.0f; Quaternion spawnRot = caster.transform.rotation * Quaternion.Euler(0, baseAngle, 0); var laserInstance = GameObject.Instantiate(_laserPrefab, spawnPos, spawnRot); laserInstance.Spawn(); activeLasers.Add(laserInstance); initialYOffsets.Add(baseAngle); noiseSeeds.Add(Random.Range(0f, 100f)); if (laserInstance.TryGetComponent<LaserVisual>(out var visual)) { visual.InitializeLaserClientRpc(startLength, maxLength, growthTime, rayWidth); } } float timer = 0f; Dictionary<string, float> hitRecords = new Dictionary<string, float>(); while (timer < totalDuration) { if (caster == null) break; timer += Time.deltaTime; float growProgress = Mathf.Clamp01(timer / growthTime); float currentLogicLen = Mathf.Lerp(startLength, maxLength, growProgress); Vector3 bossCenter = caster.transform.position + Vector3.up * 1.0f; Quaternion bossForwardRot = syncRotationWithBoss ? caster.transform.rotation : Quaternion.identity; for (int i = 0; i < activeLasers.Count; i++) { var laserObj = activeLasers[i]; if (laserObj == null || !laserObj.IsSpawned) continue; laserObj.transform.position = bossCenter; float baseOffset = initialYOffsets[i]; float noiseVal = Mathf.PerlinNoise(Time.time * sweepSpeed, noiseSeeds[i]); float sweepOffset = (noiseVal - 0.5f) * 2f * sweepAmplitude; Quaternion targetRot = bossForwardRot * Quaternion.Euler(0, baseOffset + sweepOffset, 0); laserObj.transform.rotation = targetRot; Vector3 dir = laserObj.transform.forward; RaycastHit[] hits = Physics.SphereCastAll(bossCenter, rayWidth / 2f, dir, currentLogicLen); foreach (var hit in hits) { if (hit.collider.gameObject == caster) continue; if (activeLasers.Contains(hit.collider.GetComponent<NetworkObject>())) continue; if (hit.collider.TryGetComponent<IDamageable>(out var damageable)) { ulong targetId = hit.collider.GetComponent<NetworkObject>().NetworkObjectId; string key = $"{laserObj.NetworkObjectId}_{targetId}"; if (!hitRecords.ContainsKey(key) || (Time.time - hitRecords[key] > damageInterval)) { damageable.TakeDamage(damagePerTick, caster.GetComponent<NetworkObject>().NetworkObjectId); hitRecords[key] = Time.time; } } } } yield return null; } foreach (var laser in activeLasers) { if (laser != null && laser.IsSpawned) laser.Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\ExpandingNukeEffect.cs]
using System; using System.Collections; using Unity.Netcode; using UnityEngine; [Serializable] public class ExpandingNukeEffect : SkillEffect { [Header("�˱���ֵ����")] public float damageRadius = 10f; public int killDamage = 9999; public override void Execute(GameObject caster, GameObject target, Vector3 position) { ulong attackerId = 0; if (caster.TryGetComponent<NetworkObject>(out var netObj)) { attackerId = netObj.NetworkObjectId; } Collider[] hits = Physics.OverlapSphere(position, damageRadius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage(killDamage, attackerId); Debug.Log($"[Effect] �˱�����: {hit.name}����� {killDamage} �˺�"); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\FlyingBullet.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class FlyingBullet : SkillEffect { [Header("Ͷ��������")] [SerializeField] private NetworkObject _bulletPrefab; public float speed = 10f; public float maxDistance = 20f; public int damage = 15; public float radius = 1f; [Header("ģ������")] [Tooltip("�����ʸ���򲻶ԣ����糯�ϣ�����������Ϊ (90, 0, 0) �� (-90, 0, 0) ����������")] public Vector3 modelRotationOffset = Vector3.zero; public override void Execute(GameObject caster, GameObject target, Vector3 position) { Vector3 spawnPos = caster.transform.position + Vector3.up * 1.5f; Vector3 direction = (position - caster.transform.position).normalized; direction.y = 0; Quaternion lookRotation = Quaternion.LookRotation(direction); Quaternion finalRotation = lookRotation * Quaternion.Euler(modelRotationOffset); var bulletNetObj = NetworkObjectPool.Instance.GetNetworkObject(_bulletPrefab.gameObject, spawnPos, finalRotation); if(bulletNetObj != null && bulletNetObj.TryGetComponent<ProjectileController>(out var projectileController)) { projectileController.Initialize( direction, speed, 50f, damage, radius, caster.GetComponent<NetworkObject>().NetworkObjectId, caster); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\FollowAreaDamageEffect.cs]
using System; using Unity.Netcode; using UnityEngine; [Serializable] public class FollowAreaDamageEffect : SkillEffect { [Header("Prefab Settings")] [Tooltip("������� DamageAuraController �� NetworkObject ��Ԥ����")] public DamageAuraController auraPrefab; [Header("Aura Stats")] public float radius = 3.0f; public int damagePerTick = 5; public float tickInterval = 0.5f; public float duration = 3.0f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (!NetworkManager.Singleton.IsServer) return; if (auraPrefab == null) { Debug.LogError("[FollowAreaDamageEffect] δ���� Aura Prefab��"); return; } var auraInstance = UnityEngine.Object.Instantiate(auraPrefab, caster.transform.position, Quaternion.identity); auraInstance.Initialize( caster.GetComponent<NetworkObject>(), damagePerTick, radius, tickInterval, duration ); auraInstance.GetComponent<NetworkObject>().Spawn(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\KnockbackEffect.cs]
using System; using UnityEngine; using System.Collections; [Serializable] public class KnockbackEffect : SkillEffect { public float radius = 5f; public float force = 10f; public float stunTime = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { Collider[] hits = Physics.OverlapSphere(caster.transform.position, radius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IKnockBackable>(out var knockCmpnt)) { Vector3 dir = (hit.transform.position - caster.transform.position).normalized; dir.y = 0.5f; knockCmpnt.ApplyKnockbackServer(dir, force); Debug.Log($"������ {hit.name}"); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\SkillEffect.cs]
using System; using System.Collections; using Unity.Netcode; using UnityEngine; [Serializable] public abstract class SkillEffect { [Header("��������")] public string effectName; public abstract void Execute(GameObject caster, GameObject target, Vector3 position); } [Serializable] public class DelayEffect : SkillEffect { public float duration = 1.0f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\TeleportEffect.cs]
using System; using UnityEngine; [Serializable] public class TeleportEffect : SkillEffect { [Header("λ������")] public float distance = 5f; public bool isDash = true; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (!caster.TryGetComponent<ITeleportable>(out var teleportable)) { Debug.LogWarning($"[Effect] {caster.name} does not implement ITeleportable!"); return; } Vector3 direction = (position - caster.transform.position).normalized; direction.y = 0; if (direction == Vector3.zero) direction = caster.transform.forward; Vector3 targetPos = caster.transform.position + direction * distance; teleportable.TeleportServer(targetPos); Debug.Log($"[Effect] Teleport: {caster.name} to {targetPos}"); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillSO\SkillDataSO.cs]
using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using static UnityEngine.CullingGroup; [CreateAssetMenu(fileName = "NewSkill", menuName = "Game/Skill Data")] public class SkillDataSO : ScriptableObject { [SerializeField] AnimationClip _chargeClip; [SerializeField] AnimationClip _activeClip; [SerializeField] AnimationClip _recoveryClip; #region skill base properties [Header("���ܻ�������")] public float coolDown = 1.0f; [Tooltip("ʩ������/�����뾶����ҽ���˷�Χ��ʱ�����˽�ֹͣ�ƶ�����ʼ����")] public float castRadius = 2.0f; #endregion #region skill pahse charge [Header("ǰҡ�׶�")] [Tooltip("ǰҡʱ�䣨�룩����ӦԤ��Ȧʱ��")] public float chargeDuration = 1.5f; [Tooltip("ǰҡ��������")] public string chargeAnimationName = "Idle"; [Tooltip("Ԥ��Ȧ Prefab")] public GameObject warningPrefab; [Tooltip("�����Ӿ���Ч prefab list")] public List<GameObject> chargeVisualPrefabs; public bool ifChargeInteruptable = true; #endregion #region skill pahse active [Header("�ͷŽ׶�")] public float activeDuration; public string activeAnimationName; [SerializeReference, SubclassSelector] public List<SkillEffect> effects = new List<SkillEffect>(); public bool isSelfCentered; public bool ifActiveInteruptable = false; [Tooltip("�����ѡ������ڼ����ͷ��ڼ䣨Active�׶Σ������ƶ�")] public bool canMoveDuringActive = false; #endregion #region skill phase recovery [Header("��ҡ�׶�")] public float recoveryDuration; public string recoveryAnimationName; public bool ifRecoveryInteruptable; #endregion private float _chargeTime; private float _skillTime; private float _recoveryTime; public float ChargeTime => _chargeTime; public float SkillTime => _skillTime; public float RecoveryTime => _recoveryTime; public void Cast(GameObject caster, GameObject target, Vector3 position) { if (caster.TryGetComponent<NetworkBehaviour>(out var networkBehaviour)) { networkBehaviour.StartCoroutine(ExecutionRoutine(caster, target, position)); } } private IEnumerator ExecutionRoutine(GameObject caster, GameObject target, Vector3 position) { foreach (var effect in effects) { if (effect is DelayEffect delayEffect) { yield return new WaitForSeconds(delayEffect.duration); } effect.Execute(caster, target, position); } } public void SetDurations() { chargeDuration = _chargeClip.length; activeDuration = _activeClip.length; recoveryDuration = _recoveryClip.length; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateActive.cs]
using UnityEngine; public class BossStateActive : MonoBehaviour { void Start() { } void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateCharge.cs]
using System.Collections; using UnityEngine; public class BossStateCharge : BossBaseState { private Coroutine _chargeCoroutine; private SkillDataSO _currentSkill; public BossStateCharge(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void OnEnter() { int skillIndex = _stateMachine.PendingSkillIndex; if (skillIndex == -1 || skillIndex >= _controller.Skills.Length) { if (_controller.IsServer) _controller.SetState(BossController.BossMotionState.Idle); return; } _currentSkill = _controller.Skills[skillIndex]; string animName = !string.IsNullOrEmpty(_currentSkill.chargeAnimationName) ? _currentSkill.chargeAnimationName : "Idle"; PlayAnimation(animName, 0.05f); if (_controller.IsServer) { if (_controller.Agent.isOnNavMesh) _controller.Agent.ResetPath(); Vector3 spawnPos = _controller.transform.position; if (!_currentSkill.isSelfCentered && _controller.Target != null) { spawnPos = _controller.Target.transform.position; } _controller.TriggerChargeVisuals(spawnPos, _currentSkill.chargeDuration); _chargeCoroutine = _controller.StartCoroutine(EndChargeRoutine(_currentSkill.chargeDuration)); } } public override void OnUpdate() { if (!_controller.IsServer) return; _controller.RotateTowardsTarget(); if (_currentSkill != null && _currentSkill.ifChargeInteruptable && _controller.Target != null) { float dist = Vector3.Distance(_controller.transform.position, _controller.Target.transform.position); if (dist > _currentSkill.castRadius + 1.0f) { Debug.Log("[Boss] Target escaped charge range, switching to Move."); _controller.SetState(BossController.BossMotionState.Chase); return; } } } public override void OnExit() { if (_chargeCoroutine != null) { _controller.StopCoroutine(_chargeCoroutine); _chargeCoroutine = null; } } private IEnumerator EndChargeRoutine(float duration) { yield return new WaitForSeconds(duration); _controller.SetState(BossController.BossMotionState.Skill); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateDie.cs]
using UnityEngine; public class BossStateDie : BossBaseState { public BossStateDie(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void OnEnter() { PlayAnimation("Die"); if (_controller.IsServer) { if (_controller.Agent.isOnNavMesh) _controller.Agent.isStopped = true; _controller.GetComponent<Collider>().enabled = false; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateIdle.cs]
using UnityEngine; public class BossStateIdle : BossBaseState { public BossStateIdle(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void OnEnter() { PlayAnimation("Idle"); if (_controller.IsServer) { if (_controller.Agent.isOnNavMesh) _controller.Agent.ResetPath(); } } public override void OnUpdate() { if (!_controller.IsServer) return; if (_controller.Target != null) { float dist = Vector3.Distance(_controller.transform.position, _controller.Target.transform.position); if (dist <= _controller.BasicAttackRange) { if (!_controller.TrySelectAndStartAttack()) { } } else { _controller.SetState(BossController.BossMotionState.Chase); } } else { DetectPlayer(); } } private void DetectPlayer() { var hits = Physics.OverlapSphere(_controller.transform.position, _controller.ChaseRange, _controller.ChaseLayer); foreach (var hit in hits) { if (hit.TryGetComponent<PlayerDataContainer>(out var playerData) && !playerData.IsDead) { _controller.SetTarget(hit.GetComponent<Unity.Netcode.NetworkObject>()); return; } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateMove.cs]
using UnityEngine; public class BossStateMove : BossBaseState { private float _repathTimer = 0f; private float _repathInterval = 0.2f; public BossStateMove(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void OnEnter() { PlayAnimation("Walk"); if (_controller.IsServer) { if (_controller.Agent.isOnNavMesh) _controller.Agent.isStopped = false; } } public override void OnUpdate() { if (!_controller.IsServer) return; if (_controller.Target == null) { _controller.SetState(BossController.BossMotionState.Idle); return; } float dist = Vector3.Distance(_controller.transform.position, _controller.Target.transform.position); if (dist > _controller.ChaseRange * 1.5f) { _controller.SetTarget(null); _controller.SetState(BossController.BossMotionState.Idle); return; } if (dist <= _controller.BasicAttackRange) { if (_controller.TrySelectAndStartAttack()) return; } _repathTimer += Time.deltaTime; if (_repathTimer > _repathInterval) { _repathTimer = 0f; if (_controller.Agent.isOnNavMesh) _controller.Agent.SetDestination(_controller.Target.transform.position); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateRecovery.cs]
using System.Collections; using UnityEngine; public class BossStateRecovery : BossBaseState { private Coroutine _recoveryCoroutine; public BossStateRecovery(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void OnEnter() { int skillIndex = _stateMachine.PendingSkillIndex; if (skillIndex == -1 || skillIndex >= _controller.Skills.Length) { if (_controller.IsServer) _controller.SetState(BossController.BossMotionState.Idle); return; } var skillData = _controller.Skills[skillIndex]; string animName = !string.IsNullOrEmpty(skillData.recoveryAnimationName) ? skillData.recoveryAnimationName : "Idle"; PlayAnimation(animName, 0.05f); if (_controller.IsServer) { _recoveryCoroutine = _controller.StartCoroutine(EndRecoveryRoutine(skillData.recoveryDuration)); } } public override void OnExit() { if (_recoveryCoroutine != null) { _controller.StopCoroutine(_recoveryCoroutine); _recoveryCoroutine = null; } } private IEnumerator EndRecoveryRoutine(float duration) { yield return new WaitForSeconds(duration); _stateMachine.PendingSkillIndex = -1; _controller.SetState(BossController.BossMotionState.Idle); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateSkill.cs]
using System.Collections; using UnityEngine; public class BossStateSkill : BossBaseState { private Coroutine _skillCoroutine; public BossStateSkill(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void OnEnter() { int skillIndex = _stateMachine.PendingSkillIndex; if (skillIndex == -1 || skillIndex >= _controller.Skills.Length) { if (_controller.IsServer) _controller.SetState(BossController.BossMotionState.Idle); return; } var skillData = _controller.Skills[skillIndex]; string animName = !string.IsNullOrEmpty(skillData.activeAnimationName) ? skillData.activeAnimationName : "Attack"; PlayAnimation(animName, 0.05f); if (_controller.IsServer) { Vector3 castPos = _controller.Target != null ? _controller.Target.transform.position : _controller.transform.position; if (skillData.isSelfCentered) castPos = _controller.transform.position; skillData.Cast(_controller.gameObject, _controller.Target != null ? _controller.Target.gameObject : null, castPos); _skillCoroutine = _controller.StartCoroutine(EndSkillRoutine(skillData.activeDuration)); } } public override void OnUpdate() { if (!_controller.IsServer) return; } public override void OnExit() { if (_skillCoroutine != null) { _controller.StopCoroutine(_skillCoroutine); _skillCoroutine = null; } } private IEnumerator EndSkillRoutine(float duration) { yield return new WaitForSeconds(duration); _controller.SetState(BossController.BossMotionState.Recovery); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateIdle.cs]
using Unity.Netcode; using UnityEngine; public class EnemyStateIdle : IEnemyState { private EnemyPresentation _view; private NetworkObject _target; public EnemyStateIdle(EnemyPresentation view) { _view = view; } public void Enter() { _view.Animator.Play("IdleNormal"); Debug.Log("������� Idle ״̬"); _target = null; } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateMove.cs]
using Unity.Netcode; using UnityEngine; public class EnemyStateMove : IEnemyState { private EnemyPresentation _view; public EnemyStateMove(EnemyPresentation view) { _view = view; } public void Enter() { Debug.Log("�������׷��״̬"); _view.Animator.Play("WalkFWD"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStatePatrol.cs]
public class EnemyStatePatrol : IEnemyState { public void Enter() { } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateSkillActive.cs]
using UnityEngine; public class EnemyStateSkillActive : IEnemyState { private EnemyPresentation _view; public EnemyStateSkillActive(EnemyPresentation view) { _view = view; } public void Enter() { _view.Animator.CrossFade(_view.SkillAnimationName, 0.1f); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateSkillCharge.cs]
using UnityEngine; public class EnemyStateSkillCharge : MonoBehaviour { void Start() { } void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\IEnemyState.cs]
using UnityEngine; public interface IEnemyState { void Update(); void Enter(); void Exit(); }
[FILE END]
