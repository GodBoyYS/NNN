
[FILE START: Assets\Scripts\Editor\CodeCopyer.cs]
using UnityEngine; using UnityEditor; using System.IO; using System.Text; using System.Text.RegularExpressions; using System.Collections.Generic; public class CodeCopyer : EditorWindow { private class FolderNode { public string Name; public string FullPath; public bool IsSelected; public bool IsExpanded = true; public bool HasCodeFiles; public List<FolderNode> Children = new List<FolderNode>(); public FolderNode Parent; } private FolderNode _rootNode; private Vector2 _scrollPosition; private string _extractedCode = ""; private bool _hasScanned = false; [MenuItem("Tools/Code Copyer")] public static void ShowWindow() { GetWindow<CodeCopyer>("Code Copyer"); } private void OnGUI() { GUILayout.Space(10); GUILayout.Label("������ȡ���� (����������)", EditorStyles.boldLabel); GUILayout.Space(5); if (GUILayout.Button("ɨ�� Assets/Scripts Ŀ¼", GUILayout.Height(30))) { ScanFoldersTree(); } GUILayout.Space(10); if (_hasScanned && _rootNode != null) { GUILayout.Label("��ѡ��Ҫ��ȡ��ģ��:", EditorStyles.label); GUILayout.BeginHorizontal(); if (GUILayout.Button("ȫѡ", GUILayout.Width(60))) SetTreeSelection(_rootNode, true); if (GUILayout.Button("ȫ��ѡ", GUILayout.Width(60))) SetTreeSelection(_rootNode, false); if (GUILayout.Button("ȫ��չ��", GUILayout.Width(70))) SetTreeExpansion(_rootNode, true); if (GUILayout.Button("ȫ���۵�", GUILayout.Width(70))) SetTreeExpansion(_rootNode, false); GUILayout.EndHorizontal(); _scrollPosition = GUILayout.BeginScrollView(_scrollPosition, "box", GUILayout.Height(300)); DrawFolderNode(_rootNode, 0); GUILayout.EndScrollView(); } else if (_hasScanned && _rootNode == null) { GUILayout.Label("δ�ҵ�����������ļ��С�"); } GUILayout.Space(10); if (GUILayout.Button("��ȡ��ѹ������", GUILayout.Height(30))) { ExtractCodesFromTree(); } GUILayout.Space(10); GUILayout.Label("��������:", EditorStyles.boldLabel); var textAreaStyle = new GUIStyle(EditorStyles.textArea); textAreaStyle.wordWrap = true; _extractedCode = EditorGUILayout.TextArea(_extractedCode, textAreaStyle, GUILayout.Height(150)); GUILayout.Space(5); if (GUILayout.Button("Copy All (���Ƶ�������)", GUILayout.Height(40))) { if (!string.IsNullOrEmpty(_extractedCode)) { EditorGUIUtility.systemCopyBuffer = _extractedCode; EditorUtility.DisplayDialog("�ɹ�", "�����Ѹ��Ƶ������壡", "OK"); } else { EditorUtility.DisplayDialog("��ʾ", "û�пɸ��Ƶ�����", "OK"); } } } private void ScanFoldersTree() { string scriptsRoot = Path.Combine(Application.dataPath, "Scripts"); if (!Directory.Exists(scriptsRoot)) { EditorUtility.DisplayDialog("����", "δ�ҵ� 'Assets/Scripts' �ļ��У�", "OK"); return; } _rootNode = BuildDirectoryNode(scriptsRoot, null); if (_rootNode != null && !_rootNode.HasCodeFiles && _rootNode.Children.Count == 0) { _rootNode = null; } _hasScanned = true; } private FolderNode BuildDirectoryNode(string path, FolderNode parent) { bool hasCsFiles = Directory.GetFiles(path, "*.cs", SearchOption.TopDirectoryOnly).Length > 0; string[] subDirs = Directory.GetDirectories(path); List<FolderNode> childrenNodes = new List<FolderNode>(); foreach (var dir in subDirs) { FolderNode child = BuildDirectoryNode(dir, null); if (child != null) { childrenNodes.Add(child); } } if (!hasCsFiles && childrenNodes.Count == 0) { return null; } FolderNode node = new FolderNode { Name = new DirectoryInfo(path).Name, FullPath = path, IsSelected = true, IsExpanded = true, HasCodeFiles = hasCsFiles, Children = childrenNodes, Parent = parent }; foreach (var child in childrenNodes) { child.Parent = node; } return node; } private void DrawFolderNode(FolderNode node, int indentLevel) { GUILayout.BeginHorizontal(); GUILayout.Space(indentLevel * 20); if (node.Children.Count > 0) { node.IsExpanded = EditorGUILayout.Foldout(node.IsExpanded, GUIContent.none, true); } else { GUILayout.Space(13); } bool prevSelected = node.IsSelected; string displayName = node.Name + (node.HasCodeFiles ? " (������)" : ""); node.IsSelected = EditorGUILayout.ToggleLeft(displayName, node.IsSelected); if (node.IsSelected != prevSelected) { SetTreeSelection(node, node.IsSelected); } GUILayout.EndHorizontal(); if (node.IsExpanded) { foreach (var child in node.Children) { DrawFolderNode(child, indentLevel + 1); } } } private void SetTreeSelection(FolderNode node, bool select) { if (node == null) return; node.IsSelected = select; foreach (var child in node.Children) { SetTreeSelection(child, select); } } private void SetTreeExpansion(FolderNode node, bool expand) { if (node == null) return; node.IsExpanded = expand; foreach (var child in node.Children) { SetTreeExpansion(child, expand); } } private void ExtractCodesFromTree() { if (_rootNode == null) return; StringBuilder sb = new StringBuilder(); int totalFiles = 0; CollectCodesRecursive(_rootNode, sb, ref totalFiles); _extractedCode = sb.ToString(); if (totalFiles == 0) { _extractedCode = "δѡ���κΰ���������ļ��С�"; } else { Debug.Log($"��ȡ��ɣ������� {totalFiles} ���ļ���"); } } private void CollectCodesRecursive(FolderNode node, StringBuilder sb, ref int count) { if (node.IsSelected && node.HasCodeFiles) { string[] files = Directory.GetFiles(node.FullPath, "*.cs", SearchOption.TopDirectoryOnly); foreach (string path in files) { ProcessFile(path, sb); count++; } } foreach (var child in node.Children) { CollectCodesRecursive(child, sb, ref count); } } private void ProcessFile(string path, StringBuilder sb) { string content = File.ReadAllText(path, Encoding.UTF8); string compressedContent = CompressCode(content); string relativePath = path.Replace(Application.dataPath, "Assets"); sb.Append($"\n[FILE START: {relativePath}]\n"); sb.Append(compressedContent); sb.Append($"\n[FILE END]\n"); } private string CompressCode(string source) { string noBlockComments = Regex.Replace(source, @"/\*[\s\S]*?\*/", ""); string noLineComments = Regex.Replace(noBlockComments, @" string singleLine = Regex.Replace(noLineComments, @"\s+", " "); return singleLine.Trim(); } }
[FILE END]

[FILE START: Assets\Scripts\Editor\CodeZipper.cs]
using UnityEngine; using UnityEditor; using System.IO; using System.Text; using System.Text.RegularExpressions; public class CodeZipper : EditorWindow { [MenuItem("Tools/Code Zipper")] public static void ShowWindow() { GetWindow<CodeZipper>("Code Zipper"); } private void OnGUI() { GUILayout.Space(20); GUILayout.Label("��Ŀ������ȡ����", EditorStyles.boldLabel); GUILayout.Space(10); EditorGUILayout.HelpBox("�ù��߽���ȡ Assets/Scripts ������ .cs �ļ����Ƴ�ע���뻻�У��������һ���ı��ļ���\n\n�ļ��������ڣ�\n��Ŀ��Ŀ¼/ProjectAllCodesList/", MessageType.Info); GUILayout.Space(20); if (GUILayout.Button("Start Zip (��ȡ��ѹ��)", GUILayout.Height(40))) { ZipCodes(); } } private void ZipCodes() { string scriptsFolder = Path.Combine(Application.dataPath, "Scripts"); if (!Directory.Exists(scriptsFolder)) { EditorUtility.DisplayDialog("����", "δ�ҵ� 'Assets/Scripts' �ļ��У�\n��ȷ����Ĵ��붼�� Scripts Ŀ¼�¡�", "ȷ��"); return; } string[] scriptPaths = Directory.GetFiles(scriptsFolder, "*.cs", SearchOption.AllDirectories); StringBuilder sb = new StringBuilder(); int fileCount = 0; foreach (string path in scriptPaths) { string content = File.ReadAllText(path, Encoding.UTF8); string compressedContent = CompressCode(content); string relativePath = path.Replace(Application.dataPath, "Assets"); sb.Append($"\n[FILE START: {relativePath}]\n"); sb.Append(compressedContent); sb.Append($"\n[FILE END]\n"); fileCount++; } string projectRoot = Directory.GetParent(Application.dataPath).FullName; string targetDir = Path.Combine(projectRoot, "ProjectAllCodesList"); if (!Directory.Exists(targetDir)) { Directory.CreateDirectory(targetDir); } string outputFileName = GetNextVersionFileName(targetDir); string finalPath = Path.Combine(targetDir, outputFileName); File.WriteAllText(finalPath, sb.ToString(), Encoding.UTF8); EditorUtility.DisplayDialog("���", $"�ɹ���ȡ {fileCount} ���ű��ļ���\n(��Դ: Assets/Scripts)\n\n�ѱ�����:\n{finalPath}", "ȷ��"); EditorUtility.RevealInFinder(finalPath); } private string CompressCode(string source) { string noBlockComments = Regex.Replace(source, @"/\*[\s\S]*?\*/", ""); string noLineComments = Regex.Replace(noBlockComments, @" string singleLine = Regex.Replace(noLineComments, @"\s+", " "); return singleLine.Trim(); } private string GetNextVersionFileName(string folderPath) { string baseName = "ProjectAllCodesV"; string extension = ".txt"; int version = 1; while (true) { string fileName = $"{baseName}{version}{extension}"; string fullPath = Path.Combine(folderPath, fileName); if (!File.Exists(fullPath)) { return fileName; } version++; } } }
[FILE END]

[FILE START: Assets\Scripts\Editor\SubclassSelectorDrawer.cs]
using System; using System.Linq; using UnityEditor; using UnityEngine; [CustomPropertyDrawer(typeof(SubclassSelectorAttribute))] public class SubclassSelectorDrawer : PropertyDrawer { public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { if (property.propertyType != SerializedPropertyType.ManagedReference) { EditorGUI.PropertyField(position, property, label, true); return; } var labelRect = new Rect(position.x, position.y, EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight); EditorGUI.LabelField(labelRect, label); var buttonRect = new Rect(position.x + EditorGUIUtility.labelWidth, position.y, position.width - EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight); string typeName = GetTypeName(property); if (EditorGUI.DropdownButton(buttonRect, new GUIContent(typeName), FocusType.Passive)) { ShowTypeMenu(property); } EditorGUI.PropertyField(position, property, GUIContent.none, true); } private void ShowTypeMenu(SerializedProperty property) { var menu = new GenericMenu(); string typeName = property.managedReferenceFieldTypename; if (string.IsNullOrEmpty(typeName)) return; var splitTypeString = typeName.Split(' '); var assemblyName = splitTypeString[0]; var className = splitTypeString[1]; var assembly = AppDomain.CurrentDomain.GetAssemblies() .FirstOrDefault(a => a.GetName().Name == assemblyName); if (assembly == null) { Debug.LogError($"[SubclassSelector] �Ҳ��� Assembly: {assemblyName}"); return; } Type baseType = assembly.GetType(className); if (baseType == null) { Debug.LogError($"[SubclassSelector] �Ҳ�������: {className}"); return; } var types = AppDomain.CurrentDomain.GetAssemblies() .SelectMany(s => s.GetTypes()) .Where(p => baseType.IsAssignableFrom(p) && p.IsClass && !p.IsAbstract); menu.AddItem(new GUIContent("None (Null)"), false, () => { property.managedReferenceValue = null; property.serializedObject.ApplyModifiedProperties(); }); foreach (var type in types) { string menuLabel = type.Name; menu.AddItem(new GUIContent(menuLabel), false, () => { property.managedReferenceValue = Activator.CreateInstance(type); property.serializedObject.ApplyModifiedProperties(); }); } menu.ShowAsContext(); } private string GetTypeName(SerializedProperty property) { if (string.IsNullOrEmpty(property.managedReferenceFullTypename)) return "Select Type..."; return property.managedReferenceFullTypename.Split('.').Last(); } public override float GetPropertyHeight(SerializedProperty property, GUIContent label) { return EditorGUI.GetPropertyHeight(property, label, true); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\CharacterDatabaseSO.cs]
using UnityEngine; using Unity.Netcode; using System.Collections.Generic; [CreateAssetMenu(fileName = "CharacterDatabase", menuName = "Game/Character Database")] public class CharacterDatabaseSO : ScriptableObject { public List<NetworkObject> characterPrefabs; public NetworkObject GetPrefabById(int id) { if (id >= 0 && id < characterPrefabs.Count) { return characterPrefabs[id]; } Debug.Log("��ȡĬ�Ͻ�ɫ"); return characterPrefabs[0]; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\DestructableCrate.cs]
using Unity.Netcode; using UnityEngine; public class DestructableCrate : NetworkBehaviour, IDamageable { [SerializeField] private NetworkObject _lootPrefab; private readonly NetworkVariable<int> _hp = new NetworkVariable<int>( 50, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public void TakeDamage(int amount, ulong attackerId) { _hp.Value -= amount; if( _hp.Value <= 0) { if(_lootPrefab != null) { var lootInstance = Instantiate(_lootPrefab, transform.position, Quaternion.identity); lootInstance.Spawn(); } GetComponent<NetworkObject>().Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\GameLifecycleManager.cs]
using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using UnityEngine.SceneManagement; public class GameLifecycleManager : NetworkBehaviour { [SerializeField] private BossController bossInstance; private List<PlayerNetworkCore> activePlayers = new List<PlayerNetworkCore>(); private bool isGameEnded = false; public static GameLifecycleManager Instance { get; private set; } public void Awake() { Instance = this; } public override void OnNetworkSpawn() { if (!IsServer) return; NetworkManager.Singleton.OnClientConnectedCallback += HandleClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback += HandleClientDisconnect; foreach (var client in NetworkManager.Singleton.ConnectedClientsList) { if (client.PlayerObject != null) { var playerCore = client.PlayerObject.GetComponent<PlayerNetworkCore>(); RegisterPlayer(playerCore); } } if (bossInstance != null) { bossInstance.OnBossDied += HandleBossDefeat; } } public override void OnNetworkDespawn() { if (!IsServer) return; if (NetworkManager.Singleton != null) { NetworkManager.Singleton.OnClientConnectedCallback -= HandleClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback -= HandleClientDisconnect; } } public void RegisterPlayer(PlayerNetworkCore player) { if (!IsServer || player == null) return; if (!activePlayers.Contains(player)) { activePlayers.Add(player); player.OnPlayerDied += HandlePlayerDeath; Debug.Log($"[Manager] Player Registered. ID: {player.OwnerClientId}. Total Players: {activePlayers.Count}"); } } public void UnregisterPlayer(PlayerNetworkCore player) { if (!IsServer || player == null) return; if (activePlayers.Contains(player)) { player.OnPlayerDied -= HandlePlayerDeath; activePlayers.Remove(player); Debug.Log($"[Manager] Player Unregistered. ID: {player.OwnerClientId}. Remaining: {activePlayers.Count}"); } } private void HandlePlayerDeath(PlayerNetworkCore deadPlayer) { if (isGameEnded) return; Debug.Log($"[Manager] HandlePlayerDeath Triggered for Player {deadPlayer.OwnerClientId}"); int aliveCount = 0; foreach (var p in activePlayers) { if (p != null && !p.IsDead) { aliveCount++; } } Debug.Log($"[Manager] Alive Count: {aliveCount}"); if (aliveCount <= 0) { EndGame(false); } } private void HandleClientConnected(ulong clientId) { if (NetworkManager.Singleton.ConnectedClients.TryGetValue(clientId, out var client)) { if (client.PlayerObject != null) { RegisterPlayer(client.PlayerObject.GetComponent<PlayerNetworkCore>()); } } } private void HandleClientDisconnect(ulong clientId) { } private void HandleBossDefeat() { if (isGameEnded) return; EndGame(true); } private void EndGame(bool isVictory) { isGameEnded = true; Debug.Log(isVictory ? "VICTORY! Loading WinScene..." : "DEFEAT! Loading Init..."); if (isVictory) { SceneManager.LoadScene("WinScene", LoadSceneMode.Single); } else { NetworkManager.Singleton.Shutdown(); SceneManager.LoadScene("Init", LoadSceneMode.Single); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\InteractCube.cs]
using UnityEngine; public class InteractCube : MonoBehaviour, IInteractable { private bool _stateBig = false; public string InteractionPrompt => "PickUp"; public void Interact(GameObject source) { if (_stateBig) { transform.localScale = Vector3.one * 2.0f; _stateBig = false; } else { transform.localScale = Vector3.one; _stateBig = true; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\InteracteHeal.cs]
using Unity.Netcode; using UnityEngine; public class InteracteHeal : NetworkBehaviour, IInteractable { public string InteractionPrompt => "Eat"; public void Interact(GameObject source) { ulong sourceId = source.GetComponent<NetworkObject>().NetworkObjectId; RequestInteractServerRpc(sourceId); } [ServerRpc(RequireOwnership = false)] private void RequestInteractServerRpc(ulong sourceId) { if(NetworkManager.SpawnManager.SpawnedObjects.TryGetValue(sourceId, out var sourceObject)) { if (Vector3.Distance(transform.position, sourceObject.transform.position) > 3.0f) return; if(sourceObject.TryGetComponent<PlayerNetworkHealth>(out var health)) { health.ServerHeal(10); GetComponent<NetworkObject>().Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\PickupItem.cs]
using Unity.Netcode; using UnityEngine; public class PickupItem : NetworkBehaviour, IInteractable { private int points = 10; public string InteractionPrompt => "Pickup"; public void Interact(GameObject source) { RequestPickupServerRpc(source.GetComponent<NetworkObject>().NetworkObjectId); } [ServerRpc(RequireOwnership = false)] private void RequestPickupServerRpc(ulong sourceId) { if (NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(sourceId, out var sourceNetObj)) { if (Vector3.Distance(transform.position, sourceNetObj.transform.position) > 3.0f) return; if (sourceNetObj.TryGetComponent<PlayerNetworkCore>(out var core)) { core.AddPointsServer(points); core.AddItem(gameObject.name); GetComponent<NetworkObject>().Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\PotionSpawner.cs]
using Unity.Netcode; using UnityEngine; public class PotionSpawner : NetworkBehaviour { [SerializeField] private NetworkObject potionPrefab; [SerializeField] private Transform[] spawnPoints; public override void OnNetworkSpawn() { if (IsServer) { foreach (var point in spawnPoints) { SpawnPotion(point.position); } } } private void SpawnPotion(Vector3 position) { if (potionPrefab == null) return; var instance = Instantiate(potionPrefab, position, Quaternion.identity); instance.Spawn(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\testBossSkill.cs]
using Unity.Netcode; using UnityEngine; public class testBossSkill : NetworkBehaviour { public SkillDataSO[] skills; public LayerMask goundLayer; void Start() { } void Update() { if (Input.GetMouseButtonDown(0)) { if( Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hit, 1000f, goundLayer)) { var targetpos = hit.point; transform.position = targetpos; } } if (Input.GetKeyDown(KeyCode.I)) { Debug.Log("boss�ͷż���2"); skills[0].Cast(gameObject, null, transform.position); } if (Input.GetKeyDown(KeyCode.O)) { Debug.Log("boss�ͷŴ���"); skills[1].Cast(gameObject, null, transform.position); } if (Input.GetKeyDown(KeyCode.P)) { Debug.Log("boss�ͷ�����"); skills[2].Cast(gameObject, null, transform.position); } } }
[FILE END]

[FILE START: Assets\Scripts\InitScene\ConnectionManager.cs]
using System; using System.Collections.Generic; using System.Text; using Unity.Netcode; using UnityEngine; using UnityEngine.SceneManagement; public class ConnectionManager : MonoBehaviour { [Header("Settings")] [SerializeField] private CharacterDatabaseSO characterDatabase; [SerializeField] private string gameSceneName = "Game"; private Dictionary<ulong, int> _clientSelectionData = new Dictionary<ulong, int>(); private void Start() { DontDestroyOnLoad(this); } private void OnEnable() { if (NetworkManager.Singleton != null) { SubscribeEvents(); } } private void SubscribeEvents() { UnsubscribeEvents(); NetworkManager.Singleton.ConnectionApprovalCallback += ApprovalCheck; NetworkManager.Singleton.OnClientConnectedCallback += OnClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback += OnClientDisconnect; Debug.Log("ConnectionManager: �����¼����ĳɹ���"); } private void UnsubscribeEvents() { if (NetworkManager.Singleton == null) return; NetworkManager.Singleton.ConnectionApprovalCallback -= ApprovalCheck; NetworkManager.Singleton.OnClientConnectedCallback -= OnClientConnected; NetworkManager.Singleton.OnClientDisconnectCallback -= OnClientDisconnect; if (NetworkManager.Singleton.SceneManager != null) { NetworkManager.Singleton.SceneManager.OnLoadEventCompleted -= OnSceneLoadComplete; } } private void OnDestroy() { UnsubscribeEvents(); } public void StartHostWithCharacter(int characterIndex) { SubscribeEvents(); var payload = Encoding.ASCII.GetBytes(characterIndex.ToString()); NetworkManager.Singleton.NetworkConfig.ConnectionData = payload; NetworkManager.Singleton.NetworkConfig.PlayerPrefab = null; Debug.Log($"1. [Host] ׼�������ѡ���ɫ: {characterIndex}"); if (NetworkManager.Singleton.StartHost()) { Debug.Log("2. [Host] ����ɹ���"); if (NetworkManager.Singleton.SceneManager != null) { NetworkManager.Singleton.SceneManager.OnLoadEventCompleted += OnSceneLoadComplete; Debug.Log(" -> �����¼����ĳɹ�"); NetworkManager.Singleton.SceneManager.LoadScene(gameSceneName, LoadSceneMode.Single); } else { Debug.LogError("!!! ��������SceneManager ��ȻΪ�գ����� Inspector ���Ƿ�ѡ�� 'Enable Scene Management' !!!"); } } } public void StartClientWithCharacter(int characterIndex) { SubscribeEvents(); var payload = Encoding.ASCII.GetBytes(characterIndex.ToString()); NetworkManager.Singleton.NetworkConfig.ConnectionData = payload; NetworkManager.Singleton.NetworkConfig.PlayerPrefab = null; Debug.Log($"1. [Client] ׼�����ӣ�ѡ���ɫ: {characterIndex}"); NetworkManager.Singleton.StartClient(); } private void ApprovalCheck(NetworkManager.ConnectionApprovalRequest request, NetworkManager.ConnectionApprovalResponse response) { int charId = 0; if (request.Payload != null) { int.TryParse(Encoding.ASCII.GetString(request.Payload), out charId); } if (_clientSelectionData.ContainsKey(request.ClientNetworkId)) _clientSelectionData[request.ClientNetworkId] = charId; else _clientSelectionData.Add(request.ClientNetworkId, charId); Debug.Log($"3. [Server] ����ͨ��: �ͻ���ID {request.ClientNetworkId} ѡ���˽�ɫ {charId}"); response.Approved = true; response.CreatePlayerObject = false; } private void OnClientConnected(ulong clientId) { if (!NetworkManager.Singleton.IsServer) return; Debug.Log($"4. [Server] �ͻ��� {clientId} ���ӳɹ�����ǰ����: {SceneManager.GetActiveScene().name}"); if (SceneManager.GetActiveScene().name == gameSceneName) { Debug.Log($" -> �Ѿ�����Ϸ������ֱ�����ɽ�ɫ�� {clientId}"); SpawnPlayer(clientId); } else { Debug.Log($" -> ���� {SceneManager.GetActiveScene().name}���ݲ����ɣ��ȴ���������..."); } } private void OnSceneLoadComplete(string sceneName, LoadSceneMode loadSceneMode, List<ulong> clientsCompleted, List<ulong> clientsTimedOut) { if (!NetworkManager.Singleton.IsServer) return; if (!sceneName.Contains(gameSceneName)) return; Debug.Log($"5. [Server] ���� {sceneName} ������ϣ���ʼ��鲢���ɽ�ɫ..."); foreach (ulong clientId in NetworkManager.Singleton.ConnectedClientsIds) { if (NetworkManager.Singleton.ConnectedClients[clientId].PlayerObject == null) { Debug.Log($" -> Ϊ��� {clientId} ������ɫ"); SpawnPlayer(clientId); } } } private void SpawnPlayer(ulong clientId) { int charId = _clientSelectionData.ContainsKey(clientId) ? _clientSelectionData[clientId] : 0; NetworkObject prefab = characterDatabase.GetPrefabById(charId); if (prefab == null) return; Vector3 pos = new Vector3(clientId * 2, 1, 0); GameObject instance = Instantiate(prefab.gameObject, pos, Quaternion.identity); NetworkObject netObj = instance.GetComponent<NetworkObject>(); netObj.SpawnAsPlayerObject(clientId, true); Debug.Log($"6. [Server] �ɹ����ɽ�ɫ {charId} ����� {clientId}"); } private void OnClientDisconnect(ulong clientId) { if (NetworkManager.Singleton.IsServer) _clientSelectionData.Remove(clientId); } }
[FILE END]

[FILE START: Assets\Scripts\InitScene\InitSceneController.cs]
using UnityEngine; using UnityEngine.SceneManagement; public class InitSceneController : MonoBehaviour { void Start() { } void Update() { } public void OnStartClicke() { SceneManager.LoadScene("Game"); } }
[FILE END]

[FILE START: Assets\Scripts\WinScene\WinSceneController.cs]
using UnityEngine; using UnityEngine.SceneManagement; public class WinSceneController : MonoBehaviour { void Start() { } void Update() { } public void OnBtnBackToInitClicked() { SceneManager.LoadScene("Init"); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Camera\GameCameraManager.cs]
using UnityEngine; using Unity.Netcode; using Unity.Cinemachine; public class GameCameraManager : MonoBehaviour { public static GameCameraManager Instance { get; private set; } [Header("Cinemachine Components")] [SerializeField] private CinemachineCamera virtualCamera; [SerializeField] private CinemachineImpulseSource impulseSource; private void Awake() { Instance = this; } public void SetFollowTarget(Transform target) { if (virtualCamera != null) { virtualCamera.Follow = target; Debug.Log($"[Camera] Now following {target.name}"); } } public void ShakeCamera(float force) { if (impulseSource != null) { impulseSource.GenerateImpulse(force); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Camera\TestShake.cs]
using UnityEngine; using Unity.Cinemachine; public class TestShake : MonoBehaviour { public CinemachineCamera targetCamera; public NoiseSettings noiseProfile; void Update() { if (Input.GetKeyDown(KeyCode.T)) { Debug.Log("ǿ�Ʋ����𶯣�"); if (targetCamera != null && noiseProfile != null) { } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Combat\DamageFlash.cs]
using System.Collections; using UnityEngine; public class DamageFlash : MonoBehaviour { [Header("Settings")] [SerializeField] private Color flashColor = Color.white; [SerializeField] private float duration = 0.1f; private SkinnedMeshRenderer[] _renderers; private MaterialPropertyBlock _propBlock; private Coroutine _flashRoutine; private void Awake() { _renderers = GetComponentsInChildren<SkinnedMeshRenderer>(); _propBlock = new MaterialPropertyBlock(); } public void TriggerFlash() { if (_flashRoutine != null) StopCoroutine(_flashRoutine); _flashRoutine = StartCoroutine(FlashRoutine()); } private IEnumerator FlashRoutine() { foreach (var r in _renderers) { r.GetPropertyBlock(_propBlock); _propBlock.SetColor("_EmissionColor", flashColor * 5f); r.SetPropertyBlock(_propBlock); } yield return new WaitForSeconds(duration); foreach (var r in _renderers) { r.GetPropertyBlock(_propBlock); _propBlock.SetColor("_EmissionColor", Color.black); r.SetPropertyBlock(_propBlock); } _flashRoutine = null; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Combat\HitStopManager.cs]
using System.Collections; using UnityEngine; public class HitStopManager : MonoBehaviour { public static HitStopManager Instance { get; private set; } private bool _isWaiting = false; private void Awake() { Instance = this; } public void TriggerHitStop(float duration = 0.05f, float timeScale = 0.1f) { if (_isWaiting) return; StartCoroutine(HitStopRoutine(duration, timeScale)); } private IEnumerator HitStopRoutine(float duration, float targetScale) { _isWaiting = true; float original = Time.timeScale; Time.timeScale = targetScale; yield return new WaitForSecondsRealtime(duration); Time.timeScale = original; _isWaiting = false; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\StateMachine.cs]
using UnityEngine; public abstract class StateMachine { } public class BossStateMachine { public BossBaseState CurrentState { get; private set; } public BossStateIdle StateIdle; public BossStateMove StateMove; public BossStateCharge StateCharge; public BossStateSkill StateSkill; public BossStateDie StateDie; public BossStateMachine(BossController controller) { StateIdle = new BossStateIdle(controller, this); StateMove = new BossStateMove(controller, this); StateCharge = new BossStateCharge(controller, this); StateSkill = new BossStateSkill(controller, this); StateDie = new BossStateDie(controller, this); } public void Update() { CurrentState?.Update(); } public void ChangeState(BossBaseState newState) { if (newState == null || newState == CurrentState) return; CurrentState?.Exit(); CurrentState = newState; CurrentState.Enter(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IDamageable.cs]
using UnityEngine; public interface IDamageable { void TakeDamage(int amount, ulong attackerId); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IInteractable.cs]
using UnityEngine; public interface IInteractable { string InteractionPrompt { get; } void Interact(GameObject source); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Interfaces\IKnockBackable.cs]
using UnityEngine; public interface IKnockBackable { void ApplyKnockbackServer(Vector3 forceDir, float forceStrength); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\NoUse\PlayerController.cs]
using System; using Unity.Netcode; using UnityEditor.PackageManager; using UnityEngine; using UnityEngine.Rendering; public class PlayerController : NetworkBehaviour { public enum MotionState : byte { Idle = 0, Moving = 1, Attack = 2 } private readonly NetworkVariable<MotionState> _motionState = new NetworkVariable<MotionState>( MotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public MotionState Motion => _motionState.Value; [Header("Settings")] [SerializeField] private float moveSpeed = 5f; [SerializeField] private float rotateSpeed = 10f; [SerializeField] private float attackDistance = 20f; [SerializeField] private LayerMask groundLayer; [SerializeField] private LayerMask interactLayer; private IPlayerState currentState; private Vector3 _serverTargetPosition; public Camera MainCamera { get; private set; } public Rigidbody Rigidbody { get; private set; } public CapsuleCollider CapsuleCollider { get; private set; } public float MoveSpeed => moveSpeed; public float RotationSpeed => rotateSpeed; public Vector3 ServerTargetPosition => _serverTargetPosition; private PlayerNetworkHealth _healthComponent; public LayerMask GroundLayer => groundLayer; public LayerMask InteractLayer => interactLayer; private void Awake() { MainCamera = Camera.main; Rigidbody = GetComponent<Rigidbody>(); CapsuleCollider = GetComponent<CapsuleCollider>(); _healthComponent = GetComponent<PlayerNetworkHealth>(); } public override void OnNetworkSpawn() { if (IsServer) { _serverTargetPosition = transform.position; _motionState.Value = MotionState.Idle; _healthComponent.OnHealthChanged += CheckDeath; } if (IsOwner) { BindLocalPlayerUI(); _motionState.OnValueChanged += OnMotionStateChanged; AppyMotionState(_motionState.Value); } } private void OnMotionStateChanged(MotionState oldState, MotionState newState) { AppyMotionState(newState); } private void AppyMotionState(MotionState state) { if (!IsOwner) return; switch (state) { case MotionState.Idle: if (currentState is PlayerStateIdle) return; break; case MotionState.Moving: if (currentState is PlayerStateMove) return; break; } } public override void OnNetworkDespawn() { if (IsOwner && HealthBarUI.Instance != null) { _healthComponent.OnHealthChanged -= HealthBarUI.Instance.UpdateViewHealth; _motionState.OnValueChanged -= OnMotionStateChanged; } if (IsServer) { _healthComponent.OnHealthChanged -= CheckDeath; } } void Update() { if (IsOwner) { currentState?.Update(); } if (IsServer) { ProcessMovement(); } } public void ChangeState(IPlayerState nextState) { if (currentState != null) currentState.Exit(); currentState = nextState; currentState.Enter(); } private void BindLocalPlayerUI() { var ui = HealthBarUI.Instance; if (ui == null) { Debug.LogError("Scene creates Player but HealthBarUI is missing!"); return; } _healthComponent.OnHealthChanged += ui.UpdateViewHealth; ui.UpdateViewHealth(_healthComponent.MaxHealth, _healthComponent.MaxHealth); } #region StateRequest methods public void RequestMove(Vector3 position) { if (IsOwner) { RequestMoveServerRpc(position); } } public void RequestStop() { if (IsOwner) { RequestStopServerRpc(); } } [ServerRpc] private void RequestMoveServerRpc(Vector3 pos) { _serverTargetPosition = new Vector3(pos.x, transform.position.y, pos.z); _motionState.Value = MotionState.Moving; } [ServerRpc] private void RequestStopServerRpc() { ServerStopMove(); } #endregion #region movement methods private void ProcessMovement() { if (_motionState.Value != MotionState.Moving) return; float step = moveSpeed * Time.deltaTime; transform.position = Vector3.MoveTowards(transform.position, _serverTargetPosition, step); Vector3 direction = _serverTargetPosition - transform.position; if (direction != Vector3.zero) { Quaternion targetRot = Quaternion.LookRotation(direction); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime); } if (Vector3.Distance(transform.position, _serverTargetPosition) < 0.01f) { ServerStopMove(); } } private void ServerStopMove() { if (_motionState.Value == MotionState.Idle) return; _motionState.Value = MotionState.Idle; } #endregion #region death private void CheckDeath(int currentHealth, int maxHealth) { if (currentHealth <= 0 && !(currentState is PlayerStateDie)) { BroadcastDeathClientRpc(); } } [ClientRpc] private void BroadcastDeathClientRpc() { } #endregion private void OnCollisionEnter(Collision collision) { if (!IsServer) return; if(collision != null && collision.gameObject.CompareTag("Player")) { ServerStopMove(); } } public void CheckInteract(RaycastHit hit) { switch (hit.collider.gameObject.tag) { case "Player": Debug.Log("点击到了玩家"); break; default: Debug.Log("点击到了无法交互的物体"); break; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\DamageText.cs]
using System.Collections; using TMPro; using UnityEngine; using UnityEngine.Pool; public class DamageText : MonoBehaviour { [SerializeField] private TMP_Text damageLable; private IObjectPool<DamageText> _pool; public void SetupPool(IObjectPool<DamageText> pool) { _pool = pool; } public void Setup(int damageAmount) { damageLable.text = damageAmount.ToString(); StartCoroutine(ReturnToPoolAfterTime(3.0f)); } private IEnumerator ReturnToPoolAfterTime(float time) { yield return new WaitForSeconds(time); if(_pool != null) { _pool.Release(this); } else { Destroy(gameObject); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\DamageTextManager.cs]
using System.Net.NetworkInformation; using UnityEngine; using UnityEngine.Pool; public class DamageTextManager : MonoBehaviour { public static DamageTextManager Instance { get; private set; } [Header("����")] [SerializeField] private DamageText textPrefab; [SerializeField] private Canvas gameCanvas; private ObjectPool<DamageText> _pool; private Camera _camera; private void Awake() { Instance = this; _camera = Camera.main; _pool = new ObjectPool<DamageText>( createFunc: CreateText, actionOnGet: OnGetText, actionOnRelease: OnReleaseText, actionOnDestroy: OnDestroyText, defaultCapacity:20, maxSize:100 ); } private DamageText CreateText() { var instance = Instantiate(textPrefab, transform); instance.SetupPool(_pool); return instance; } private void OnGetText(DamageText text) { text.gameObject.SetActive(true); text.transform.localScale = Vector3.one; } private void OnReleaseText(DamageText text) { text.gameObject.SetActive(false); } private void OnDestroyText(DamageText text) { Destroy(text.gameObject); } public void ShowDamage(int amount, Vector3 worldPos) { if (textPrefab == null) return; var instance = _pool.Get(); Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPos); instance.transform.position = screenPos; instance.Setup(amount); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\HealthBarUI.cs]
using UnityEngine; using UnityEngine.UI; public class HealthBarUI : MonoBehaviour { public static HealthBarUI Instance { get; private set; } [SerializeField] private Slider healthSlider; [SerializeField] private Image QSkill; private void Awake() { Instance = this; } public void UpdateViewHealth(int current, int max) { if (healthSlider == null) return; healthSlider.value = (float)current / max; } public void UpdateViewQskill(bool activeBefore, bool activeCurrent) { if(QSkill == null) return; QSkill.color = activeCurrent ? Color.yellow : Color.red; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\InteractableTest.cs]
using Unity.Netcode; using UnityEngine; public class InteractableTest : NetworkBehaviour { private NetworkVariable<float> _health = new NetworkVariable<float>( 100f, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public override void OnNetworkSpawn() { _health.OnValueChanged += OnHealthChanged; } public override void OnNetworkDespawn() { _health.OnValueChanged -= OnHealthChanged; } private void OnHealthChanged(float prev, float cur) { if (!IsServer) return; if(cur <= 0f) { NetworkObject.Despawn(); } } [ServerRpc] public void ServerTakeDamageServerRpc(float damage) { if(!IsServer) return; _health.Value -= damage; Debug.Log("ľ׮�ܵ��˺�"); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\ChargeGrowingVisual.cs]
using UnityEngine; using System.Collections; public class ChargeGrowingVisual : MonoBehaviour { [Header("�Ӿ�����")] [Tooltip("�������յ�Ŀ���С (Local Scale)")] [SerializeField] private float _targetScale = 20.0f; [Tooltip("�������ߣ��ñ����̸���Ȼ")] [SerializeField] private AnimationCurve _growthCurve = AnimationCurve.Linear(0, 0, 1, 1); public void SetDuration(float duration) { transform.localScale = Vector3.zero; StartCoroutine(GrowthRoutine(duration)); } private IEnumerator GrowthRoutine(float duration) { float timer = 0f; while (timer < duration) { timer += Time.deltaTime; float progress = Mathf.Clamp01(timer / duration); float curveValue = _growthCurve.Evaluate(progress); transform.localScale = Vector3.one * (_targetScale * curveValue); yield return null; } transform.localScale = Vector3.one * _targetScale; Destroy(gameObject); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\LaserVisual.cs]
using UnityEngine; using Unity.Netcode; [RequireComponent(typeof(LineRenderer))] public class LaserVisual : NetworkBehaviour { private LineRenderer _line; private float _growthDuration; private float _startLen; private float _maxLen; private bool _isGrowing = false; private float _timer = 0f; private void Awake() { _line = GetComponent<LineRenderer>(); _line.useWorldSpace = false; } [ClientRpc] public void InitializeLaserClientRpc(float startLen, float maxLen, float growthDuration, float width) { _startLen = startLen; _maxLen = maxLen; _growthDuration = growthDuration; _line.startWidth = width; _line.endWidth = width; _line.SetPosition(0, Vector3.zero); _line.SetPosition(1, Vector3.forward * startLen); _timer = 0f; _isGrowing = true; } private void Update() { if (!_isGrowing) return; _timer += Time.deltaTime; float progress = Mathf.Clamp01(_timer / _growthDuration); float currentLen = Mathf.Lerp(_startLen, _maxLen, progress); _line.SetPosition(1, Vector3.forward * currentLen); if (progress >= 1.0f) { _isGrowing = false; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\NukeZoneVisual.cs]
using Unity.Netcode; using UnityEngine; using System.Collections; public class NukeZoneVisual : NetworkBehaviour { private float _targetScale; private float _duration; private bool _isRunning = false; private float _timer = 0f; [ClientRpc] public void StartExpansionClientRpc(float targetRadius, float duration) { _targetScale = targetRadius * 2.0f; _duration = duration; _timer = 0f; _isRunning = true; transform.localScale = Vector3.zero; } private void Update() { if (!_isRunning) return; _timer += Time.deltaTime; float progress = _timer / _duration; if (progress >= 1.0f) { transform.localScale = Vector3.one * _targetScale; _isRunning = false; } else { transform.localScale = Vector3.Lerp(Vector3.zero, Vector3.one * _targetScale, progress); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\ProjectileController.cs]
using System; using Unity.Netcode; using UnityEngine; public class ProjectileController : NetworkBehaviour { private float _speed; private float _maxDistance; private int _damage; private float _radius; private ulong _attackerId; private GameObject _caster; private Vector3 _startPos; private Vector3 _direction; private float _traveledDistance; private bool _isInitialized = false; public void Initialize(Vector3 direction, float speed, float maxDistance, int damage, float radius, ulong attackerId, GameObject caster) { _direction = direction; _speed = speed; _maxDistance = maxDistance; _damage = damage; _radius = radius; _attackerId = attackerId; _caster = caster; _startPos = transform.position; _traveledDistance = 0f; _isInitialized = true; } private void Update() { if (!IsServer || !_isInitialized) return; ProcessMovement(); } private void ProcessMovement() { float step = _speed * Time.deltaTime; transform.position += _direction * step; _traveledDistance += step; if (_traveledDistance >= _maxDistance) { DespawnObject(); return; } if (Physics.CheckSphere(transform.position, _radius, LayerMask.GetMask("Player", "Enemy"))) { Collider[] hits = Physics.OverlapSphere(transform.position, _radius); bool hitValidTarget = false; foreach (var hit in hits) { if (hit.gameObject == _caster) continue; if (hit.gameObject == gameObject) continue; if (hit.TryGetComponent<IDamageable>(out var damageCmp)) { damageCmp.TakeDamage(_damage, _attackerId); Debug.Log($"[Projectile] Hit {hit.name}, caused {_damage}"); hitValidTarget = true; } } if (hitValidTarget) { DespawnObject(); } } } private void DespawnObject() { if (NetworkObject != null && NetworkObject.IsSpawned) { NetworkObject.Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillIndicator.cs]
using UnityEngine; using UnityEngine.UI; using System.Collections; public class SkillIndicator : MonoBehaviour { [Header("UI �������")] [SerializeField] private Image _fillImage; public void Initialize(float duration, float diameter) { transform.localScale = Vector3.one * diameter; StartCoroutine(PlayFillAnimationRoutine(duration)); } private IEnumerator PlayFillAnimationRoutine(float duration) { float timer = 0f; _fillImage.fillAmount = 0f; while (timer < duration) { timer += Time.deltaTime; _fillImage.fillAmount = timer / duration; yield return null; } _fillImage.fillAmount = 1f; yield return new WaitForSeconds(0.1f); Destroy(gameObject); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\BufferedHealthBar.cs]
using System.Collections; using UnityEngine; using UnityEngine.UI; public class BufferedHealthBar : MonoBehaviour { [Header("UI References")] [SerializeField] private Slider _mainSlider; [SerializeField] private Slider _bufferSlider; [Header("Settings")] [SerializeField] private float _bufferDropSpeed = 0.5f; [SerializeField] private float _bufferDelay = 0.5f; private float _targetFillAmount; private float _delayTimer; private void Awake() { if (_mainSlider == null) _mainSlider = GetComponent<Slider>(); } public void UpdateHealth(int current, int max) { float fillAmount = (float)current / max; _targetFillAmount = fillAmount; _mainSlider.value = _targetFillAmount; if (_bufferSlider != null) { if (_mainSlider.value > _bufferSlider.value) { _bufferSlider.value = _mainSlider.value; } else { _delayTimer = _bufferDelay; } } } private void Update() { if (_bufferSlider == null) return; if (_bufferSlider.value > _mainSlider.value) { if (_delayTimer > 0) { _delayTimer -= Time.deltaTime; return; } _bufferSlider.value -= _bufferDropSpeed * Time.deltaTime; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\GameHUDView.cs]
using UnityEngine; using UnityEngine.UI; using TMPro; using System.Collections.Generic; using Unity.Collections; using Unity.Netcode; public class GameHUDView : MonoBehaviour { public Slider HealthSlider; public Image QSkill; public Image WSkill; public Image ESkill; public TMP_Text points; public Sprite itemIcon; public Image item1; public Image item2; public Image item3; private PlayerNetworkHealth _pnHealth; private PlayerNetworkCombat _pnCombat; private PlayerNetworkCore _core; public static GameHUDView Instance { get; private set; } private void Awake() { Instance = this; } public void BindToLocalPlayer(PlayerNetworkHealth health, PlayerNetworkCombat combat, PlayerNetworkCore core) { _pnHealth = health; _pnCombat = combat; _core = core; BindView(); } public void BindView() { _pnHealth.CurrentHealthVar.OnValueChanged += UpdateHealthSlider; _pnCombat.QSkillActiveVar.OnValueChanged += UpdateQSkill; _pnCombat.WSkillActiveVar.OnValueChanged += UpdateWSkill; _pnCombat.ESkillActiveVar.OnValueChanged += UpdateESkill; _core.PointVar.OnValueChanged += UpdatePoints; _core.ItemsVar.OnListChanged += UpdateItems; UpdateHealthSlider(_pnHealth.MaxHealth, _pnHealth.MaxHealth); UpdateQSkill(true, _pnCombat.QSkillActiveVar.Value); UpdateWSkill(true, _pnCombat.WSkillActiveVar.Value); UpdateESkill(true, _pnCombat.ESkillActiveVar.Value); } public void UpdateHealthSlider(int preHealth, int currentHealth) { if (HealthSlider == null) return; HealthSlider.value = (float)currentHealth / (float)_pnHealth.MaxHealth; } public void UpdateQSkill(bool ignore, bool active) { QSkill.color = active ? Color.white : Color.gray; } public void UpdateWSkill(bool ignore, bool active) { WSkill.color = active ? Color.white : Color.gray; } public void UpdateESkill(bool ignore, bool active) { ESkill.color = active ? Color.white : Color.gray; } public void UpdatePoints(int pre, int current) { points.text = current.ToString(); } public void UpdateItems(NetworkListEvent<FixedString32Bytes> changeEvent) { int count = _core.ItemsVar.Count; if (count >= 1) { item1.sprite = itemIcon; item1.color = Color.white; } else { item1.sprite = null; item1.color = Color.clear; } if (count >= 2) { item2.sprite = itemIcon; item2.color = Color.white; } else { item2.sprite = null; item2.color = Color.clear; } if (count >= 3) { item3.sprite = itemIcon; item3.color = Color.white; } else { item3.sprite = null; item3.color = Color.clear; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\UIBillboard.cs]
using UnityEngine; public class UIBillboard : MonoBehaviour { private Camera _mainCamera; private void Start() { _mainCamera = Camera.main; } private void LateUpdate() { if (_mainCamera == null) _mainCamera = Camera.main; if (_mainCamera == null) return; transform.LookAt(transform.position + _mainCamera.transform.rotation * Vector3.forward, _mainCamera.transform.rotation * Vector3.up); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\UIManager.cs]
using UnityEngine; using Unity.Netcode; public class UIManager : MonoBehaviour { public static UIManager Instance { get; private set; } [SerializeField] private GameHUDView hudView; private void Awake() { Instance = this; } public void OnLocalPlayerSpawned(PlayerNetworkHealth health, PlayerNetworkCombat combat) { } public void OnLocalPlayerDespawned() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\UI\UnitHealthBinder.cs]
using Unity.Netcode; using UnityEngine; public class UnitHealthBinder : NetworkBehaviour { [Header("UI Reference")] [SerializeField] private BufferedHealthBar _healthBar; [Header("Unit References")] [SerializeField] private BossController _bossController; [SerializeField] private EnemyController _enemyController; public override void OnNetworkSpawn() { if (_bossController == null) _bossController = GetComponentInParent<BossController>(); if (_enemyController == null) _enemyController = GetComponentInParent<EnemyController>(); if (_bossController != null) { _bossController.OnHealthChanged += HandleHealthChanged; HandleHealthChanged(_bossController.CurrentHealth, _bossController.MaxHealth); } if (_enemyController != null) { _enemyController.OnHealthChanged += HandleHealthChanged; HandleHealthChanged(_enemyController.CurrentHealth, _enemyController.MaxHealth); } } public override void OnNetworkDespawn() { if (_bossController != null) _bossController.OnHealthChanged -= HandleHealthChanged; if (_enemyController != null) _enemyController.OnHealthChanged -= HandleHealthChanged; } private void HandleHealthChanged(int current, int max) { if (_healthBar != null) { _healthBar.UpdateHealth(current, max); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Utils\SubclassSelectorAttribute.cs]
using UnityEngine; public class SubclassSelectorAttribute : PropertyAttribute { }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossBaseState.cs]
using UnityEngine; public abstract class BossBaseState { protected BossController _controller; protected BossPresentation _view; protected BossStateMachine _stateMachine; public BossBaseState(BossController controller, BossStateMachine stateMachine) { _controller = controller; _view = controller.View; _stateMachine = stateMachine; } public virtual void Enter() { } public virtual void Update() { } public virtual void Exit() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossController.cs]
using System; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using UnityEngine.AI; using Random = UnityEngine.Random; [RequireComponent(typeof(BossPresentation))] [RequireComponent(typeof(NetworkObject))] public class BossController : NetworkBehaviour, IDamageable { public enum BossMotionState { Idle = 0, Chase = 1, Charge = 2, Skill = 3, Die = 4, } [Header("References")] [SerializeField] private BossPresentation _view; [SerializeField] private SkillDataSO[] _skills; [Header("Settings")] [SerializeField] private int _maxHealth = 100; [SerializeField] public float ChaseRange = 50f; [SerializeField] public float BasicAttackRange = 3.5f; [SerializeField] public LayerMask ChaseLayer; [SerializeField] private float _specialSkillInterval = 15f; public NavMeshAgent Agent => _view.Agent; public BossPresentation View => _view; public NetworkObject Target { get; private set; } public SkillDataSO[] Skills => _skills; private float[] _skillCDs; private float _specialSkillTimer = 0f; private bool _hasTriggered50Ult = false; private bool _hasTriggered10Ult = false; private NetworkVariable<BossMotionState> _currentBossState = new NetworkVariable<BossMotionState>( BossMotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 100, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private NetworkVariable<int> _currentSkillIndex = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public int MaxHealth => _maxHealth; public int CurrentHealth => _currentHealth.Value; public BossMotionState MotionState => _currentBossState.Value; public int CurrentSkillIdx => _currentSkillIndex.Value; public SkillDataSO CurrentSkillData => (_skills != null && CurrentSkillIdx >= 0 && CurrentSkillIdx < _skills.Length) ? _skills[CurrentSkillIdx] : null; public event Action OnBossDied; private BossStateMachine _stateMachine; #region public events public event Action<int, int> OnHealthChanged; #endregion private void Awake() { if (_view == null) _view = GetComponent<BossPresentation>(); _stateMachine = new BossStateMachine(this); } public override void OnNetworkSpawn() { if (IsServer) { _currentHealth.Value = _maxHealth; _currentBossState.Value = BossMotionState.Idle; _currentSkillIndex.Value = 0; Agent.enabled = true; Target = null; if (_skills != null) _skillCDs = new float[_skills.Length]; } else { Agent.enabled = false; } _currentBossState.OnValueChanged += OnStateNetworkValueChanged; SyncStateFromNetwork(_currentBossState.Value); _currentHealth.OnValueChanged += OnHealthNetworkChanged; OnHealthChanged?.Invoke(_currentHealth.Value, _maxHealth); } public override void OnNetworkDespawn() { _currentBossState.OnValueChanged -= OnStateNetworkValueChanged; _currentHealth.OnValueChanged -= OnHealthNetworkChanged; } private void Update() { if (IsServer) { UpdateTimers(); } _stateMachine.Update(); } private void UpdateTimers() { if (_currentBossState.Value == BossMotionState.Die) return; if (_skillCDs != null) { for (int i = 0; i < _skillCDs.Length; i++) if (_skillCDs[i] > 0) _skillCDs[i] -= Time.deltaTime; } if (Target != null) _specialSkillTimer += Time.deltaTime; } private void OnStateNetworkValueChanged(BossMotionState oldState, BossMotionState newState) { SyncStateFromNetwork(newState); } private void OnHealthNetworkChanged(int prev, int curr) { OnHealthChanged?.Invoke(curr, _maxHealth); } private void SyncStateFromNetwork(BossMotionState state) { switch (state) { case BossMotionState.Idle: _stateMachine.ChangeState(_stateMachine.StateIdle); break; case BossMotionState.Chase: _stateMachine.ChangeState(_stateMachine.StateMove); break; case BossMotionState.Charge: _stateMachine.ChangeState(_stateMachine.StateCharge); break; case BossMotionState.Skill: _stateMachine.ChangeState(_stateMachine.StateSkill); break; case BossMotionState.Die: _stateMachine.ChangeState(_stateMachine.StateDie); break; } } public void SetState(BossMotionState newState) { if (!IsServer) return; if (_currentBossState.Value != newState) { _currentBossState.Value = newState; } } public void SetTarget(NetworkObject target) { Target = target; } public void RotateTowardsTarget() { if (Target == null) return; Vector3 dir = (Target.transform.position - transform.position).normalized; dir.y = 0; if (dir != Vector3.zero) transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(dir), 10f * Time.deltaTime); } public bool TrySelectAndStartAttack() { int skillIndex = SelectSkillToCast(); if (skillIndex != -1) { _currentSkillIndex.Value = skillIndex; if (_skills != null && skillIndex < _skills.Length) _skillCDs[skillIndex] = _skills[skillIndex].coolDown; SetState(BossMotionState.Charge); return true; } return false; } private int SelectSkillToCast() { float hpPercent = (float)_currentHealth.Value / _maxHealth; int ultIndex = 3; if (_skills.Length > ultIndex) { if (hpPercent <= 0.1f && !_hasTriggered10Ult) { _hasTriggered10Ult = true; _skillCDs[ultIndex] = 0; return ultIndex; } if (hpPercent <= 0.5f && !_hasTriggered50Ult) { _hasTriggered50Ult = true; _skillCDs[ultIndex] = 0; return ultIndex; } } if (_specialSkillTimer >= _specialSkillInterval) { List<int> readySpecials = new List<int>(); if (_skills.Length > 1 && _skillCDs[1] <= 0) readySpecials.Add(1); if (_skills.Length > 2 && _skillCDs[2] <= 0) readySpecials.Add(2); if (readySpecials.Count > 0) { _specialSkillTimer = 0f; return readySpecials[Random.Range(0, readySpecials.Count)]; } } if (_skills.Length > 0 && _skillCDs[0] <= 0) return 0; return -1; } public void TakeDamage(int amount, ulong attackerId) { if (!IsServer) return; if (_currentBossState.Value == BossMotionState.Die) return; int newHealth = Mathf.Max(_currentHealth.Value - amount, 0); _currentHealth.Value = newHealth; if (newHealth <= 0) { SetState(BossMotionState.Die); OnBossDied?.Invoke(); return; } if (Target == null && NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(attackerId, out var attacker)) { Target = attacker; } } public void TageDamage(int amount, ulong attackerId) => TakeDamage(amount, attackerId); public void TriggerChargeVisuals(Vector3 pos, float duration) { int skillIndex = _currentSkillIndex.Value; SpawnChargeVisualsClientRpc(skillIndex, pos, duration); } [ClientRpc] private void SpawnChargeVisualsClientRpc(int skillIndex, Vector3 pos, float duration) { if (_skills == null || skillIndex < 0 || skillIndex >= _skills.Length) return; var skillData = _skills[skillIndex]; var prefabs = skillData.chargeVisualPrefabs; if (prefabs == null || prefabs.Count == 0) return; foreach (var prefab in prefabs) { if (prefab == null) continue; GameObject instance = Instantiate(prefab, pos, Quaternion.identity); if (instance.TryGetComponent<ChargeGrowingVisual>(out var visualScript)) { visualScript.SetDuration(duration); } else { Destroy(instance, duration + 0.5f); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossPresentation.cs]
using UnityEngine; using UnityEngine.AI; public class BossPresentation : MonoBehaviour { [Header("Component References")] public Animator Animator; public NavMeshAgent Agent; private void Awake() { if (Animator == null) Animator = GetComponent<Animator>(); if (Agent == null) Agent = GetComponent<NavMeshAgent>(); } public void PlayAnimation(string animName, float transitionDuration = 0.1f) { if (Animator != null && !string.IsNullOrEmpty(animName)) { Animator.CrossFade(animName, transitionDuration); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyController.cs]
using System; using System.Collections; using System.Linq; using Unity.Netcode; using UnityEngine; using UnityEngine.AI; [RequireComponent(typeof(NavMeshAgent)), RequireComponent(typeof(NetworkObject))] public class EnemyController : NetworkBehaviour, IDamageable { public enum NPCMotionState { Idle = 0, Chase = 1, Attack = 2, Die = 3 } [Header("Detection Settings")] [SerializeField] private float _chaseRange = 10f; [SerializeField] private LayerMask _chaseLayer; [Header("Skill Settings")] [SerializeField] private SkillDataSO _skillData; private float _repathTimer = 0f; private float _repathInterval = 0.2f; private float _attackTimer = 0f; private float _attackInterval = 0.833f; public LayerMask ChaseLayer => _chaseLayer; private NavMeshAgent _agent; private NetworkObject _target; #region public property public NavMeshAgent Agent => _agent; public float ChaseRange => _chaseRange; public SkillDataSO SkillData => _skillData; #endregion #region network variable private NetworkVariable<NPCMotionState> _currentEnmeyState = new NetworkVariable<NPCMotionState>( NPCMotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<NPCMotionState> Motion => _currentEnmeyState; public NPCMotionState MotionStateVar => _currentEnmeyState.Value; private NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 100, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public int MaxHealth => _maxHealth; public int CurrentHealth => _currentHealth.Value; [SerializeField] private int _maxHealth = 100; #endregion private float _skillTimer = 0f; public string GetSkillAnimationName() { return _skillData != null ? _skillData.skillActiveAnimationName : "Attack"; } #region public events public event Action<int, int> OnHealthChanged; #endregion public override void OnNetworkSpawn() { _agent = GetComponent<NavMeshAgent>(); if (IsServer) { _target = null; _agent.enabled = true; _currentEnmeyState.Value = NPCMotionState.Idle; _currentHealth.Value = _maxHealth; _skillTimer = 0f; if (_skillData != null) { _agent.stoppingDistance = Mathf.Max(1.0f, _skillData.castRadius - 0.5f); } } else { _agent.enabled = false; } _currentHealth.OnValueChanged += (prev, curr) => OnHealthChanged?.Invoke(curr, _maxHealth); OnHealthChanged?.Invoke(_currentHealth.Value, _maxHealth); } private void Update() { if (!IsServer) return; if (_skillTimer > 0) _skillTimer -= Time.deltaTime; switch (_currentEnmeyState.Value) { case NPCMotionState.Idle: LogicIdle(); break; case NPCMotionState.Chase: LogicChase(); break; case NPCMotionState.Attack: LogicAttack(); break; } } private void LogicIdle() { DetectPlayer(); if (_target != null) { float distance = Vector3.Distance(transform.position, _target.transform.position); float requiredRange = GetRequiredAttackRange(); if (distance <= requiredRange) { ChangeStateToAttack(); } else { ChangeStateToChase(); } } } private void LogicChase() { if (_target == null) { ChangeStateToIdle(); return; } float distance = Vector3.Distance(transform.position, _target.transform.position); if (distance > _chaseRange * 1.5f) { ChangeStateToIdle(); return; } float requiredRange = GetRequiredAttackRange(); if (distance <= requiredRange) { ChangeStateToAttack(); return; } ChasePlayerMovement(); } private void LogicAttack() { if (_target == null) { ChangeStateToIdle(); return; } float distance = Vector3.Distance(transform.position, _target.transform.position); float requiredRange = GetRequiredAttackRange(); if (distance > requiredRange * 1.1f) { ChangeStateToChase(); return; } if (_agent.isOnNavMesh && !_agent.isStopped) { _agent.isStopped = true; _agent.ResetPath(); } Vector3 direction = (_target.transform.position - transform.position).normalized; direction.y = 0; if (direction != Vector3.zero) { transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(direction), 10f * Time.deltaTime); } if (_skillTimer <= 0 && _skillData != null) { _skillTimer = _skillData.coolDown; _skillData.Cast(gameObject, _target.gameObject, _target.transform.position); Debug.Log($"Enemy Cast Skill: {_skillData.name}"); } } private float GetRequiredAttackRange() { if (_skillData != null) { return _skillData.castRadius; } return 2.0f; } private void ChangeStateToIdle() { if (_currentEnmeyState.Value == NPCMotionState.Idle) return; _currentEnmeyState.Value = NPCMotionState.Idle; _target = null; if (_agent.isOnNavMesh) _agent.ResetPath(); } private void ChangeStateToChase() { if (_currentEnmeyState.Value == NPCMotionState.Chase) return; _currentEnmeyState.Value = NPCMotionState.Chase; if (_agent.isOnNavMesh && _skillData != null) { float stopDist = Mathf.Max(0.5f, _skillData.castRadius * 0.8f); _agent.stoppingDistance = stopDist; _agent.isStopped = false; } } private void ChangeStateToAttack() { if (_currentEnmeyState.Value == NPCMotionState.Attack) return; _currentEnmeyState.Value = NPCMotionState.Attack; if (_agent.isOnNavMesh) _agent.ResetPath(); } private void ChasePlayerMovement() { _repathTimer += Time.deltaTime; if (_repathTimer > _repathInterval) { _repathTimer = 0f; if (_agent.isOnNavMesh && _target != null) { _agent.SetDestination(_target.transform.position); } } } private void DetectPlayer() { if (_target != null) return; var colliderInfos = Physics.OverlapSphere(transform.position, _chaseRange, _chaseLayer); if (colliderInfos.Length <= 0) return; NetworkObject bestTarget = null; float minDistance = float.MaxValue; foreach (Collider collider in colliderInfos) { if (collider.gameObject == gameObject) continue; if (!collider.TryGetComponent<NetworkObject>(out NetworkObject netObj)) continue; float d = Vector3.Distance(collider.transform.position, transform.position); if (d < minDistance) { minDistance = d; bestTarget = netObj; } } if (bestTarget != null) { _target = bestTarget; } } public void TakeDamage(int amount, ulong attackerId) { if (!IsServer) return; int newHealth = _currentHealth.Value - amount; if (newHealth < 0) newHealth = 0; _currentHealth.Value = newHealth; if (_target == null && NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(attackerId, out var attackerObj)) { _target = attackerObj; ChangeStateToChase(); } if (newHealth <= 0) { GetComponent<NetworkObject>().Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyPresentation.cs]
using UnityEditor.VersionControl; using UnityEngine; [RequireComponent(typeof(Animator))] public class EnemyPresentation : MonoBehaviour { private EnemyController _controller; private IEnemyState _currentState; private Animator _animator; public Animator Animator => _animator; private string _skillAnimationName; public string SkillAnimationName => _skillAnimationName; void Start() { _controller = GetComponent<EnemyController>(); _controller.Motion.OnValueChanged += OnMtionStateChanged; _animator = GetComponent<Animator>(); } void Update() { } private void OnMtionStateChanged(EnemyController.NPCMotionState oldState, EnemyController.NPCMotionState newState) { RefreshState(); } private void RefreshState() { if(_controller == null) return; switch (_controller.MotionStateVar) { case EnemyController.NPCMotionState.Idle: if (_currentState is EnemyStateIdle) return; ChangeState(new EnemyStateIdle(this)); break; case EnemyController.NPCMotionState.Chase: if(_currentState is EnemyStateMove) return; ChangeState(new EnemyStateMove(this)); break; case EnemyController.NPCMotionState.Attack: if(_currentState is EnemyStateSkillActive) return; _skillAnimationName = _controller.GetSkillAnimationName(); ChangeState(new EnemyStateSkillActive(this)); break; default: break; } } public void ChangeState(IEnemyState newState) { _currentState?.Exit(); _currentState = newState; _currentState.Enter(); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerInputManager.cs]
using Unity.Netcode; using UnityEngine; [RequireComponent(typeof(PlayerNetworkCore))] public class PlayerInputManager : NetworkBehaviour { [Header("Raycast Layers")] [SerializeField] private LayerMask groundLayer; [SerializeField] private LayerMask interactLayer; [Header("Raycast")] [SerializeField] private float rayMaxDistance = 1000f; private Camera _mainCamera; private PlayerNetworkCore _core; private PlayerNetworkMovement _movement; private PlayerNetworkCombat _combat; private void Awake() { _core = GetComponent<PlayerNetworkCore>(); _movement = GetComponent<PlayerNetworkMovement>(); _combat = GetComponent<PlayerNetworkCombat>(); } public override void OnNetworkSpawn() { if (!IsOwner) { enabled = false; return; } _mainCamera = Camera.main; if( _core != null ) { _core.LifeVar.OnValueChanged += OnLifeChanged; } } public override void OnNetworkDespawn() { if (IsOwner && _core != null) _core.LifeVar.OnValueChanged -= OnLifeChanged; } private void OnLifeChanged(PlayerNetworkStates.LifeState oldState, PlayerNetworkStates.LifeState newState) { if (newState == PlayerNetworkStates.LifeState.Dead) enabled = false; } private void Update() { if (!IsOwner) return; if (_movement == null) return; if (Input.GetKeyDown(KeyCode.S)) { _movement.RequestStop(); return; } if (Input.GetKeyDown(KeyCode.A)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position + transform.forward; _combat.RequestCastSkill(0, aimPos); return; } if (Input.GetKeyDown(KeyCode.Q)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(1, aimPos); return; } if (Input.GetKeyDown(KeyCode.W)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(2, aimPos); return; } if (Input.GetKeyDown(KeyCode.E)) { Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); Vector3 aimPos = transform.position; if (Physics.Raycast(ray, out RaycastHit hit, rayMaxDistance, groundLayer)) { aimPos = hit.point; } _combat.RequestCastSkill(3, aimPos); return; } if (Input.GetMouseButtonDown(1)) { if (_mainCamera == null) _mainCamera = Camera.main; if (_mainCamera == null) return; Ray ray = _mainCamera.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out RaycastHit interactHit, rayMaxDistance, interactLayer)) { if(interactHit.collider.TryGetComponent<IInteractable>(out var interact)) { Debug.Log("����������㣬��ȡ�����ӿ�"); interact.Interact(gameObject); } return; } if(Physics.Raycast(ray, out RaycastHit groundHit, rayMaxDistance, groundLayer)) { _movement.RequestMove(groundHit.point); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkCombat.cs]
using System; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkCombat : NetworkBehaviour { [Header("技能配置")] [Tooltip("Element 0 = 普攻, Element 1 = Q, Element 2 = W, Element 3 = E")] [SerializeField] private List<SkillDataSO> _skillSlots; private PlayerNetworkCore _core; private PlayerNetworkMovement _movement; #region net var private readonly NetworkVariable<int> _currentSkillIndex = new NetworkVariable<int>( -1, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private readonly NetworkVariable<bool> _qSkillActive = new NetworkVariable<bool>( true, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private readonly NetworkVariable<bool> _wSkillActive = new NetworkVariable<bool>( true, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); private readonly NetworkVariable<bool> _eSkillActive = new NetworkVariable<bool>( true, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<bool> QSkillActiveVar => _qSkillActive; public NetworkVariable<bool> WSkillActiveVar => _wSkillActive; public NetworkVariable<bool> ESkillActiveVar => _eSkillActive; #endregion private float[] _cooldownTimers; public string GetSkillAnimationName() => _skillSlots[_currentSkillIndex.Value].skillActiveAnimationName; public int CurrentSkillIndex => _currentSkillIndex.Value; public int SkillCount => _skillSlots.Count; public event Action<int> OnSkillIndexChanged; private bool _isChasing; private void Awake() { _core = GetComponent<PlayerNetworkCore>(); _movement = GetComponent<PlayerNetworkMovement>(); _cooldownTimers = new float[_skillSlots.Count]; for(int i = 0; i < _skillSlots.Count; i++) { _cooldownTimers[i] = _skillSlots[i].coolDown; } } public override void OnNetworkSpawn() { _currentSkillIndex.OnValueChanged += HandleSkillIndexChanged; if (!IsServer) return; } public override void OnNetworkDespawn() { _currentSkillIndex.OnValueChanged -= HandleSkillIndexChanged; } private void HandleSkillIndexChanged(int prev, int curr) { OnSkillIndexChanged?.Invoke(curr); } private void Update() { if (!IsServer) return; if (_core.IsDead) return; ProcessCooldowns(); if (_isChasing) PerformChaseLogic(); } private void ProcessCooldowns() { for (int i = 0; i < _cooldownTimers.Length; i++) { if (_cooldownTimers[i] > 0) { _cooldownTimers[i] -= Time.deltaTime; } else { if (i == 1 && !_qSkillActive.Value) _qSkillActive.Value = true; if (i == 2 && !_wSkillActive.Value) _wSkillActive.Value = true; if (i == 3 && !_eSkillActive.Value) _eSkillActive.Value = true; } } } public SkillDataSO GetCurrentSkillData() { int index = _currentSkillIndex.Value; if (index < 0 || index >= _skillSlots.Count) return null; return _skillSlots[index]; } public void RequestCastSkill(int slotIndex, Vector3 aimPosition) { if (!IsOwner) return; RequestCastSkillServerRpc(slotIndex, aimPosition); } [ServerRpc] private void RequestCastSkillServerRpc(int index, Vector3 aimPosition) { if (_core.IsDead) return; if (index < 0 || index >= _skillSlots.Count) return; if (_cooldownTimers[index] > 0) return; ExecuteSkill(index, aimPosition); } private void ExecuteSkill(int index, Vector3 aimPosition) { switch (index) { case 1: _qSkillActive.Value = false; break; case 2: _wSkillActive.Value = false; break; case 3: _eSkillActive.Value = false; break; default: break; } SkillDataSO skillData = _skillSlots[index]; _movement.ServerForceStop(); _isChasing = false; _currentSkillIndex.Value = index; _core.SetMotionServer(PlayerNetworkStates.MotionState.Skill); _cooldownTimers[index] = skillData.coolDown; skillData.Cast(gameObject, null, aimPosition); CancelInvoke(nameof(ResetToIdle)); float recoveryTime = 0.8f; Invoke(nameof(ResetToIdle), recoveryTime); } private void ResetToIdle() { if (_core.IsDead) return; _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); _currentSkillIndex.Value = -1; } private void PerformChaseLogic() { } public float GetCooldownRemaining(int v) { return _cooldownTimers[v]; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkCore.cs]
using NUnit.Framework; using System; using System.Collections.Generic; using Unity.Collections; using TMPro.EditorUtilities; using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkCore : NetworkBehaviour { [Header("Server LifeCycle")] [SerializeField] private float deathDespawnDelay = 3f; private readonly NetworkVariable<PlayerNetworkStates.LifeState> _lifeState = new NetworkVariable<PlayerNetworkStates.LifeState>( PlayerNetworkStates.LifeState.Alive, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server); public PlayerNetworkStates.LifeState Life => _lifeState.Value; public NetworkVariable<PlayerNetworkStates.LifeState> LifeVar => _lifeState; private readonly NetworkVariable<PlayerNetworkStates.MotionState> _motionState = new NetworkVariable<PlayerNetworkStates.MotionState>( PlayerNetworkStates.MotionState.Idle, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server); public PlayerNetworkStates.MotionState Motion => _motionState.Value; public NetworkVariable<PlayerNetworkStates.MotionState> MotionVar => _motionState; public bool IsDead => _lifeState.Value == PlayerNetworkStates.LifeState.Dead; private readonly NetworkVariable<int> _points = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkVariable<int> PointVar => _points; private NetworkList<FixedString32Bytes> _items = new NetworkList<FixedString32Bytes>( new List<FixedString32Bytes>(), NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public NetworkList<FixedString32Bytes> ItemsVar => _items; #region public events public event Action<PlayerNetworkCore> OnPlayerDied; #endregion private PlayerNetworkHealth _health; private PlayerNetworkMovement _movement; private PlayerNetworkCombat _combat; private bool _deathTimerRunning; private float _deathTimer; private void Awake() { _health = GetComponent<PlayerNetworkHealth>(); _movement = GetComponent<PlayerNetworkMovement>(); _combat = GetComponent<PlayerNetworkCombat>(); } public override void OnNetworkSpawn() { if (!IsServer) return; _lifeState.Value = PlayerNetworkStates.LifeState.Alive; _deathTimerRunning = false; _deathTimer = 0f; if (_health != null) { _health.OnDiedServer += OnDiedServer; } if (GameLifecycleManager.Instance != null) { GameLifecycleManager.Instance.RegisterPlayer(this); } else { var manager = FindFirstObjectByType<GameLifecycleManager>(); if (manager != null) manager.RegisterPlayer(this); } _movement?.ServerReset(); } public override void OnNetworkDespawn() { if (!IsServer) return; if (_health != null) { _health.OnDiedServer -= OnDiedServer; } if (GameLifecycleManager.Instance != null) { GameLifecycleManager.Instance.UnregisterPlayer(this); } var gameManager = GameLifecycleManager.Instance; gameManager.UnregisterPlayer(this); } private void Update() { if (!IsServer) return; if (!IsDead) return; ProcessDeathDespawn(); } private void OnDiedServer() { if (!IsServer) return; if (IsDead) return; _lifeState.Value = PlayerNetworkStates.LifeState.Dead; OnPlayerDied?.Invoke(this); _movement?.ServerForceStop(); _deathTimerRunning = true; _deathTimer = 0f; } private void ProcessDeathDespawn() { if (!_deathTimerRunning) return; _deathTimer += Time.deltaTime; if (_deathTimer < deathDespawnDelay) return; var nob = GetComponent<NetworkObject>(); if (nob != null && nob.IsSpawned) { nob.Despawn(); } _deathTimerRunning = false; } public void ApplyDamageServer(int amount, ulong attackerId) { if (!IsServer) return; if (IsDead) return; if (_health == null) return; _health.ServerTakeDamage(amount, attackerId); } public void SetMotionServer(PlayerNetworkStates.MotionState newState) { if (!IsServer) return; if(_motionState.Value == newState) return; _motionState.Value = newState; } public void AddPointsServer(int amount) { if (!IsServer) return; _points.Value += amount; } public void AddItem(string name) { _items.Add(name); string allItems = ""; foreach(var item in _items) { allItems += item; } Debug.Log(allItems); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkHealth.cs]
using System; using Unity.Netcode; using UnityEngine; public class PlayerNetworkHealth : NetworkBehaviour, IDamageable { [Header("����")] [SerializeField] private int _maxHealth = 100; [Header("Feedback Settings")] [SerializeField] private float knockbackForce = 15f; private readonly NetworkVariable<int> _currentHealth = new NetworkVariable<int>( 0, NetworkVariableReadPermission.Everyone, NetworkVariableWritePermission.Server ); public int CurrentHealth => _currentHealth.Value; public NetworkVariable<int> CurrentHealthVar => _currentHealth; public int MaxHealth => _maxHealth; public bool IsDead => _currentHealth.Value < 0; private PlayerNetworkMovement _movement; private DamageFlash _damageFlash; public event Action<int, int> OnHealthChanged; public event Action<int, ulong> OnDamaged; public event Action<ulong> OnDied; public event Action OnDiedServer; private void Awake() { _movement = GetComponent<PlayerNetworkMovement>(); _damageFlash = GetComponent<DamageFlash>(); } public override void OnNetworkSpawn() { _currentHealth.OnValueChanged += HandleHealthChanged; if (IsServer) { _currentHealth.Value = _maxHealth; } _currentHealth.Value = _maxHealth; OnHealthChanged?.Invoke(_currentHealth.Value, _maxHealth); } public override void OnNetworkDespawn() { _currentHealth.OnValueChanged -= HandleHealthChanged; OnHealthChanged = null; OnDamaged = null; OnDied = null; OnDiedServer = null; } private void HandleHealthChanged(int prev, int curr) { OnHealthChanged?.Invoke(curr, _maxHealth); } public void RequestTakeDamage(int damage, ulong attackerCliendId = 0) { ServerTakeDamage(damage, attackerCliendId); } public void ServerTakeDamage(int damage, ulong attackerClientId = 0) { if (!IsServer) return; if (damage < 0) return; if (IsDead) return; int prev = _currentHealth.Value; int next = Mathf.Clamp(prev - damage, 0, MaxHealth); if (next != prev) { _currentHealth.Value = next; } DamagedClientRpc(damage, attackerClientId); if (next <= 0) { DiedClientRpc(attackerClientId); OnDiedServer?.Invoke(); } } public void ServerHeal(int amount) { if (!IsServer) return; if(amount <= 0) return; if (IsDead) return; int prev = _currentHealth.Value; int next = Mathf.Clamp(prev + amount, 0, MaxHealth); if(next == prev) return; _currentHealth.Value = next; } [ClientRpc] private void DamagedClientRpc(int damage, ulong attackerClientId) { OnDamaged?.Invoke(damage, attackerClientId); if (DamageTextManager.Instance != null) { Vector3 randomOffset = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 1.5f, 0); DamageTextManager.Instance.ShowDamage(damage, transform.position + randomOffset); } if (_damageFlash != null) { _damageFlash.TriggerFlash(); } if (HitStopManager.Instance != null) { HitStopManager.Instance.TriggerHitStop(0.05f, 0.0f); } } [ClientRpc] private void DiedClientRpc(ulong attackerCliendId) { OnDied?.Invoke(attackerCliendId); } [ClientRpc] private void ShowDamagePopupClientRpc(int amount, Vector3 targetPos) { if(DamageTextManager.Instance != null) { Vector3 randomOffset = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), 1.5f, 0); DamageTextManager.Instance.ShowDamage(amount, targetPos + randomOffset); } } public void TakeDamage(int amount, ulong attackerId) { RequestTakeDamage(amount, attackerId); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkMovement.cs]
using System; using System.Collections; using Unity.Netcode; using UnityEngine; [DisallowMultipleComponent] public class PlayerNetworkMovement : NetworkBehaviour, IKnockBackable { [Header("Server Movement")] [SerializeField] private float moveSpeed = 6f; [SerializeField] private float rotateSpeed = 15f; [SerializeField] private float smoothTime = 0.15f; [Header("Physics Settings")] [SerializeField] private float gravity = -9.81f; [SerializeField] private float drag = 2.0f; private bool _isKnockedBack = false; private Vector3 _velocity; private Vector3 _smoothDampVelocity; private Vector3 _serverTargetPosition; private PlayerNetworkCore _core; public event Action ServerReachedDestination; private void Awake() { _core = GetComponent<PlayerNetworkCore>(); } public override void OnNetworkSpawn() { if (!IsServer) return; _serverTargetPosition = transform.position; _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); } private void Update() { if (!IsServer) return; if (_core != null && _core.IsDead) return; ProcessMovementServer(); } private IEnumerator RecoverFromKnockback(float duration) { yield return new WaitForSeconds(duration); _isKnockedBack = false; } public void RequestMove(Vector3 worldPos) { if (!IsOwner) return; RequestMoveServerRpc(worldPos); } public void RequestStop() { if (!IsOwner) return; RequestStopServerRpc(); } public void ServerMoveTo(Vector3 worldPos) { if (!IsServer) return; if (_core != null && _core.IsDead) return; _serverTargetPosition = new Vector3(worldPos.x, transform.position.y, worldPos.z); _core.SetMotionServer(PlayerNetworkStates.MotionState.Moving); } public void ServerForceStop() { if (!IsServer) return; _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); _serverTargetPosition = transform.position; _smoothDampVelocity = Vector3.zero; } public void ServerForceDash(Vector3 direction, float distance, float duration) { if (!IsServer) return; Vector3 targetPos = transform.position + direction.normalized * distance; _serverTargetPosition = targetPos; transform.position = targetPos; _smoothDampVelocity = Vector3.zero; } public void ServerReset() { if (!IsServer) return; _serverTargetPosition = transform.position; _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); _smoothDampVelocity = Vector3.zero; } [ServerRpc] private void RequestMoveServerRpc(Vector3 pos, ServerRpcParams rpcParams = default) { if (_core != null && _core.IsDead) return; if (rpcParams.Receive.SenderClientId != OwnerClientId) return; if (_isKnockedBack) return; _serverTargetPosition = new Vector3(pos.x, transform.position.y, pos.z); _core.SetMotionServer(PlayerNetworkStates.MotionState.Moving); } [ServerRpc] private void RequestStopServerRpc(ServerRpcParams rpcParams = default) { if (_core != null && _core.IsDead) return; if (rpcParams.Receive.SenderClientId != OwnerClientId) return; ServerForceStop(); } private void ProcessMovementServer() { if (_isKnockedBack) { float dt = Time.deltaTime; _velocity.y += gravity * 2.0f * dt; Vector3 horizontalVel = new Vector3(_velocity.x, 0, _velocity.z); horizontalVel = Vector3.Lerp(horizontalVel, Vector3.zero, drag * dt); _velocity = new Vector3(horizontalVel.x, _velocity.y, horizontalVel.z); transform.position += _velocity * dt; if (Physics.Raycast(transform.position + Vector3.up * 0.5f, Vector3.down, out RaycastHit hit, 0.6f)) { if (_velocity.y < 0) { _isKnockedBack = false; _velocity = Vector3.zero; transform.position = new Vector3(transform.position.x, hit.point.y, transform.position.z); _serverTargetPosition = transform.position; } } return; } if (_core.Motion != PlayerNetworkStates.MotionState.Moving) return; float currentY = transform.position.y; Vector3 currentPosFlat = new Vector3(transform.position.x, 0, transform.position.z); Vector3 targetPosFlat = new Vector3(_serverTargetPosition.x, 0, _serverTargetPosition.z); Vector3 directionToTarget = targetPosFlat - currentPosFlat; if (directionToTarget.sqrMagnitude > 0.01f) { Quaternion targetRot = Quaternion.LookRotation(directionToTarget.normalized); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime); } Vector3 newPosFlat = Vector3.SmoothDamp( currentPosFlat, targetPosFlat, ref _smoothDampVelocity, smoothTime, moveSpeed ); transform.position = new Vector3(newPosFlat.x, currentY, newPosFlat.z); float dist = Vector3.Distance(currentPosFlat, targetPosFlat); if (dist < 0.2f && _smoothDampVelocity.sqrMagnitude < 0.1f) { _core.SetMotionServer(PlayerNetworkStates.MotionState.Idle); ServerReachedDestination?.Invoke(); _smoothDampVelocity = Vector3.zero; } } private void OnCollisionEnter(Collision collision) { if (!IsServer) return; if (_core != null && _core.IsDead) return; if (collision == null) return; if (collision.gameObject.CompareTag("Player")) { ServerForceStop(); } } private void OnTriggerEnter(Collider other) { if (!IsServer) return; if (_core != null && _core.IsDead) return; if (other == null) return; if (other.gameObject.TryGetComponent<IInteractable>(out var interact)) { interact.Interact(gameObject); } } public void ApplyKnockbackServer(Vector3 forceDir, float forceStrength) { if (!IsServer) return; _isKnockedBack = true; _velocity = forceDir.normalized * forceStrength; _serverTargetPosition = transform.position; _smoothDampVelocity = Vector3.zero; } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerNetworkStates.cs]
using UnityEngine; public class PlayerNetworkStates { public enum MotionState : byte { Idle = 0, Moving = 1, Skill = 2, } public enum LifeState : byte { Alive = 0, Dead = 1 } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\Network\PlayerPresentation.cs]
using Unity.Netcode; using UnityEngine; [RequireComponent(typeof(PlayerNetworkCore))] public class PlayerPresentation : NetworkBehaviour { private PlayerNetworkCore _core; private PlayerNetworkCombat _combat; private PlayerNetworkHealth _health; private IPlayerState _currentState; private string _skillAnimationName; public string SkillAnimationName => _skillAnimationName; public Rigidbody Rigidbody { get; private set; } public CapsuleCollider CapsuleCollider { get; private set; } public Animator Animator { get; private set; } private void Awake() { _core = GetComponent<PlayerNetworkCore>(); _combat = GetComponent<PlayerNetworkCombat>(); _health = GetComponent<PlayerNetworkHealth>(); Rigidbody = GetComponent<Rigidbody>(); CapsuleCollider = GetComponent<CapsuleCollider>(); Animator = GetComponent<Animator>(); } public override void OnNetworkSpawn() { if( _core != null) { _core.LifeVar.OnValueChanged += OnLifeChanged; _core.MotionVar.OnValueChanged += OnMotionChanged; } if (_combat != null) { _combat.OnSkillIndexChanged += OnSkillIndexChanged; } RefreshStateFromNet(); if(_health != null) { _health.OnDamaged += OnDamagedLocal; } if (IsOwner) { if (GameHUDView.Instance != null) { GameHUDView.Instance.BindToLocalPlayer(_health, _combat, _core); } if (GameCameraManager.Instance != null) { GameCameraManager.Instance.SetFollowTarget(transform); } else { } } } public override void OnNetworkDespawn() { if( _core != null) { _core.LifeVar.OnValueChanged-= OnLifeChanged; _core.MotionVar.OnValueChanged -= OnMotionChanged; } if (_combat != null) { _combat.OnSkillIndexChanged -= OnSkillIndexChanged; } if (IsOwner && _health != null && HealthBarUI.Instance != null) { _health.OnHealthChanged -= HealthBarUI.Instance.UpdateViewHealth; _health.OnDamaged -= OnDamagedLocal; } } private void OnSkillIndexChanged(int newIndex) { if (_core.Motion == PlayerNetworkStates.MotionState.Skill && newIndex != -1) { RefreshStateFromNet(); } } private void OnDamagedLocal(int damage, ulong attackerId) { if (IsOwner) { } } private void Update() { _currentState?.Update(); } private void OnMotionChanged(PlayerNetworkStates.MotionState oldState, PlayerNetworkStates.MotionState newState) { RefreshStateFromNet(); } private void OnLifeChanged(PlayerNetworkStates.LifeState oldState, PlayerNetworkStates.LifeState newState) { RefreshStateFromNet(); } private void RefreshStateFromNet() { if (_core == null) return; if(_core.Life == PlayerNetworkStates.LifeState.Dead) { if (_currentState is PlayerStateDie) return; ChangeState(new PlayerStateDie(this)); return; } switch (_core.Motion) { case PlayerNetworkStates.MotionState.Moving: if (_currentState is PlayerStateMove) return; ChangeState(new PlayerStateMove(this)); break; case PlayerNetworkStates.MotionState.Idle: if(_currentState is PlayerStateIdle) return; ChangeState(new PlayerStateIdle(this)); break; case PlayerNetworkStates.MotionState.Skill: _skillAnimationName = _combat.GetSkillAnimationName(); ChangeState(new PlayerStateSkill(this)); break; default: ChangeState(new PlayerStateIdle(this)); break; } } public void ChangeState(IPlayerState nextState) { _currentState?.Exit(); _currentState = nextState; _currentState.Enter(); } private void BindLocalPlayerUI() { var ui = HealthBarUI.Instance; if(ui == null) { Debug.LogError("����������ҵ���û�� Ѫ����"); return; } if(_health == null) { Debug.LogError("���û��Ѫ�����"); return; } _health.OnHealthChanged += ui.UpdateViewHealth; ui.UpdateViewHealth(_health.MaxHealth, _health.MaxHealth); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\IPlayerState.cs]
using UnityEngine; public interface IPlayerState { void Enter(); void Update(); void Exit(); }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateDie.cs]
using Unity.Netcode; using Unity.VisualScripting; using UnityEngine; public class PlayerStateDie : IPlayerState { private float DieTime = 3f; private float timer = 0; private PlayerPresentation _view; public PlayerStateDie(PlayerPresentation view) => _view = view; public void Enter() { if(_view.CapsuleCollider != null) { _view.CapsuleCollider.enabled = false; } if(_view.Rigidbody != null) { _view.Rigidbody.isKinematic = true; } Debug.Log("���� Die��Presentation������ײ��ʧЧ�����嶳�ᣨDespawn �� Server Authority ����"); _view.Animator.Play("Die01_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateIdle.cs]
using UnityEngine; public class PlayerStateIdle : IPlayerState { private RaycastHit groundHit; private PlayerPresentation _view; public PlayerStateIdle(PlayerPresentation view) => _view = view; public void Enter() { _view.Animator.Play("Idle_Battle_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateMove.cs]
using System; using System.Globalization; using Unity.Netcode; using UnityEngine; public class PlayerStateMove : IPlayerState { private PlayerPresentation _view; public PlayerStateMove(PlayerPresentation view) => _view = view; public void Enter() { _view.Animator.Play("MoveFWD_Normal_InPlace_SwordAndShield"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Player\PlayerStates\PlayerStateSkill.cs]
using UnityEngine; public class PlayerStateSkill : IPlayerState { private PlayerPresentation _view; public PlayerStateSkill(PlayerPresentation view) { _view = view; } public void Enter() { _view.Animator.Play(_view.SkillAnimationName); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\AreaEffect.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class AreaEffect : SkillEffect { [Header("AOE ����")] public float radius = 3f; public float delay = 1.0f; public int damage = 10; public GameObject vfxPrefab; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (vfxPrefab != null) { var vfx = GameObject.Instantiate(vfxPrefab, position, Quaternion.identity); vfx.GetComponent<NetworkObject>().Spawn(); GameObject.Destroy(vfx, delay + 0.5f); } caster.GetComponent<NetworkBehaviour>().StartCoroutine(ExplodeRoutine(caster, position)); } private IEnumerator ExplodeRoutine(GameObject caster, Vector3 centerPos) { yield return new WaitForSeconds(delay); Collider[] hits = Physics.OverlapSphere(centerPos, radius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage(damage, caster.GetComponent<NetworkObject>().NetworkObjectId); Debug.Log($"[Effect] AOE ը���� {hit.name}"); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\BossJumpEffect.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class BossJumpEffect : SkillEffect { [Header("��Ծ����")] public float height = 5.0f; public float duration = 1.0f; public bool isLanding = false; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (!caster.TryGetComponent<UnityEngine.AI.NavMeshAgent>(out var agent)) return; caster.GetComponent<NetworkBehaviour>().StartCoroutine( JumpRoutine(caster.transform, agent, isLanding) ); } private IEnumerator JumpRoutine(Transform bossInfo, UnityEngine.AI.NavMeshAgent agent, bool landing) { float timer = 0f; Vector3 startPos = bossInfo.position; Vector3 endPos = landing ? new Vector3(startPos.x, 0, startPos.z) : startPos + Vector3.up * height; if (!landing) { agent.enabled = false; } while (timer < duration) { timer += Time.deltaTime; float t = timer / duration; bossInfo.position = Vector3.Lerp(startPos, endPos, t); yield return null; } bossInfo.position = endPos; if (landing) { agent.enabled = true; if (UnityEngine.AI.NavMesh.SamplePosition(bossInfo.position, out var hit, 2.0f, UnityEngine.AI.NavMesh.AllAreas)) { agent.Warp(hit.position); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\CameraShakeEffect.cs]
using System; using UnityEngine; [Serializable] public class CameraShakeEffect : SkillEffect { [Header("��Ļ������")] [Tooltip("������ (0.1 - 5.0)")] public float shakeForce = 1.0f; [Tooltip("ֻ���ͷ����Լ��ܸ��ܵ�����")] public bool onlyLocalPlayer = true; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (GameCameraManager.Instance == null) return; bool shouldShake = false; if (onlyLocalPlayer) { if (caster.TryGetComponent<Unity.Netcode.NetworkObject>(out var netObj)) { if (netObj.IsOwner) shouldShake = true; } } else { shouldShake = true; } if (shouldShake) { GameCameraManager.Instance.ShakeCamera(shakeForce); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\ConeLaserEffect.cs]
using System; using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using Random = UnityEngine.Random; [Serializable] public class ConeLaserEffect : SkillEffect { [Header("����Ԥ���� (��� NetworkObject + LaserVisual)")] [SerializeField] private NetworkObject _laserPrefab; [Header("��Χ����")] [Range(0, 180)] public float coneAngle = 60f; public int rayCount = 5; [Header("��������")] public float startLength = 0.5f; public float maxLength = 20f; public float growthTime = 1.0f; public float totalDuration = 3.0f; [Header("ս������")] public float rayWidth = 0.2f; public int damagePerTick = 10; public float damageInterval = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { caster.GetComponent<NetworkBehaviour>().StartCoroutine( LaserBarrageRoutine(caster) ); } private IEnumerator LaserBarrageRoutine(GameObject caster) { List<NetworkObject> activeLasers = new List<NetworkObject>(); List<Vector3> laserDirections = new List<Vector3>(); for (int i = 0; i < rayCount; i++) { float randomYAngle = Random.Range(-coneAngle / 2f, coneAngle / 2f); Quaternion rotation = Quaternion.Euler(0, randomYAngle, 0); Vector3 finalDir = rotation * caster.transform.forward; Vector3 spawnPos = caster.transform.position + Vector3.up * 1.0f; Quaternion laserRot = Quaternion.LookRotation(finalDir); var laserInstance = GameObject.Instantiate(_laserPrefab, spawnPos, laserRot); laserInstance.Spawn(); activeLasers.Add(laserInstance); laserDirections.Add(finalDir); if (laserInstance.TryGetComponent<LaserVisual>(out var visual)) { visual.InitializeLaserClientRpc(startLength, maxLength, growthTime, rayWidth); } } float timer = 0f; Dictionary<string, float> hitRecords = new Dictionary<string, float>(); while (timer < totalDuration) { timer += Time.deltaTime; float progress = Mathf.Clamp01(timer / growthTime); float currentLogicLen = Mathf.Lerp(startLength, maxLength, progress); for (int i = 0; i < activeLasers.Count; i++) { var laserObj = activeLasers[i]; if (laserObj == null || !laserObj.IsSpawned) continue; Vector3 origin = laserObj.transform.position; Vector3 dir = laserObj.transform.forward; RaycastHit[] hits = Physics.SphereCastAll(origin, rayWidth / 2f, dir, currentLogicLen); foreach (var hit in hits) { if (hit.collider.gameObject == caster) continue; if (hit.collider.TryGetComponent<IDamageable>(out var damageable)) { ulong targetId = hit.collider.GetComponent<NetworkObject>().NetworkObjectId; ulong laserId = laserObj.NetworkObjectId; string key = $"{laserId}_{targetId}"; if (!hitRecords.ContainsKey(key) || (Time.time - hitRecords[key] > damageInterval)) { damageable.TakeDamage(damagePerTick, caster.GetComponent<NetworkObject>().NetworkObjectId); hitRecords[key] = Time.time; } } } } yield return null; } foreach (var laser in activeLasers) { if (laser != null && laser.IsSpawned) { laser.Despawn(); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\DamageEffect.cs]
using System; using Unity.Netcode; using UnityEngine; [Serializable] public class DamageEffect : SkillEffect { public int damageAmount = 10; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (target == null) return; if (target.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage( damageAmount, caster.GetComponent<NetworkObject>().NetworkObjectId); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\DynamicLaserEffect.cs]
using System; using System.Collections; using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using Random = UnityEngine.Random; [Serializable] public class DynamicLaserEffect : SkillEffect { [Header("����Ԥ���� (��� NetworkObject + NetworkTransform + LaserVisual)")] [SerializeField] private NetworkObject _laserPrefab; [Header("��Χ����")] [Range(0, 180)] public float baseConeAngle = 60f; public int rayCount = 5; [Header("��̬ɨ������ (Snake Motion)")] public float sweepSpeed = 2.0f; public float sweepAmplitude = 30f; public bool syncRotationWithBoss = true; [Header("��������")] public float startLength = 0.5f; public float maxLength = 20f; public float growthTime = 1.0f; public float totalDuration = 5.0f; [Header("ս������")] public float rayWidth = 0.5f; public int damagePerTick = 10; public float damageInterval = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { caster.GetComponent<NetworkBehaviour>().StartCoroutine( LaserBarrageRoutine(caster) ); } private IEnumerator LaserBarrageRoutine(GameObject caster) { List<NetworkObject> activeLasers = new List<NetworkObject>(); List<float> initialYOffsets = new List<float>(); List<float> noiseSeeds = new List<float>(); for (int i = 0; i < rayCount; i++) { float t = rayCount > 1 ? (float)i / (rayCount - 1) : 0.5f; float baseAngle = Mathf.Lerp(-baseConeAngle / 2f, baseConeAngle / 2f, t); Vector3 spawnPos = caster.transform.position + Vector3.up * 1.0f; Quaternion spawnRot = caster.transform.rotation * Quaternion.Euler(0, baseAngle, 0); var laserInstance = GameObject.Instantiate(_laserPrefab, spawnPos, spawnRot); laserInstance.Spawn(); activeLasers.Add(laserInstance); initialYOffsets.Add(baseAngle); noiseSeeds.Add(Random.Range(0f, 100f)); if (laserInstance.TryGetComponent<LaserVisual>(out var visual)) { visual.InitializeLaserClientRpc(startLength, maxLength, growthTime, rayWidth); } } float timer = 0f; Dictionary<string, float> hitRecords = new Dictionary<string, float>(); while (timer < totalDuration) { if (caster == null) break; timer += Time.deltaTime; float growProgress = Mathf.Clamp01(timer / growthTime); float currentLogicLen = Mathf.Lerp(startLength, maxLength, growProgress); Vector3 bossCenter = caster.transform.position + Vector3.up * 1.0f; Quaternion bossForwardRot = syncRotationWithBoss ? caster.transform.rotation : Quaternion.identity; for (int i = 0; i < activeLasers.Count; i++) { var laserObj = activeLasers[i]; if (laserObj == null || !laserObj.IsSpawned) continue; laserObj.transform.position = bossCenter; float baseOffset = initialYOffsets[i]; float noiseVal = Mathf.PerlinNoise(Time.time * sweepSpeed, noiseSeeds[i]); float sweepOffset = (noiseVal - 0.5f) * 2f * sweepAmplitude; Quaternion targetRot = bossForwardRot * Quaternion.Euler(0, baseOffset + sweepOffset, 0); laserObj.transform.rotation = targetRot; Vector3 dir = laserObj.transform.forward; RaycastHit[] hits = Physics.SphereCastAll(bossCenter, rayWidth / 2f, dir, currentLogicLen); foreach (var hit in hits) { if (hit.collider.gameObject == caster) continue; if (activeLasers.Contains(hit.collider.GetComponent<NetworkObject>())) continue; if (hit.collider.TryGetComponent<IDamageable>(out var damageable)) { ulong targetId = hit.collider.GetComponent<NetworkObject>().NetworkObjectId; string key = $"{laserObj.NetworkObjectId}_{targetId}"; if (!hitRecords.ContainsKey(key) || (Time.time - hitRecords[key] > damageInterval)) { damageable.TakeDamage(damagePerTick, caster.GetComponent<NetworkObject>().NetworkObjectId); hitRecords[key] = Time.time; } } } } yield return null; } foreach (var laser in activeLasers) { if (laser != null && laser.IsSpawned) laser.Despawn(); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\ExpandingNukeEffect.cs]
using System; using System.Collections; using Unity.Netcode; using UnityEngine; [Serializable] public class ExpandingNukeEffect : SkillEffect { [Header("�˱���ֵ����")] public float damageRadius = 10f; public int killDamage = 9999; public override void Execute(GameObject caster, GameObject target, Vector3 position) { ulong attackerId = 0; if (caster.TryGetComponent<NetworkObject>(out var netObj)) { attackerId = netObj.NetworkObjectId; } Collider[] hits = Physics.OverlapSphere(position, damageRadius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IDamageable>(out var damageable)) { damageable.TakeDamage(killDamage, attackerId); Debug.Log($"[Effect] �˱�����: {hit.name}����� {killDamage} �˺�"); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\FlyingBullet.cs]
using System; using Unity.Netcode; using UnityEngine; using System.Collections; [Serializable] public class FlyingBullet : SkillEffect { [Header("Ͷ��������")] [SerializeField] private NetworkObject _bulletPrefab; public float speed = 10f; public float maxDistance = 20f; public int damage = 15; public float radius = 1f; [Header("ģ������")] [Tooltip("�����ʸ���򲻶ԣ����糯�ϣ�����������Ϊ (90, 0, 0) �� (-90, 0, 0) ����������")] public Vector3 modelRotationOffset = Vector3.zero; public override void Execute(GameObject caster, GameObject target, Vector3 position) { Vector3 spawnPos = caster.transform.position + Vector3.up * 1.5f; Vector3 direction = (position - caster.transform.position).normalized; direction.y = 0; Quaternion lookRotation = Quaternion.LookRotation(direction); Quaternion finalRotation = lookRotation * Quaternion.Euler(modelRotationOffset); var bulletInstance = GameObject.Instantiate(_bulletPrefab, spawnPos, finalRotation); if (bulletInstance.TryGetComponent<ProjectileController>(out var projectile)) { bulletInstance.Spawn(); ulong attackerId = 0; if (caster.TryGetComponent<NetworkObject>(out var casterNet)) { attackerId = casterNet.OwnerClientId; } projectile.Initialize(direction, speed, maxDistance, damage, radius, attackerId, caster); } else { Debug.LogError($"[FlyingBullet] Prefab {bulletInstance.name} ȱ�� ProjectileController �ű�������ء�"); GameObject.Destroy(bulletInstance.gameObject); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\KnockbackEffect.cs]
using System; using UnityEngine; using System.Collections; [Serializable] public class KnockbackEffect : SkillEffect { public float radius = 5f; public float force = 10f; public float stunTime = 0.5f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { Collider[] hits = Physics.OverlapSphere(caster.transform.position, radius); foreach (var hit in hits) { if (hit.gameObject == caster) continue; if (hit.TryGetComponent<IKnockBackable>(out var knockCmpnt)) { Vector3 dir = (hit.transform.position - caster.transform.position).normalized; dir.y = 0.5f; knockCmpnt.ApplyKnockbackServer(dir, force); Debug.Log($"������ {hit.name}"); } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\SkillEffect.cs]
using System; using System.Collections; using Unity.Netcode; using UnityEngine; [Serializable] public abstract class SkillEffect { [Header("��������")] public string effectName; public abstract void Execute(GameObject caster, GameObject target, Vector3 position); } [Serializable] public class DelayEffect : SkillEffect { public float duration = 1.0f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillEffects\TeleportEffect.cs]
using System; using UnityEngine; [Serializable] public class TeleportEffect : SkillEffect { [Header("λ������")] public float distance = 5f; public bool isDash = true; public float duration = 0.2f; public override void Execute(GameObject caster, GameObject target, Vector3 position) { if (!caster.TryGetComponent<PlayerNetworkMovement>(out var movement)) return; Vector3 direction = (position - caster.transform.position).normalized; direction.y = 0; direction.Normalize(); Vector3 targetPos = caster.transform.position + direction * distance; Debug.Log($"[Effect] λ��: {caster.name} �� {direction} �ƶ� {distance}��"); movement.ServerForceDash(direction, distance, duration); } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Skills\SkillSO\SkillDataSO.cs]
using System.Collections.Generic; using Unity.Netcode; using UnityEngine; using System.Collections; [CreateAssetMenu(fileName = "NewSkill", menuName = "Game/Skill Data")] public class SkillDataSO : ScriptableObject { [Header("���ܻ�������")] public float coolDown = 1.0f; [Tooltip("ʩ������/�����뾶����ҽ���˷�Χ��ʱ�����˽�ֹͣ�ƶ�����ʼ����")] public float castRadius = 2.0f; [Header("ǰҡ�׶�")] [Tooltip("ǰҡʱ�䣨�룩����ӦԤ��Ȧʱ��")] public float chargeDuration = 1.5f; [Tooltip("ǰҡ��������")] public string chargeAnimationName = "Idle"; [Tooltip("Ԥ��Ȧ Prefab")] public GameObject warningPrefab; [Tooltip("�����Ӿ���Ч prefab list")] public List<GameObject> chargeVisualPrefabs; [Header("�ͷŽ׶�")] public string skillActiveAnimationName; [SerializeReference, SubclassSelector] public List<SkillEffect> effects = new List<SkillEffect>(); public bool isSelfCentered; [Header("��ҡ�׶�")] public string skillRecoveryAnimationName; public void Cast(GameObject caster, GameObject target, Vector3 position) { if (caster.TryGetComponent<NetworkBehaviour>(out var networkBehaviour)) { networkBehaviour.StartCoroutine(ExecutionRoutine(caster, target, position)); } } private IEnumerator ExecutionRoutine(GameObject caster, GameObject target, Vector3 position) { foreach (var effect in effects) { if (effect is DelayEffect delayEffect) { yield return new WaitForSeconds(delayEffect.duration); } effect.Execute(caster, target, position); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateActive.cs]
using UnityEngine; public class BossStateActive : MonoBehaviour { void Start() { } void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateCharge.cs]
using System; using Unity.Netcode; using UnityEngine; public class BossStateCharge : BossBaseState { private float _timer; private float _duration; public BossStateCharge(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void Enter() { var skillData = _controller.CurrentSkillData; string animName = skillData != null && !string.IsNullOrEmpty(skillData.chargeAnimationName) ? skillData.chargeAnimationName : "Idle"; _view.PlayAnimation(animName); if (_controller.IsServer) { _timer = 0f; _duration = skillData != null ? skillData.chargeDuration : 0f; if (_controller.Agent.isOnNavMesh) _controller.Agent.ResetPath(); if (skillData != null) { Vector3 spawnPos = _controller.transform.position; if (!skillData.isSelfCentered && _controller.Target != null) { spawnPos = _controller.Target.transform.position; } _controller.TriggerChargeVisuals(spawnPos, _duration); } } } public override void Update() { if (_controller.IsServer) { _timer += Time.deltaTime; _controller.RotateTowardsTarget(); if (_timer >= _duration) { _controller.SetState(BossController.BossMotionState.Skill); } } } [ClientRpc] private void SpawnChargeVisualsClientRpc() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateDie.cs]
using UnityEngine; public class BossStateDie : BossBaseState { public BossStateDie(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void Enter() { _view.PlayAnimation("Die"); if (_controller.IsServer) { if (_controller.Agent.isOnNavMesh) _controller.Agent.isStopped = true; _controller.GetComponent<Collider>().enabled = false; } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateIdle.cs]
using UnityEngine; public class BossStateIdle : BossBaseState { public BossStateIdle(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void Enter() { _view.PlayAnimation("Idle"); if (_controller.IsServer) { if (_controller.Agent.isOnNavMesh) _controller.Agent.ResetPath(); } } public override void Update() { if (!_controller.IsServer) return; if (_controller.Target != null) { float dist = Vector3.Distance(_controller.transform.position, _controller.Target.transform.position); if (dist <= _controller.BasicAttackRange) { if (!_controller.TrySelectAndStartAttack()) { } } else { _controller.SetState(BossController.BossMotionState.Chase); } } else { DetectPlayer(); } } private void DetectPlayer() { var hits = Physics.OverlapSphere(_controller.transform.position, _controller.ChaseRange, _controller.ChaseLayer); foreach (var hit in hits) { if (hit.TryGetComponent<PlayerNetworkCore>(out var playerCore) && !playerCore.IsDead) { _controller.SetTarget(hit.GetComponent<Unity.Netcode.NetworkObject>()); return; } } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateMove.cs]
using UnityEngine; public class BossStateMove : BossBaseState { private float _repathTimer = 0f; private float _repathInterval = 0.2f; public BossStateMove(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void Enter() { _view.PlayAnimation("Walk"); if (_controller.IsServer) { if (_controller.Agent.isOnNavMesh) _controller.Agent.isStopped = false; } } public override void Update() { if (!_controller.IsServer) return; if (_controller.Target == null) { _controller.SetState(BossController.BossMotionState.Idle); return; } float dist = Vector3.Distance(_controller.transform.position, _controller.Target.transform.position); if (dist > _controller.ChaseRange * 1.5f) { _controller.SetState(BossController.BossMotionState.Idle); return; } if (dist <= _controller.BasicAttackRange) { if (_controller.TrySelectAndStartAttack()) return; } _repathTimer += Time.deltaTime; if (_repathTimer > _repathInterval) { _repathTimer = 0f; if (_controller.Agent.isOnNavMesh) _controller.Agent.SetDestination(_controller.Target.transform.position); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateRecovery.cs]
using UnityEngine; public class BossStateRecovery : MonoBehaviour { void Start() { } void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\Boss\BossState\BossStateSkill.cs]
using UnityEngine; public class BossStateSkill : BossBaseState { private float _timer; private float _recoveryTime; private bool _hasCast; public BossStateSkill(BossController controller, BossStateMachine sm) : base(controller, sm) { } public override void Enter() { var skillData = _controller.CurrentSkillData; string animName = skillData != null ? skillData.skillActiveAnimationName : "Attack"; _view.PlayAnimation(animName); if (_controller.IsServer) { _timer = 0f; _hasCast = false; _recoveryTime = (_controller.CurrentSkillIdx == 0) ? 1.0f : 2.0f; _controller.RotateTowardsTarget(); } } public override void Update() { if (!_controller.IsServer) return; _timer += Time.deltaTime; if (!_hasCast) { _hasCast = true; var skillData = _controller.CurrentSkillData; if (skillData != null) { Vector3 castPos = _controller.Target != null ? _controller.Target.transform.position : _controller.transform.position; if (skillData.isSelfCentered) castPos = _controller.transform.position; skillData.Cast(_controller.gameObject, _controller.Target != null ? _controller.Target.gameObject : null, castPos); } } if (_timer >= _recoveryTime) { _controller.SetState(BossController.BossMotionState.Idle); } } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateIdle.cs]
using Unity.Netcode; using UnityEngine; public class EnemyStateIdle : IEnemyState { private EnemyPresentation _view; private NetworkObject _target; public EnemyStateIdle(EnemyPresentation view) { _view = view; } public void Enter() { _view.Animator.Play("IdleNormal"); Debug.Log("������� Idle ״̬"); _target = null; } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateMove.cs]
using Unity.Netcode; using UnityEngine; public class EnemyStateMove : IEnemyState { private EnemyPresentation _view; public EnemyStateMove(EnemyPresentation view) { _view = view; } public void Enter() { Debug.Log("�������׷��״̬"); _view.Animator.Play("WalkFWD"); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStatePatrol.cs]
public class EnemyStatePatrol : IEnemyState { public void Enter() { } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateSkillActive.cs]
using UnityEngine; public class EnemyStateSkillActive : IEnemyState { private EnemyPresentation _view; public EnemyStateSkillActive(EnemyPresentation view) { _view = view; } public void Enter() { _view.Animator.CrossFade(_view.SkillAnimationName, 0.1f); } public void Exit() { } public void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\EnemyStateSkillCharge.cs]
using UnityEngine; public class EnemyStateSkillCharge : MonoBehaviour { void Start() { } void Update() { } }
[FILE END]

[FILE START: Assets\Scripts\GameScene\Enemy\NPC\EnemyState\IEnemyState.cs]
using UnityEngine; public interface IEnemyState { void Update(); void Enter(); void Exit(); }
[FILE END]
